[{"categories":["Unity"],"content":"Unity의 새로운 UI 시스템인 UI Toolkit을 알아보자 Unity 로고 ","date":"2023-02-24","objectID":"/2023-02-24_unity_ui_toolkit/:0:0","series":null,"tags":["unity","uitoolkit"],"title":"Unity UI Toolkit 맛보기","uri":"/2023-02-24_unity_ui_toolkit/#"},{"categories":["Unity"],"content":" 1. 핵심요약 유니티에서 UI Toolkit 을 새로운 UI 시스템으로 민단다. 웹을 좀 만져 봤으면 쉽게 적응할 수 있다. (html, css, javascript 각각 uxml, uss, cs 에 대응) 안 쓸 이유가 없다면, 써보자! ","date":"2023-02-24","objectID":"/2023-02-24_unity_ui_toolkit/:1:0","series":null,"tags":["unity","uitoolkit"],"title":"Unity UI Toolkit 맛보기","uri":"/2023-02-24_unity_ui_toolkit/#1-핵심요약"},{"categories":["Unity"],"content":" 2. 기본 소개 및 Unity UI와의 차이점나도 UI Toolkit 이라는 것을 유니티 코리아 유튜브 채널 에서 보고 알게 되었다. 2배속으로 후딱 들어보자. 기존의 Unity UI 와 새로운 UI Toolkit의 차이를 {Unity eBook} User interface design and implementation in Unity에서는 아래와 같이 설명하고 있다. item Unity UI UI Toolkit What is it? A GameObject-based UI system A UI system inspired by web technologies Workflow UI elements are GameObjects inside a Canvas GameObject. They have a Rect Transform component to define position and scale relative to their parent. UXML files define the UI’s layout, and USS files define the styling. UXML files, also known as Visual Trees, are displayed in the Game view through a UI Document component applied to a GameObject. Authoring tool In the Scene view, create UI GameObjects in the Hierarchy and nest them to form layout groups. With UI Builder, create UI Toolkit interfaces consisting of UXML and USS files visually. Styling Use Prefabs and Nested Prefabs to apply the same styling to many UI elements. You can override the Prefab’s settings from the Scene view. Use Selectors (USS files) to define styling and apply to many Visual Elements. Override styles with in-line styles in the Visual Tree elements. Key benefits Integration with other Unity systems, such as Animation, GameObjects, or the position in a 3D space Performance (retained-mode graphics), scalability with complex UI, customizable materials, different screen sizes and theming; works for Editor UI as well as runtime UI; textureless interfaces Best for… Simpler UI elements blended in-game or with very specific needs, i.e., damage points coming from a character in a 3D space or a UI element that needs Physics Recommended for screen overlay menus and HUD elements 인게임 오브젝트랑 밀접하게 연관되어 있는 UI의 경우에는 애매해 보이는데, 나의 경우는 Unity UI도 제대로 써보지 않았으므로, UI Toolkit을 안 쓸 이유가 없다. 써 보자! ","date":"2023-02-24","objectID":"/2023-02-24_unity_ui_toolkit/:2:0","series":null,"tags":["unity","uitoolkit"],"title":"Unity UI Toolkit 맛보기","uri":"/2023-02-24_unity_ui_toolkit/#2-기본-소개-및-unity-ui와의-차이점"},{"categories":["Unity"],"content":" 3. 무작정 따라하기일단 어떤 느낌인지 확인해보자. 아래의 두 유뷰브 정도가 좋아 보였다. {유튜브} Create Game Menu like a PRO using UI Toolkit {유튜브} Unity UI Toolkit in 5 Minutes 위 두 개 정도 봤으면, 이제 충분한 것 같다. 직접 간단한 거 하나 만들어 보자. ","date":"2023-02-24","objectID":"/2023-02-24_unity_ui_toolkit/:3:0","series":null,"tags":["unity","uitoolkit"],"title":"Unity UI Toolkit 맛보기","uri":"/2023-02-24_unity_ui_toolkit/#3-무작정-따라하기"},{"categories":["Unity"],"content":" 3.1. 새 프로젝트 준비새 프로젝트를 만들고, 거대한 프로젝트가 될지도 모르니 멋진 폴더들을 준비하자. 폴더 준비 08_UI 폴더 밑에 PanelSettings, Uss, Uxml 폴더를 준비 했다. ","date":"2023-02-24","objectID":"/2023-02-24_unity_ui_toolkit/:3:1","series":null,"tags":["unity","uitoolkit"],"title":"Unity UI Toolkit 맛보기","uri":"/2023-02-24_unity_ui_toolkit/#31-새-프로젝트-준비"},{"categories":["Unity"],"content":" 3.2. UXML 레이아웃 준비Uxml 폴더에 UI Document 를 하나 만든다. (Project 윈도우 우클릭 \u003e Create \u003e UI Toolkit \u003e UI Document) 이름은 MainMenu 정도로 해 두자. 해당 파일을 더블 클릭하면 UI Builder 윈도우가 열린다. 인터페이스는 아래와 같다. 이미지 출처: {Unity Docs} UI builder - Interface overview 🔷 전체를 담을 Container 준비 ② Hierarchy 패널의 MainMenu.uxml 에다가 ③ Library 패널의 VisualElement 를 하나 끌어다 놓자. 더블 클릭해서 이름을 지정할 수 있는데, 적당히 Container 라고 해 두자. 이제, 실제 게임 화면에서의 배치를 위해 ⑥ Inspector 패널에서 속성 값을 적당히 바꿔 보자. (#Container 고른 상태) - Size - Width: 40%, Height 100% - Margin - Left: 5% - Background - Color : A(alpha) 0.3 바꾼 부분은 흰색으로 표시됨. 되돌리고 싶다면 우클릭해서 Unset 🔷 Logo 부분 VisualElement를 또 끌어와서, #Container 의 자식이 되게 하자. 이름은 Logo. 이미지를 넣어야겠지만, 일단 색깔만 칠해두자. - Size - Height 30% - Background - Color 적당히 붉은 빛 Label 을 하나 끌어다가 #Logo 의 자식으로 두고, “Logo” 라고 Text 를 바꿔준다. - Label - Text : Logo - Text - Font Style: bold - Size: 40 - Color : white 요 텍스트를 가운데에 배치하려면, 부모의 속성 세팅이 필요하다. #Logo 를 골라 아래 세팅을 추가로 하자. - Align - Align Items : center - Justify Content : center Hierarchy 패널에서 #Container 에 마우스를 올렸을 때의 화면이다. 마우스 올린 항목의 영역이 어디인지 margin 포함해서 보여줌 ","date":"2023-02-24","objectID":"/2023-02-24_unity_ui_toolkit/:3:2","series":null,"tags":["unity","uitoolkit"],"title":"Unity UI Toolkit 맛보기","uri":"/2023-02-24_unity_ui_toolkit/#32-uxml-레이아웃-준비"},{"categories":["Unity"],"content":" 3.3. 게임에 해당 UI 추가저장 후 UI Builder 는 잠시 닫아두고, 일단 여기까지를 게임에 붙여보자. Scene 에 빈 GameObject를 만들고 (이름은 적당히 “Main UI”), UI Document 컴포넌트를 추가한다. (Inspector 패널의 Add Component 버튼 \u003e UI Toolkit \u003e UI Document) PanelSettings asset을 요구함 🔷 Panel Settings Panel Settings이 없다고 뭐라고 한다. 08_UI/PanelSettings 폴더로 가서, Panel Settings Asset 를 하나 만들자. (Project 윈도우 우클릭 \u003e Create \u003e UI Toolkit \u003e Panel Settings Asset) 이름은 Default Panel Settings 정도로 두자. 한 화면에 여러 UI 가 있을 때 순서를 어떻게 할 건지, 기본 테마 및 폰트를 어떻게 할건지 등을 세팅하기 위한 에셋으로 보인다. 일단 디폴트로 쓰고 천천히 알아가자. 🔷 UI Document 컴포넌트에 Asset 할당 UI Document 컴포넌트의 Panel Settings 에 방금 만든 Default Panel Settings를 할당하고, Source Asset 에 3.2. UXML 레이아웃 준비 에서 만든 MainMenu 를 할당한다. 이제 우리의 UI가 게임에 나타났다. UI가 게임 화면에 표시됨 ","date":"2023-02-24","objectID":"/2023-02-24_unity_ui_toolkit/:3:3","series":null,"tags":["unity","uitoolkit"],"title":"Unity UI Toolkit 맛보기","uri":"/2023-02-24_unity_ui_toolkit/#33-게임에-해당-ui-추가"},{"categories":["Unity"],"content":" 3.4. UXML 레이아웃 - 버튼 영역MainMenu 를 더블 클릭해서 UI Builder 로 편집을 계속하자. VisualElement 하나를 더 #Container 자식으로 추가한다. 더블 클릭해서 이름은 Buttons 라고 하자. - Flex - Grow: 1 위 세팅을 추가하면, 남은 영역을 꽉 채우게 된다. - Align - Align Items : center - Justify Content : space-around #Buttons의 자식들을 어떻게 배치할 건지를 위해 위 세팅도 추가하자. #Buttons 의 자식으로 Button 세개를 추가하고, 각각 PlayButton, SettingButton, ExitButton 라고 이름을 붙인다. Inspector 패널의 Button - Text 도 각각 “Play”, “Setting”, “Exit” 로 바꿔준다. 이제 #Buttons 의 Align 아래의 Align Items, Justify Content 를 바꿔가면서 버튼들의 배치가 어떻게 달라지는지 확인해보자. 이 부분이 VisualElement의 레이아웃 배치에 근간이 되는 Flexbox 에 대한 부분이다. {1분코딩} 이번에야말로 CSS Flex를 익혀보자 요 블로그의 내용이 좋았던 걸로 기억한다. 요 내용을 이해해야 UI Toolkit도 마음대로 사용할 수 있으니 제대로 숙지해 두자. 이미지 출처: {1분코딩} 이번에야말로 CSS Flex를 익혀보자 이미지 출처: {1분코딩} 이번에야말로 CSS Flex를 익혀보자 이미지 출처: {1분코딩} 이번에야말로 CSS Flex를 익혀보자 이미지 출처: {1분코딩} 이번에야말로 CSS Flex를 익혀보자 flex-glow. 이미지 출처: {1분코딩} 이번에야말로 CSS Flex를 익혀보자 ","date":"2023-02-24","objectID":"/2023-02-24_unity_ui_toolkit/:3:4","series":null,"tags":["unity","uitoolkit"],"title":"Unity UI Toolkit 맛보기","uri":"/2023-02-24_unity_ui_toolkit/#34-uxml-레이아웃---버튼-영역"},{"categories":["Unity"],"content":" 3.5. USS로 스타일링이제 버튼들에 스타일을 적용해 보자. 🔷 버튼 항목에 클래스 지정 #PlayButton, #SettingButton, #ExitButton 에 menu-button 이라고 class 를 지정 해 준다. Heirarcy 패널에서 해당 버튼을 고른 상태에서 Inspector 패널의 Style Class List 에 원하는 키워드를 추가하면 된다. USS 파일에서 여기서 지정한 class 단위로 스타일을 지정한다. 버튼 항목에 class 추가 .menu-button 이 추가 되었다. class 추가됨 🔷 USS 파일 추가 StyleSheets 패널의 + 버튼을 눌러 USS 파일을 추가할 수 있다. USS 파일 추가 메뉴 08_UI/Uss 폴더에 MainMenu 라는 이름으로 만들자. 🔷 셀렉터 추가 MainMenu.uss 를 고른 상태에서, Inspector 에서 Selector 를 추가할 수 있다. menu-button 이라는 클래스를 추가해둔 버튼들에 스타일을 적용하고 싶으므로 .menu-button 을 추가한다. (.은 문서에 여러개 있어도 괜찮은 class, #은 유니크한 id를 의미함) Selector 추가 🔷 버튼 스타일링 추가한 셀렉터 .menu-button 에 마우스를 올려보면, 버튼 3개 모두 하이라이팅 되는 것을 볼 수 있다. 셀렉터에 마우스 올리면 해당하는 항목 보여줌 요 셀렉터를 고른 상태에서 속성을 바꾸면, 해당 클래스를 가진 모든 아이템들에 공통으로 적용된다. - Text - Font Style : bold - Size: 30 - Color : white - Background - Color : alpha 0 - Border - Color : alpha 0 - Transform - Rotate : -5 버튼들에 스타일 일괄 적용됨 🔷버튼 눌렸을 때 스타일링 이제 버튼이 눌렸을 때의 스타일링을 해보자. 마우스가 올라갔을 때:hover는 모바일에서 의미가 없으니, 눌렸을 때인 :active 에 변화를 줘 보자. (요런걸 Pseudo-class 라고 하고, {Unity Docs} Pseudo-classes에서 유니티에서 사용가능한 다른 항목들도 확인할 수 있다.) StyleSheets 패널에서 MainMenu.uss 을 고르고, Inspector 패널에서 .menu-button:active 셀렉터를 추가한다. 생성된 .menu-button:active 을 고르고 아래 속성을 추가한다. - Text - Size: 25 - Color : red - Transform - Rotate : 0 (다른 값으로 바꿔서 흰색이 표시되게 한 후, 0으로 세팅) Preview 를 체크해서 버튼을 눌러 보면, 반응을 확인할 수 있다. Play 버튼 눌렀을 때 변화 확인 ","date":"2023-02-24","objectID":"/2023-02-24_unity_ui_toolkit/:3:5","series":null,"tags":["unity","uitoolkit"],"title":"Unity UI Toolkit 맛보기","uri":"/2023-02-24_unity_ui_toolkit/#35-uss로-스타일링"},{"categories":["Unity"],"content":" 3.7. 코드 연결하기이제 버튼이 눌렸을 때, 실제 실행한 로직을 연결할 차례이다. 02_Scripts/UI 폴더를 만들어서 MainUiController 정도의 이름으로 스크립트를 추가하자. (우클릭 \u003e Create \u003e C# Script) 만든 스크립트를 Scene 의 Main UI 오브젝트에 컴포넌트로 추가해 준다. Main UI에 스크립트 추가 이제 버튼이 눌렸을 때 실행될 로직을 연결해 보자. using UnityEngine; using UnityEngine.UIElements; public class MainUiController : MonoBehaviour { private UIDocument _doc; // 요 스크립트와 같은 게임 오브젝트에 있는 UI Document 컴포넌트 할당용 private Button _playButton; private Button _settingButton; private Button _exitButton; private void Awake() { _doc = GetComponent\u003cUIDocument\u003e(); // 각 버튼의 가져옴 _playButton = _doc.rootVisualElement.Q\u003cButton\u003e(\"PlayButton\"); _settingButton = _doc.rootVisualElement.Q\u003cButton\u003e(\"SettingButton\"); _exitButton = _doc.rootVisualElement.Q\u003cButton\u003e(\"ExitButton\"); // 콜백 연결 _playButton.clicked += PlayButtonClicked; _settingButton.clicked += SettingButtonClicked; _exitButton.clicked += ExitButtonClicked; } private void PlayButtonClicked() { Debug.Log(\"PlayButtonClicked\"); } private void SettingButtonClicked() { Debug.Log(\"SettingButtonClicked\"); } private void ExitButtonClicked() { Debug.Log(\"ExitButtonClicked\"); Application.Quit(); } } 각 버튼은 UI Builder 에서 지었던 이름(#PlayButton 으로 보이던) 으로 가져올 수 있다. _playButton = _doc.rootVisualElement.Q\u003cButton\u003e(\"PlayButton\"); Play 해보면, Console 윈도우에 로그가 잘 찍히면 성공이다! ","date":"2023-02-24","objectID":"/2023-02-24_unity_ui_toolkit/:3:6","series":null,"tags":["unity","uitoolkit"],"title":"Unity UI Toolkit 맛보기","uri":"/2023-02-24_unity_ui_toolkit/#37-코드-연결하기"},{"categories":["Unity"],"content":" 4. 더 알아보기유니티에서 준비한 훌륭한 샘플(UI Toolkit Sample – Dragon Crashers)이 있으니, 뜯어보고 비슷하게 사용하면 좋을 듯 하다. 이미지 출처: {유니티 블로그} Try the new UI Toolkit sample – now available on the Asset Store ","date":"2023-02-24","objectID":"/2023-02-24_unity_ui_toolkit/:4:0","series":null,"tags":["unity","uitoolkit"],"title":"Unity UI Toolkit 맛보기","uri":"/2023-02-24_unity_ui_toolkit/#4-더-알아보기"},{"categories":["Unity"],"content":" Reference {유튜브} [유니티 TIPS] 새로워진 유니티 UI Tool kit, 완벽정복 성공?! {유튜브} Create Game Menu like a PRO using UI Toolkit {유튜브} Unity UI Toolkit in 5 Minutes {1분코딩} 이번에야말로 CSS Flex를 익혀보자 {Unity Docs} Comparison of UI systems in Unity {Unity Docs} UI builder - Interface overview {Unity Docs} pseudo-class {Unity Blog} Try the new UI Toolkit sample – now available on the Asset Store {Unity Asset Store} UI Toolkit Sample – Dragon Crashers {Unity Feature} Unity UI Toolkit {Unity Blog} UI Toolkit at runtime: Get the breakdown {Unity eBook} User interface design and implementation in Unity ","date":"2023-02-24","objectID":"/2023-02-24_unity_ui_toolkit/:5:0","series":null,"tags":["unity","uitoolkit"],"title":"Unity UI Toolkit 맛보기","uri":"/2023-02-24_unity_ui_toolkit/#reference"},{"categories":["Machine Learning"],"content":"거리를 측정하는 모델은 feature 간의 scale이 다른게 영향을 주지 않도록 정규화가 필요하다. sklearn의 StandardScalier 를 알아보자. ","date":"2023-02-09","objectID":"/2023-02-09_pandas_normalization/:0:0","series":null,"tags":["python","sklearn"],"title":"데이터 정규화 - skearn StandardScaler","uri":"/2023-02-09_pandas_normalization/#"},{"categories":["Machine Learning"],"content":" 핵심 요약 sklearn.preprocessing 에 여러 scaler가 준비되어 있음 fit_transform() 으로 테스트셋에 대해 fit 과 transform 수행 transform() 으로 테스트셋에 대해서 정규화 수행 원래의 스케일로 변환해주는 inverse_transform() 도 있음 from sklearn.preprocessing import StandardScaler scaler = StandardScaler() # fit + transform scaler.fit_transform(X_train) # transform scaler.transform(X_test) # inverse stransform scaler.inverse_transform(sample) ","date":"2023-02-09","objectID":"/2023-02-09_pandas_normalization/:1:0","series":null,"tags":["python","sklearn"],"title":"데이터 정규화 - skearn StandardScaler","uri":"/2023-02-09_pandas_normalization/#핵심-요약"},{"categories":["Machine Learning"],"content":" 정규화의 필요성 출처: scikit-learn Example 왼쪽의 산포도를 보면 x축의 범위는 [0, 1700] 인데, y축은 [0, 2] 범위 안에 있다. 두 점간의 거리를 잰다고 했을때, y값의 차이는 x값의 차이에 비해 아주 작을 것이서, 거의 영향을 주지 못하게 된다. 오른쪽은 scale 을 맞춰준 상황이다. 이제 두 feature가 비슷한 조건으로 학습에 사용될 수 있다. ","date":"2023-02-09","objectID":"/2023-02-09_pandas_normalization/:2:0","series":null,"tags":["python","sklearn"],"title":"데이터 정규화 - skearn StandardScaler","uri":"/2023-02-09_pandas_normalization/#정규화의-필요성"},{"categories":["Machine Learning"],"content":" sklearn의 정규화 클래스scikit learn 사이트의 Compare the effect of different scalers on data with outliers 에서 주요 scaler 들이 어떻게 값을 바꿔주는지 보여주고 있다. StandardScaler : 평균 0, 표준편차 1 이 되게 scaling MinMaxScaler : 최소값 -\u003e 0, 최대값 -\u003e 1 이 되도록 scaling [0, 1] MaxAbsScaler : 최대절대값 -\u003e 1 이 되도록 scaling [0, 1] ","date":"2023-02-09","objectID":"/2023-02-09_pandas_normalization/:3:0","series":null,"tags":["python","sklearn"],"title":"데이터 정규화 - skearn StandardScaler","uri":"/2023-02-09_pandas_normalization/#sklearn의-정규화-클래스"},{"categories":["Machine Learning"],"content":" StandardScaler 적용 예시Click here to view this notebook in full screen ","date":"2023-02-09","objectID":"/2023-02-09_pandas_normalization/:4:0","series":null,"tags":["python","sklearn"],"title":"데이터 정규화 - skearn StandardScaler","uri":"/2023-02-09_pandas_normalization/#standardscaler-적용-예시"},{"categories":["Machine Learning"],"content":" Reference {scikit-learn API} StandardScaler {scikit-learn Example} Importance of Feature Scaling {scikit-learn Example} Compare the effect of different scalers on data with outliers ","date":"2023-02-09","objectID":"/2023-02-09_pandas_normalization/:5:0","series":null,"tags":["python","sklearn"],"title":"데이터 정규화 - skearn StandardScaler","uri":"/2023-02-09_pandas_normalization/#reference"},{"categories":["flutter"],"content":"AppBar 를 화면 위에 고정시켜두면 뭔가 화면을 비효율적으로 쓰는 느낌이다. 이미 많은 앱들이 AppBar 도 같이 스크롤 되게 동작하고 있었다. Flutter에는 이러한 동작을 위해 CustomScrollView, SliverAppBar 가 준비되어 있다. Flutter ","date":"2023-02-08","objectID":"/2023-02-08_flutter-sliverappbar/:0:0","series":null,"tags":["flutter"],"title":"Flutter, SliverAppBar로 AppBar도 같이 스크롤","uri":"/2023-02-08_flutter-sliverappbar/#"},{"categories":["flutter"],"content":" 핵심 요약 CustomScrollView 의 slivers 안에 SliverAppBar 배치 그 다음으로 주로 SliverList로 list형 자료를 표현 개별 항목이 필요하면 SliverToBoxAdapter CustomScrollView( slivers: [ SliverAppBar( // 오늘의 주인공!! expandedHeight: 100.0, // 전체 보였을때 크기 flexibleSpace: FlexibleSpaceBar( // 확장되는 영역 title: Text('SilverAppBar Example'), background: FlutterLogo(), ), ), SliverList( // 리스트형 자료 표현 delegate: SliverChildBuilderDelegate( // 빌더 사용해서 효율적으로 (BuildContext context, int index) { return Placeholder(); // index와 리스트 이용해서 해당 아이템 표현 }, childCount: 10, // 리스트의 아이템 개수 ), ), SliverToBoxAdapter( // 단일 위젯은 요걸로 child: Placeholder(), // 개별 위젯 ), ], ), 결과 예시 맨 위의 AppBar도 같이 스크롤 된다. ","date":"2023-02-08","objectID":"/2023-02-08_flutter-sliverappbar/:1:0","series":null,"tags":["flutter"],"title":"Flutter, SliverAppBar로 AppBar도 같이 스크롤","uri":"/2023-02-08_flutter-sliverappbar/#핵심-요약"},{"categories":["flutter"],"content":" SliverAppBar의 세부 옵션파라미터가 많다. 그 중에서도 floating, pinned, snap이 동작에 큰 영향을 주는 듯 하다. floating: 위로 스크롤 했을때 SliverAppBar가 나오는지 여부. (default: false) pinned: 아래로 스크롤 했을때 title 이 남아 있는지 여부 (default: false) snap: 살짝만 스크롤해도 SliverAppBar를 전체로 확장/축소하는지 여부. floating가 true 일때만 의미 있음 (default: false) 설명만으로는 살짝 부족한데, SliverAppBar API 문서의 예제 에서 옵션에 따른 차이를 바로 확인해 볼 수 있다. 필요하다고 느껴지면 살펴보도록 하자. ","date":"2023-02-08","objectID":"/2023-02-08_flutter-sliverappbar/:2:0","series":null,"tags":["flutter"],"title":"Flutter, SliverAppBar로 AppBar도 같이 스크롤","uri":"/2023-02-08_flutter-sliverappbar/#sliverappbar의-세부-옵션"},{"categories":["flutter"],"content":" Dartpad에서 확인적당히 바꿔서 테스트도 해보자. 아래쪽에 배너광고를 넣을까 싶어서 Column으로 감싸 주었고, 아래쪽의 Fixed Widgets 의 사이즈를 정하고, 나머지 부분을 CustomScrollView가 모두 차지하도록 Expanded로 감쌌다. ","date":"2023-02-08","objectID":"/2023-02-08_flutter-sliverappbar/:3:0","series":null,"tags":["flutter"],"title":"Flutter, SliverAppBar로 AppBar도 같이 스크롤","uri":"/2023-02-08_flutter-sliverappbar/#dartpad에서-확인"},{"categories":["flutter"],"content":" Etcsliver의 단어 뜻 sliver a very small, thin piece of something, usually broken off something larger Cambridge Dictionary sliver 가늘고 긴 조각. 쪼개진 조각 다음 사전 ","date":"2023-02-08","objectID":"/2023-02-08_flutter-sliverappbar/:4:0","series":null,"tags":["flutter"],"title":"Flutter, SliverAppBar로 AppBar도 같이 스크롤","uri":"/2023-02-08_flutter-sliverappbar/#etc"},{"categories":["flutter"],"content":" Reference {API 문서} SilverAppBar class {API 문서} CustomScrollView class {티스토리 블로그} CustomScrollView / 코딩전사의 기록 {외국 블로그} How to add SliverAppBar to your Flutter app {Flutter Cookbook} Place a floating app bar above a list ","date":"2023-02-08","objectID":"/2023-02-08_flutter-sliverappbar/:5:0","series":null,"tags":["flutter"],"title":"Flutter, SliverAppBar로 AppBar도 같이 스크롤","uri":"/2023-02-08_flutter-sliverappbar/#reference"},{"categories":["flutter"],"content":"Flutter 3.7 이 발표 되었단다. 기왕이면 최신 버전을 쓰자. 뭔가 좋아 졌겠지. ","date":"2023-02-05","objectID":"/2023-02-05_flutter-upgrade/:0:0","series":null,"tags":["flutter"],"title":"Flutter 버전 업그레이드","uri":"/2023-02-05_flutter-upgrade/#"},{"categories":["flutter"],"content":" 핵심 요약# 현재 채널 및 버전 확인 \u003e flutter --version # 채널 변경 (optional) \u003e flutter channel stable # 업그레이드 \u003e flutter upgrade # 작업 프로젝트의 패키지 업그레이드 (좀 오래 걸리니 -v 옵션 추가해서 로그 출력) \u003e flutter -v pub get ","date":"2023-02-05","objectID":"/2023-02-05_flutter-upgrade/:1:0","series":null,"tags":["flutter"],"title":"Flutter 버전 업그레이드","uri":"/2023-02-05_flutter-upgrade/#핵심-요약"},{"categories":["flutter"],"content":" 현재 채널 및 버전 확인flutter doctor 혹은 flutter --version 으로 현재 사용하고 채널과 flutter 버전을 확인할 수 있다. \u003e flutter doctor # Output Doctor summary (to see all details, run flutter doctor -v): [√] Flutter (Channel stable, 3.3.9, on Microsoft Windows [Version 10.0.19045.2486], locale ko-KR) [!] Visual Studio - develop for Windows (Visual Studio Community 2019 16.11.4) X Visual Studio is missing necessary components. Please re-run the Visual Studio installer for the \"Desktop development with C++\" workload, and include these components: MSVC v142 - VS 2019 C++ x64/x86 build tools - If there are multiple build tool versions available, install the latest C++ CMake tools for Windows Windows 10 SDK [√] Android Studio (version 2021.3) [√] VS Code (version 1.75.0) [√] Connected device (3 available) [√] HTTP Host Availability 필자의 경우, stable 채널을 쓰고 있었고, Flutter 3.3.9 버전을 사용하고 있었다. 3.7이 나왔다고 하고, 특별히 안 올릴 이유가 없으니, 사용 Flutter 버전을 올리기로 했다. 혹, stable 채널이 아니라, beta 채널을 사용 중이면, flutter channel stable 명령으로 채널을 변경할 수 있다. ","date":"2023-02-05","objectID":"/2023-02-05_flutter-upgrade/:2:0","series":null,"tags":["flutter"],"title":"Flutter 버전 업그레이드","uri":"/2023-02-05_flutter-upgrade/#현재-채널-및-버전-확인"},{"categories":["flutter"],"content":" 업그레이드그냥 flutter upgrade 명령만 내리면 끝. 사용하고 있는 채널의 최신 버전으로 flutter를 업그레이드 한다. \u003e flutter upgrade # Output Upgrading Flutter to 3.7.1 from 3.3.9 in C:\\flutter... Checking Dart SDK version... Downloading Dart SDK from Flutter engine 800594f1f4a6674010a6f1603c07a919b4d7ebd7... Expanding downloaded archive... Building flutter tool... Running pub upgrade... Upgrading engine... Downloading android-arm-profile/windows-x64 tools... 2,185ms Downloading android-arm-release/windows-x64 tools... 505ms # ... Flutter 3.7.1 • channel stable • https://github.com/flutter/flutter.git Framework • revision 7048ed95a5 (3 days ago) • 2023-02-01 09:07:31 -0800 Engine • revision 800594f1f4 Tools • Dart 2.19.1 • DevTools 2.20.1 Running flutter doctor... Doctor summary (to see all details, run flutter doctor -v): [√] Flutter (Channel stable, 3.7.1, on Microsoft Windows [Version 10.0.19045.2486], locale ko-KR) ","date":"2023-02-05","objectID":"/2023-02-05_flutter-upgrade/:3:0","series":null,"tags":["flutter"],"title":"Flutter 버전 업그레이드","uri":"/2023-02-05_flutter-upgrade/#업그레이드"},{"categories":["flutter"],"content":" 작업 중인 프로젝트 pug getFlutter 업그레이드 후, 작업 중인 프로젝트를 빌드 하는데 pug get 에서 반응이 없었다. 괜히 빨리 업그레이드 했나 후회하고 있었는데, 알고보니 첫 빌드가 그냥 오래 걸린 것이었다. (필자의 경우는 한 3분 정도 걸렸던 것 같다.) 자세한 로그를 출력하면서 진행하도록 flutter -v pug get 을 한 번 해주도록 하자. \u003e flutter -v pug get ","date":"2023-02-05","objectID":"/2023-02-05_flutter-upgrade/:4:0","series":null,"tags":["flutter"],"title":"Flutter 버전 업그레이드","uri":"/2023-02-05_flutter-upgrade/#작업-중인-프로젝트-pug-get"},{"categories":["flutter"],"content":" Flutter 3.7 주요 수정 사항What’s new in Flutter 3.7 블로그에 따르면, Material 3 update 랑 iOS 개선이 큰 축으로 보인다. Material 3 샘플에서 Material 2 와 Material 3 를 토글해가면서 확인해 볼 수 있다. ","date":"2023-02-05","objectID":"/2023-02-05_flutter-upgrade/:5:0","series":null,"tags":["flutter"],"title":"Flutter 버전 업그레이드","uri":"/2023-02-05_flutter-upgrade/#flutter-37-주요-수정-사항"},{"categories":["flutter"],"content":" Reference {Flutter 공식 문서} Upgrading Flutter {Medium 블로그} What’s new in Flutter 3.7 {Flutter Samples} Material 3 ","date":"2023-02-05","objectID":"/2023-02-05_flutter-upgrade/:6:0","series":null,"tags":["flutter"],"title":"Flutter 버전 업그레이드","uri":"/2023-02-05_flutter-upgrade/#reference"},{"categories":["Machine Learning"],"content":"DataFrame의 열 혹은 행에 특정 함수를 적용하고 싶을때는 apply()를 사용한다. ","date":"2023-01-31","objectID":"/2023-01-31_pandas_apply/:0:0","series":null,"tags":["python","pandas"],"title":"Pandas DataFrame 함수 매핑 - apply()","uri":"/2023-01-31_pandas_apply/#"},{"categories":["Machine Learning"],"content":" 1. 핵심 요약DataFrame.apply() 를 이용해, 열별 혹은 행별로 함수를 적용할 수 있다. 열별로 함수 적용 - 4. DataFrame의 각 열에 함수 매핑 def min_max(x: pd.Series) -\u003e float: return x.max() - x.min() result = df.apply(min_max) # axis=0 은 기본 값이므로 생략 가능 행별로 함수 적용 (axis=1) - 5. DataFrame의 각 행에 함수 매핑 - apply() df['add'] = df.apply(lambda x : x['age'] + x['fare'], axis=1) # lambda 활용 ","date":"2023-01-31","objectID":"/2023-01-31_pandas_apply/:1:0","series":null,"tags":["python","pandas"],"title":"Pandas DataFrame 함수 매핑 - apply()","uri":"/2023-01-31_pandas_apply/#1-핵심-요약"},{"categories":["Machine Learning"],"content":" 2. Series의 개별 원소에 함수 매핑 - apply()Series 객체의 개별 원소에 함수를 적용하는 경우이다. 각 원소에 함수를 적용해서 만들어진 Series를 반환해준다. Click here to view this notebook in full screen ","date":"2023-01-31","objectID":"/2023-01-31_pandas_apply/:2:0","series":null,"tags":["python","pandas"],"title":"Pandas DataFrame 함수 매핑 - apply()","uri":"/2023-01-31_pandas_apply/#2-series의-개별-원소에-함수-매핑---apply"},{"categories":["Machine Learning"],"content":" 3. DataFrame의 모든 개별 원소에 함수 매핑 - applymap()DataFrame의 개별 원소에 특정 함수를 매핑하려면, applymap() 메소드를 활용한다. Click here to view this notebook in full screen ","date":"2023-01-31","objectID":"/2023-01-31_pandas_apply/:3:0","series":null,"tags":["python","pandas"],"title":"Pandas DataFrame 함수 매핑 - apply()","uri":"/2023-01-31_pandas_apply/#3-dataframe의-모든-개별-원소에-함수-매핑---applymap"},{"categories":["Machine Learning"],"content":" 4. DataFrame의 각 열에 함수 매핑 - apply()DataFrame의 apply(매핑함수, axis=0) 메소드를 호출하면, DataFrame의 각 열을 매핑 함수의 인자로 전달한다. 매핑 함수의 return type에 따라 결과 type이 달라진다. Series를 리턴하는 함수 매핑 -\u003e DataFrame 반환 값을 리턴하는 함수 매핑 -\u003e Series 반환 Click here to view this notebook in full screen ","date":"2023-01-31","objectID":"/2023-01-31_pandas_apply/:4:0","series":null,"tags":["python","pandas"],"title":"Pandas DataFrame 함수 매핑 - apply()","uri":"/2023-01-31_pandas_apply/#4-dataframe의-각-열에-함수-매핑---apply"},{"categories":["Machine Learning"],"content":" 5. DataFrame의 각 행에 함수 매핑 - apply()axis=1을 적용하면, DataFrame의 각 행을 매핑 함수의 인자로 전달한다. 인자로 넘기는 Series의 index가 원래 DataFrame의 colums 라서 axis=1 이다. Click here to view this notebook in full screen ","date":"2023-01-31","objectID":"/2023-01-31_pandas_apply/:5:0","series":null,"tags":["python","pandas"],"title":"Pandas DataFrame 함수 매핑 - apply()","uri":"/2023-01-31_pandas_apply/#5-dataframe의-각-행에-함수-매핑---apply"},{"categories":["Machine Learning"],"content":" 6. DataFrame 객체 자체에 함수 매핑 - pipe()DataFrame 객체에 함수를 매핑하려면 pipe() 메소드를 활용한다. 매핑 함수의 return type에 따라 결과 type 이 달라진다. DataFrame을 리턴하는 함수 매핑 -\u003e DataFrame 반환 Series를 리턴하는 함수 매핑 -\u003e Series 반환 값을 리턴하는 함수 매핑 -\u003e 값 반환 Click here to view this notebook in full screen ","date":"2023-01-31","objectID":"/2023-01-31_pandas_apply/:6:0","series":null,"tags":["python","pandas"],"title":"Pandas DataFrame 함수 매핑 - apply()","uri":"/2023-01-31_pandas_apply/#6-dataframe-객체-자체에-함수-매핑---pipe"},{"categories":["Machine Learning"],"content":" Reference {책} 파이썬 머신러닝 판다스 데이터 분석 / 오승환 - 6.1 함수 매핑 {Pandas User Guide} Essential basic functionality - Function application ","date":"2023-01-31","objectID":"/2023-01-31_pandas_apply/:7:0","series":null,"tags":["python","pandas"],"title":"Pandas DataFrame 함수 매핑 - apply()","uri":"/2023-01-31_pandas_apply/#reference"},{"categories":["Machine Learning"],"content":"DataFrame을 특정 열의 값들 기준으로 그룹화 해서 살펴보는 경우가 많다. groupby()를 알아보자. ","date":"2023-01-27","objectID":"/2023-01-27_pandas_groupby/:0:0","series":null,"tags":["python","pandas"],"title":"Pandas DataFrame 그룹 연산 - groupby()","uri":"/2023-01-27_pandas_groupby/#"},{"categories":["Machine Learning"],"content":" 1. 기본 사용법1개의 열을 기준으로 그룹화 df.groupby(['class'])[['age', 'fare']].mean().reset_index() class 열 기준으로 그룹화 age, fare 열이 관심 있음 각 열에 대해서 mean() 집계 reset_index() 하면 결과 DataFrame을 또 조작하기 용이함 2개의 열을 기준으로 그룹화 df.groupby(['class', 'sex']).mean().reset_index() ","date":"2023-01-27","objectID":"/2023-01-27_pandas_groupby/:1:0","series":null,"tags":["python","pandas"],"title":"Pandas DataFrame 그룹 연산 - groupby()","uri":"/2023-01-27_pandas_groupby/#1-기본-사용법"},{"categories":["Machine Learning"],"content":" 2. 세부 동작 확인groupby() 만 하면 그룹별로 DataFrame을 갖고 있는 상태이고, 거기에 mean() 같은 집계 합수를 적용한 뒤, 다시 합쳐서 테이블로 보여주게 된다. 아래 노트북을 살펴보자 Click here to view this notebook in full screen ","date":"2023-01-27","objectID":"/2023-01-27_pandas_groupby/:2:0","series":null,"tags":["python","pandas"],"title":"Pandas DataFrame 그룹 연산 - groupby()","uri":"/2023-01-27_pandas_groupby/#2-세부-동작-확인"},{"categories":["Machine Learning"],"content":" 3. 여러 열 기준으로 그룹화아래 노트북은 여러 열 기준으로 그룹화 하는 예제이다. Click here to view this notebook in full screen ","date":"2023-01-27","objectID":"/2023-01-27_pandas_groupby/:3:0","series":null,"tags":["python","pandas"],"title":"Pandas DataFrame 그룹 연산 - groupby()","uri":"/2023-01-27_pandas_groupby/#3-여러-열-기준으로-그룹화"},{"categories":["Machine Learning"],"content":" 4. 사용자 집계 함수 사용집계함수로는 mean(), max(), min(), sum(), count(), size(), var(), std(), describe(), info(), first(), last() 등이 지원된다. agg()를 사용하여, 여러 집계 함수를 동시에 적용하거나, 사용자 함수를 집계 함수로 사용할 수 있다. 열별로 다른 함수를 적용 하는 것도 가능하다. Click here to view this notebook in full screen ","date":"2023-01-27","objectID":"/2023-01-27_pandas_groupby/:4:0","series":null,"tags":["python","pandas"],"title":"Pandas DataFrame 그룹 연산 - groupby()","uri":"/2023-01-27_pandas_groupby/#4-사용자-집계-함수-사용"},{"categories":["Machine Learning"],"content":" Reference {책} 파이썬 머신러닝 판다스 데이터 분석 / 오승환 - 6.5 그룹 연산 {Pandas User Guide} 10minutes to pandas ","date":"2023-01-27","objectID":"/2023-01-27_pandas_groupby/:5:0","series":null,"tags":["python","pandas"],"title":"Pandas DataFrame 그룹 연산 - groupby()","uri":"/2023-01-27_pandas_groupby/#reference"},{"categories":["Machine Learning"],"content":"두 DataFrame을 위아래로 합칠때는 pd.concat(), 특정 열을 기준으로 join 할 때는 pd.merge()를 사용하자. ","date":"2023-01-26","objectID":"/2023-01-26_pandas_concat_merge/:0:0","series":null,"tags":["python","pandas"],"title":"Pandas DataFrame 합치기 - concat()과 merge()","uri":"/2023-01-26_pandas_concat_merge/#"},{"categories":["Machine Learning"],"content":" pd.concat()여러 소스를 통해 얻은(ex. 다른 csv 파일) 데이터 프레임들을 위아래로 합치고 싶은 상황이다. 아래 코드로 합칠 수 있다. pd.concat([df1, df2], ignore_index=True) 아래 노트북은 pd.concat() 참고 예시 Click here to view this notebook in full screen 보통은 인덱스를 새로 매겨야 하는 경우가 많아서, ignore_index=True 를 많이 사용할 듯 하다. ","date":"2023-01-26","objectID":"/2023-01-26_pandas_concat_merge/:1:0","series":null,"tags":["python","pandas"],"title":"Pandas DataFrame 합치기 - concat()과 merge()","uri":"/2023-01-26_pandas_concat_merge/#pdconcat"},{"categories":["Machine Learning"],"content":" pd.merge()pd.merge(df_left, df_right, how='inner', left_on='name', right_on='member') SQL에서 테이블 조인하는 느낌이다. pd.join()이 또 있기는 한데, pd.merge()가 주로 쓰인다고 한다. 아래 노트북은 pd.merge() 참고 예시 Click here to view this notebook in full screen ","date":"2023-01-26","objectID":"/2023-01-26_pandas_concat_merge/:2:0","series":null,"tags":["python","pandas"],"title":"Pandas DataFrame 합치기 - concat()과 merge()","uri":"/2023-01-26_pandas_concat_merge/#pdmerge"},{"categories":["Machine Learning"],"content":" Reference {책} 파이썬 머신러닝 판다스 데이터 분석 / 오승환 - 6.4 데이터프레임 합치기 {Pandas User Guide} 10minutes to pandas ","date":"2023-01-26","objectID":"/2023-01-26_pandas_concat_merge/:3:0","series":null,"tags":["python","pandas"],"title":"Pandas DataFrame 합치기 - concat()과 merge()","uri":"/2023-01-26_pandas_concat_merge/#reference"},{"categories":["Machine Learning"],"content":"특정 조건에 해당하는 행들만 필터링 하는 것을 boolean indexing 이라고 한다. isin() 메소드도 유용하다. ","date":"2023-01-25","objectID":"/2023-01-25_pandas_filter/:0:0","series":null,"tags":["python","pandas"],"title":"Pandas DataFrame 필터링 - boolean indexing 과 isin() 메소드","uri":"/2023-01-25_pandas_filter/#"},{"categories":["Machine Learning"],"content":" 1. boolean indexing아래 노트북처럼 각 행을 True, False 로 판단하는 mask를 준비하고, df.loc() 로 해당 행들만 필터링한다. Click here to view this notebook in full screen Out [2]에서 True로 마킹된 행이 102 행이고, Out [3]에서 보면 102행이 출력되었다. ","date":"2023-01-25","objectID":"/2023-01-25_pandas_filter/:1:0","series":null,"tags":["python","pandas"],"title":"Pandas DataFrame 필터링 - boolean indexing 과 isin() 메소드","uri":"/2023-01-25_pandas_filter/#1-boolean-indexing"},{"categories":["Machine Learning"],"content":" 2. isin() 메소드 사용Series.isin()을 이용해서 조건을 명시할 수도 있다. Click here to view this notebook in full screen and(\u0026)를 이용해 mask 를 준비한 경우와 isin()을 사용하는 경우의 결과가 동일하다. 경우에 따라 isin()을 쓰는게 조건을 더 알기 쉽게 표현할 수 있을 것으로 보인다. ","date":"2023-01-25","objectID":"/2023-01-25_pandas_filter/:2:0","series":null,"tags":["python","pandas"],"title":"Pandas DataFrame 필터링 - boolean indexing 과 isin() 메소드","uri":"/2023-01-25_pandas_filter/#2-isin-메소드-사용"},{"categories":["Machine Learning"],"content":" Reference {책} 파이썬 머신러닝 판다스 데이터 분석 / 오승환 - 6.3 필터링 {Pandas User Guide} 10minutes to pandas ","date":"2023-01-25","objectID":"/2023-01-25_pandas_filter/:3:0","series":null,"tags":["python","pandas"],"title":"Pandas DataFrame 필터링 - boolean indexing 과 isin() 메소드","uri":"/2023-01-25_pandas_filter/#reference"},{"categories":["flutter"],"content":"컨텍스트 메뉴를 추가로 보여주기 위한 PopupMenuButton 사용법을 알아보자. ","date":"2022-11-27","objectID":"/2022-11-27_flutter-popupmenubutton/:0:0","series":null,"tags":["flutter"],"title":"Flutter의 PopupMenuButton 위젯","uri":"/2022-11-27_flutter-popupmenubutton/#"},{"categories":["flutter"],"content":" 배경 및 코드리스트로 여러 아이템을 보여줄 때, 각 아이템들에 대해 삭제 등의 기능을 추가하고 싶었다. (more 느낌의 ⫶ 버튼) Flutter 에는 PopupMenuButton이 해당 역할을 한다. 위 스크린 샷은 아래 코드의 결과이다. import 'package:flutter/material.dart'; void main() =\u003e runApp(const PopupMenuButtonDemo()); class PopupMenuButtonDemo extends StatelessWidget { const PopupMenuButtonDemo({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: 'PopupMenuButton Demo', home: Scaffold( appBar: AppBar( title: const Text('PopupMenuButton Demo'), ), body: const PopupMenuButtonPage(), ), ); } } // 추가 기능 여러개 일때, enum 으로 관리하는 게 좋아 보임 enum MenuType { first, second, third, } class PopupMenuButtonPage extends StatelessWidget { const PopupMenuButtonPage({super.key}); @override Widget build(BuildContext context) { return Center( child: ListTile( title: const Text(\"Test Item\"), trailing: PopupMenuButton\u003cMenuType\u003e( // 오늘의 주인공, PopupMenuButton. 뒤에 \u003c\u003e안에 type 적어주는 게 깔끔해 보임 // 선택된 버튼에 따라 원하는 로직 수행. (여기서는 SnackBar 표시) onSelected: (MenuType result) { final snackBar = SnackBar( content: Text(\"$result is selected.\"), ); ScaffoldMessenger.of(context).showSnackBar(snackBar); }, // itemBuilder 에서 PopMenuItem 리스트 리턴해줘야 함. itemBuilder: (BuildContext buildContext) { return [ for (final value in MenuType.values) PopupMenuItem( value: value, child: Text(value.toString()), ) ]; }, ), ), ); } } ","date":"2022-11-27","objectID":"/2022-11-27_flutter-popupmenubutton/:1:0","series":null,"tags":["flutter"],"title":"Flutter의 PopupMenuButton 위젯","uri":"/2022-11-27_flutter-popupmenubutton/#배경-및-코드"},{"categories":["flutter"],"content":" Flutter Gallery 의 예제Flutter Gallery 의 아래 항목에서 예제를 확인해 볼 수 있다. Material \u003e 메뉴 \u003e 컨텍스트 메뉴 (https://gallery.flutter.dev/#/demo/menu) menu_demo.dart (Github 소스 확인) App bar 에서도 사용된다. Material \u003e App bar (https://gallery.flutter.dev/#/demo/app-bar) app_bar_demo.dart (Github 소스 확인) ","date":"2022-11-27","objectID":"/2022-11-27_flutter-popupmenubutton/:2:0","series":null,"tags":["flutter"],"title":"Flutter의 PopupMenuButton 위젯","uri":"/2022-11-27_flutter-popupmenubutton/#flutter-gallery-의-예제"},{"categories":["flutter"],"content":" Dartpad적당히 바꿔서 테스트도 해보자. ","date":"2022-11-27","objectID":"/2022-11-27_flutter-popupmenubutton/:3:0","series":null,"tags":["flutter"],"title":"Flutter의 PopupMenuButton 위젯","uri":"/2022-11-27_flutter-popupmenubutton/#dartpad"},{"categories":["flutter"],"content":" Reference {tistory 블로그} [플러터 2.0] 버튼 - (2) (ToggleButtons, DropdownButton, PopupMenuButton) / 2021-04-18 / mike123789-dev {medium 블로그} PopupMenuButton in Flutter / 2021-01-08 / Apoorv Wadhwa {App Making Academy} Flutter Popup Menu Button Example {Flutter Open} Widgets 14 | PopupMenuButton {Flutter Gallery} 컨텍스트 메뉴 {github} Flutter Gallery ","date":"2022-11-27","objectID":"/2022-11-27_flutter-popupmenubutton/:4:0","series":null,"tags":["flutter"],"title":"Flutter의 PopupMenuButton 위젯","uri":"/2022-11-27_flutter-popupmenubutton/#reference"},{"categories":["flutter"],"content":"ListView 위에 아래에 위젯을 따로 배치하고 싶으면 Column 을 감싸고 있는 SingleChildScrollView를 이용하자. ","date":"2022-10-26","objectID":"/2022-10-26_listview-inside-singlechildscrollview/:0:0","series":null,"tags":["flutter","layout"],"title":"SingleChildScrollView 안에 ListView 배치","uri":"/2022-10-26_listview-inside-singlechildscrollview/#"},{"categories":["flutter"],"content":" 배경 및 코드아래 그림과 같이 ListView 아래에 다른 위젯(적당한 여벽 후 버튼 모음)을 배치하고 싶었다. 검색하던 중 TOP 12 ListView Widgets - 5. SingleChildScrollView 영상를 발견했다. 결론은 아래 코드 느낌으로 SingleChildScrollView 를 사용하면 된다. 내부의 Listview 에 shrinkWrap: true (리스트뷰 크기 고정), primary: false (리스트뷰 내부는 스크롤 없음) 를 지정하는 것이 포인트!! import 'package:flutter/material.dart'; void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( home: Scaffold( appBar: AppBar( title: const Text('ListView inside SingleChildScrollView'), ), body: SingleChildScrollView( // \u003c==== 주인공. Column 하나를 child로 가짐 child: Column( // 물론 Row도 가능 children: [ Container( height: 150, color: Colors.red, child: const Center( child: Text(\"Some Widgets\"), ), ), ListView.builder( // \u003c=== 성능을 생각한다면 ListView.builder 로 사용 shrinkWrap: true, // \u003c==== limit height. 리스트뷰 크기 고정 primary: false, // \u003c==== disable scrolling. 리스트뷰 내부는 스크롤 안할거임 itemCount: 10, itemBuilder: (context, index) =\u003e ListTile( title: Text(\"Item ${index + 1}\"), ), ), Container( height: 150, color: Colors.green, child: const Center( child: Text(\"Some Widgets\"), ), ), Container( height: 150, color: Colors.blue, child: const Center( child: Text(\"Some Widgets\"), ), ), ], ), ), ), ); } } 이렇게 하면 ListView 도 크기가 정해진 하나의 위젯으로 보고 Column 안에 적절히 배치할 수 있다. (물론, Column 대신에 Row도 가능하다.) 전체 스크롤은 SingleChildScrollView 책임지고 있다. ","date":"2022-10-26","objectID":"/2022-10-26_listview-inside-singlechildscrollview/:1:0","series":null,"tags":["flutter","layout"],"title":"SingleChildScrollView 안에 ListView 배치","uri":"/2022-10-26_listview-inside-singlechildscrollview/#배경-및-코드"},{"categories":["flutter"],"content":" Dartpad적당히 바꿔서 테스트도 해보자. ","date":"2022-10-26","objectID":"/2022-10-26_listview-inside-singlechildscrollview/:2:0","series":null,"tags":["flutter","layout"],"title":"SingleChildScrollView 안에 ListView 배치","uri":"/2022-10-26_listview-inside-singlechildscrollview/#dartpad"},{"categories":["flutter"],"content":" Reference {유튜브} TOP 12 ListView Widgets - 5. SingleChildScrollView {API문서} SingleChildScrollView class ","date":"2022-10-26","objectID":"/2022-10-26_listview-inside-singlechildscrollview/:3:0","series":null,"tags":["flutter","layout"],"title":"SingleChildScrollView 안에 ListView 배치","uri":"/2022-10-26_listview-inside-singlechildscrollview/#reference"},{"categories":["flutter"],"content":"Color, TextStyle을 앱 전체에서 일관되게 적용을 위해 Theme을 사용하자. ","date":"2022-10-10","objectID":"/2022-10-10_flutter-theme/:0:0","series":null,"tags":["flutter"],"title":"flutter에서 theme 사용 및 TextStyle, Color 관리","uri":"/2022-10-10_flutter-theme/#"},{"categories":["flutter"],"content":" 요약아래 코드 느낌으로 theme 정의해서 사용 가능하다. google_fonts 패키지 사용하면 폰트 적용도 쉽게 해 볼 수 있다. import 'package:flutter/material.dart'; import 'package:google_fonts/google_fonts.dart'; class EllasNotesThemeData { static ThemeData lightThemeData = themeData(); // 실제 쓸 때는 요걸로 쓸 거임 static ThemeData themeData() { // 실제 ThemeData 만듬 final base = ThemeData.light(); return base.copyWith( textTheme: _buildEllasNotesTextTheme(base.textTheme), // ... // textTheme 외에도 appBarTheme, primaryTheme, colorScheme 등 override 할 수 있는 항목 매우 많음 ); } static TextTheme _buildEllasNotesTextTheme(TextTheme base) { // TextTheme 생성 return base.copyWith( titleLarge: GoogleFonts.robotoSlab(textStyle: base.titleLarge), // main text bodyMedium: GoogleFonts.nanumGothic(textStyle: base.bodyMedium), // note // ... ); } } 앱 진입 부분에서 theme 지정 class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: \"Ella's Notes\", theme: EllasNotesThemeData.lightThemeData, // 위에서 정의한 theme 적용!! initialRoute: 'home', routes: { \"home\": (context) =\u003e const HomePage(), \"game\": (context) =\u003e const GamePage(), }, builder: EasyLoading.init(), ); } } ","date":"2022-10-10","objectID":"/2022-10-10_flutter-theme/:1:0","series":null,"tags":["flutter"],"title":"flutter에서 theme 사용 및 TextStyle, Color 관리","uri":"/2022-10-10_flutter-theme/#요약"},{"categories":["flutter"],"content":" TextStyle, Color 모아두기theme 으로 아래처럼 TextStyle와 Color 들을 모아두고, 사용하는 것도 괜찮아 보인다. (참고: {책} 쉽고 빠른 플러터 앱 개발 / 권태형 / 2022.04.28 / 8.3. 앱 스타일 파일로 정의하여 관리하기) import 'package:flutter/material.dart'; class TextStyles { static const hintTextStyle = TextStyle(fontStyle: FontStyle.italic); static const noteTextStyle = TextStyle(fontSize: 12, color: Colors.black54); static const memoTextStyle = TextStyle(fontSize: 12, color: Colors.black45, fontStyle: FontStyle.italic); // ... } import 'package:flutter/material.dart'; class ColorStyles { static const Color darkGray = Color(0xff494949); // ... } ","date":"2022-10-10","objectID":"/2022-10-10_flutter-theme/:2:0","series":null,"tags":["flutter"],"title":"flutter에서 theme 사용 및 TextStyle, Color 관리","uri":"/2022-10-10_flutter-theme/#textstyle-color-모아두기"},{"categories":["flutter"],"content":" 추가 텍스트 이름 지정TextTheme 에서 제공하는 이름 외에 다른 이름을 만들어서 쓰고 싶으면, 아래와 같이 사용 가능하다. (참고: {stackoverflow} How to define custom text theme in flutter?) class CustomTextStyle { static TextStyle hint(BuildContext context) { return GoogleFonts.nanumBrushScript(textStyle: Theme.of(context).textTheme.titleLarge); } static TextStyle memo(BuildContext context) { return Theme.of(context).textTheme.bodyMedium!.copyWith( color: ColorStyles.darkGray, ); } } ","date":"2022-10-10","objectID":"/2022-10-10_flutter-theme/:3:0","series":null,"tags":["flutter"],"title":"flutter에서 theme 사용 및 TextStyle, Color 관리","uri":"/2022-10-10_flutter-theme/#추가-텍스트-이름-지정"},{"categories":["flutter"],"content":" 샘플 프로젝트, GalleryGallery 프로젝트가 flutter 대표 샘플 프로젝트로 보이는데, 웹에서 바로 실행해 볼 수도 있다. 소스코드에 각 하위 샘플앱들의 theme 적용 부분도 꽤 있어서, 요 프로젝트들에서 어떻게 활용하는지 참고하면 좋을 듯 하다. lib/studies 밑의 각 하위 샘플앱들 : app.dart 혹은 theme.dart 에서 theme 정의 lib/themes 의 파일들 : 첫 화면의 theme 정의 ","date":"2022-10-10","objectID":"/2022-10-10_flutter-theme/:4:0","series":null,"tags":["flutter"],"title":"flutter에서 theme 사용 및 TextStyle, Color 관리","uri":"/2022-10-10_flutter-theme/#샘플-프로젝트-gallery"},{"categories":["flutter"],"content":" Reference {Flutter 문서} Use themes to share colors and font styles {책} 쉽고 빠른 플러터 앱 개발 / 권태형 / 2022.04.28 / 8.3. 앱 스타일 파일로 정의하여 관리하기 {Flutter 문서} TextTheme class {stackoverflow} How to define custom text theme in flutter? {pub.dev} google_fonts 패키지 ","date":"2022-10-10","objectID":"/2022-10-10_flutter-theme/:5:0","series":null,"tags":["flutter"],"title":"flutter에서 theme 사용 및 TextStyle, Color 관리","uri":"/2022-10-10_flutter-theme/#reference"},{"categories":["Machine Learning"],"content":"시간이 좀 걸리는 loop 를 돌 때, 해당 iterable 을 tqdm으로 감싸기만 하면 progress bar를 예쁘게 보여준다. enuerate, zip과 같이 사용할 때는 길이를 확인할 수 있는 안쪽의 list 에 tqdm을 적용해야 하고, generator와 같이 사용할 때는 total을 같이 넘겨주면 된다. ","date":"2022-10-01","objectID":"/2022-10-01_tqdm/:0:0","series":null,"tags":["python"],"title":"진행상황 표시에 사용하는 tqdm 모듈, enumerate, zip, generator 와 함께 사용","uri":"/2022-10-01_tqdm/#"},{"categories":["Machine Learning"],"content":" 1. 기본 사용법iterable을 tqdm으로 감싸기만 하면 끝.1 from tqdm import tqdm for i in tqdm(range(10000)): ... 76%|████████████████████████████ | 7568/10000 [00:33\u003c00:10, 229.00it/s] ","date":"2022-10-01","objectID":"/2022-10-01_tqdm/:1:0","series":null,"tags":["python"],"title":"진행상황 표시에 사용하는 tqdm 모듈, enumerate, zip, generator 와 함께 사용","uri":"/2022-10-01_tqdm/#1-기본-사용법"},{"categories":["Machine Learning"],"content":" 2. notebook 에서 사용tqdm.notebook 에서 import 하고 동일하게 tqdm 사용 tqdm_notebook()이 따로 있던 때도 있었지만, 지금은 tqdm() 함수를 쓰면 됨2 from tqdm.notebook import tqdm for image_path in tqdm(image_paths): ... Kaggle, Colab 에서 요렇게 사용하면 색깔도 예쁘게 칠해 줌. ","date":"2022-10-01","objectID":"/2022-10-01_tqdm/:2:0","series":null,"tags":["python"],"title":"진행상황 표시에 사용하는 tqdm 모듈, enumerate, zip, generator 와 함께 사용","uri":"/2022-10-01_tqdm/#2-notebook-에서-사용"},{"categories":["Machine Learning"],"content":" 3. enumerate, zip 과 함께 사용tqdm 내부적으로 감싼 녀석의 __len__() 을 확인하는데, enumerate, zip은 그게 없음.3 =\u003e 안쪽의 list를 tqdm으로 감싼다. 아래 코드에서 enumerate 이나, zip을 tqdm으로 감싸는 것이 아니라, 더 안쪽의 paths를 감쌈. (제일 안쪽의 paths 는 list라 길이를 알 수 있음.) ... for (i, (path, label)) in enumerate(zip(tqdm(paths), labels)): image = cv2.imread(path) ... zip은 둘 중에 어느 쪽을 tqdm으로 감싸도 무관. ","date":"2022-10-01","objectID":"/2022-10-01_tqdm/:3:0","series":null,"tags":["python"],"title":"진행상황 표시에 사용하는 tqdm 모듈, enumerate, zip, generator 와 함께 사용","uri":"/2022-10-01_tqdm/#3-enumerate-zip-과-함께-사용"},{"categories":["Machine Learning"],"content":" 4. generator 와 함께 사용generator가 몇 개 값을 줄 건지 알고 있다면, 그 값을 total 인자로 넘김.4 from tqdm import tqdm length = 1000000 generator = (3 * n for n in range(length)) # just doing something random for n in tqdm(generator, total=length): pass tqdm 공식 문서 Instantly make your loops show a smart progress meter - just wrap any iterable with tqdm(iterable), and you’re done!  ↩︎ tqdm_notebook은 이제 tqdm으로 사용하세요, 네이버 블로그 TqdmDeprecationWarning: This function will be removed in tqdm==5.0.0 Please use tqdm.notebook.tqdm instead of tqdm.tqdm_notebook  ↩︎ tqdm을 enumerate/zip과 함께 사용하기, 티스토리 블로그 ↩︎ tqdm show progress for a generator I know the length of, Stack Overflow ↩︎ ","date":"2022-10-01","objectID":"/2022-10-01_tqdm/:4:0","series":null,"tags":["python"],"title":"진행상황 표시에 사용하는 tqdm 모듈, enumerate, zip, generator 와 함께 사용","uri":"/2022-10-01_tqdm/#4-generator-와-함께-사용"},{"categories":["flutter"],"content":" ?? 연산자(’null operator’ 라고 부르나 봄)는 왼쪽 표현식이 null이 아니면 그걸 취하고, null 이면 오른쪽 표현식을 취함. ??= 연산자(’null-aware operator’ 라고 부르나 봄)는 현재 변수의 값이 null 일때만 오른 쪽 값 assign. 처음보는 사람은 모를 수 있으니 안쓰는게 깔끔할 것 같은데, 가끔 보이는 것 같으니 알아두도록 하자. ","date":"2022-09-23","objectID":"/2022-09-23_null-operator/:0:0","series":null,"tags":["dart","flutter"],"title":"Dart에서 ?? 연산자와 ??= 연산자","uri":"/2022-09-23_null-operator/#"},{"categories":["flutter"],"content":" 1. ?? 연산자🔶 ?? 연산자 사용해서 함수 구현 String playerName(String? name) =\u003e name ?? 'Guest'; 🔶 삼항 연산자 (condition) ? (expr1) : (expr2) 로 같은 함수 구현 // Slightly longer version uses ?: operator. String playerName(String? name) =\u003e name != null ? name : 'Guest'; 🔶 if-else 로 같은 함수 구현 // Very long version uses if-else statement. String playerName(String? name) { if (name != null) { return name; } else { return 'Guest'; } } ","date":"2022-09-23","objectID":"/2022-09-23_null-operator/:1:0","series":null,"tags":["dart","flutter"],"title":"Dart에서 ?? 연산자와 ??= 연산자","uri":"/2022-09-23_null-operator/#1--연산자"},{"categories":["flutter"],"content":" 2. ??= 연산자// Assign value to a a = value; // Assign value to b if b is null; otherwise, b stays the same b ??= value; 다른 예제 void main() { int value; print(value); // \u003c- null value ??= 5; print(value); // \u003c- 5, changed from null value ??= 6; print(value); // \u003c- 5, no change } ","date":"2022-09-23","objectID":"/2022-09-23_null-operator/:2:0","series":null,"tags":["dart","flutter"],"title":"Dart에서 ?? 연산자와 ??= 연산자","uri":"/2022-09-23_null-operator/#2--연산자"},{"categories":["flutter"],"content":" 99. Reference Language Tour - Conditional expressions | 공식 문서 Language Tour - Assignment operators | 공식 문서 What are ??, ??=, ?., …? in Dart? | medium 블로그 ","date":"2022-09-23","objectID":"/2022-09-23_null-operator/:3:0","series":null,"tags":["dart","flutter"],"title":"Dart에서 ?? 연산자와 ??= 연산자","uri":"/2022-09-23_null-operator/#99-reference"},{"categories":["flutter"],"content":"Dart 에는 cascade notation(.., ?..) 이란게 있음. (점 두개) 한 object의 여러 method들을 호출할 때 object 이름을 생략하려는 목적으로 보임. 처음보는 사람은 모를 수 있으니 안쓰는게 깔끔할 것 같은데, 가끔 보이는 것 같으니 알아두도록 하자. ","date":"2022-09-22","objectID":"/2022-09-22_cascade-notation/:0:0","series":null,"tags":["dart","flutter"],"title":"Dart의 cascade notation (.., dot dot)","uri":"/2022-09-22_cascade-notation/#"},{"categories":["flutter"],"content":" 1. cascade notation 사용 예시var paint = Paint() ..color = Colors.black ..strokeCap = StrokeCap.round ..strokeWidth = 5.0; 아래 코드와 같은 의미 var paint = Paint(); paint.color = Colors.black; paint.strokeCap = StrokeCap.round; paint.strokeWidth = 5.0; ","date":"2022-09-22","objectID":"/2022-09-22_cascade-notation/:1:0","series":null,"tags":["dart","flutter"],"title":"Dart의 cascade notation (.., dot dot)","uri":"/2022-09-22_cascade-notation/#1-cascade-notation-사용-예시"},{"categories":["flutter"],"content":" 99. Reference Language Tour - Cascade notation | 공식 문서 flutter_easyloading | pub.dev ","date":"2022-09-22","objectID":"/2022-09-22_cascade-notation/:2:0","series":null,"tags":["dart","flutter"],"title":"Dart의 cascade notation (.., dot dot)","uri":"/2022-09-22_cascade-notation/#99-reference"},{"categories":["flutter"],"content":"DartPad에서 dart 코드(flutter 포함)를 테스트 해 볼 수 있다. Gist 에 .dart 소스를 저장하고, 해당 id를 DartPad의 url에 추가하면 해당 소스가 보인다. ","date":"2022-09-21","objectID":"/2022-09-21_dartpad-gist/:0:0","series":null,"tags":["dartpad","gist","flutter","dart"],"title":"DartPad와 Gist를 활용한 소스 공유","uri":"/2022-09-21_dartpad-gist/#"},{"categories":["flutter"],"content":" 1. DartPadDartPad에서 간단한 dart 소스 테스트 가능하다. flutter 소스도 아래처럼 실행해 볼 수 있다. ‘sample’ 버튼을 눌러 보면 dart 및 flutter 샘플이 몇 개 있다. 단, 저장 기능은 없다. 대신에 Gist 를 활용해서 저장 효과를 볼 수 있다. ","date":"2022-09-21","objectID":"/2022-09-21_dartpad-gist/:1:0","series":null,"tags":["dartpad","gist","flutter","dart"],"title":"DartPad와 Gist를 활용한 소스 공유","uri":"/2022-09-21_dartpad-gist/#1-dartpad"},{"categories":["flutter"],"content":" 2. Gist 활용한 공유먼저 DartPad에서 실행이 잘 되는 것을 확인한 코드를 Gist에 public gist로 생성한다. 위 스크린샷은 https://gist.github.com/mechurak/a3109d6d8c9c4c67191cd36152560667 에 gist가 생성되었다. 여기서 빨간색으로 표시한 id 부분 (여기서는 a3109d6d8c9c4c67191cd36152560667)을 https://dartpad.dev/ 뒤에 붙여서 주소창에 넣으면 (https://dartpad.dev/a3109d6d8c9c4c67191cd36152560667), 해당 Gist 소스를 보여주는 DartPad가 바로 열린다. 결과물을 공유할때 유용하게 사용할 수 있을 것으로 보인다. 아래처럼 embedding 도 가능하다. \u003c!--일반 dart : embed-inline.html 사용. theme=dark --\u003e \u003ciframe style=\"width:100%;height:400px;\" src=\"https://dartpad.dev/embed-inline.html?id=5d70bc1889d055c7a18d35d77874af88\u0026split=80\u0026theme=dark\"\u003e\u003c/iframe\u003e \u003c!--flutter : embed-flutter.html 사용 --\u003e \u003ciframe style=\"width:100%;height:400px;\" src=\"https://dartpad.dev/embed-flutter.html?id=a3109d6d8c9c4c67191cd36152560667\"\u003e\u003c/iframe\u003e 일반 dart 예제 embedding (dark 테마) flutter 예제 embedding ","date":"2022-09-21","objectID":"/2022-09-21_dartpad-gist/:2:0","series":null,"tags":["dartpad","gist","flutter","dart"],"title":"DartPad와 Gist를 활용한 소스 공유","uri":"/2022-09-21_dartpad-gist/#2-gist-활용한-공유"},{"categories":["flutter"],"content":" 99. Reference DartPad Saring Guide | 공식 가이드 Embedding Guide | 공식 가이드 ","date":"2022-09-21","objectID":"/2022-09-21_dartpad-gist/:3:0","series":null,"tags":["dartpad","gist","flutter","dart"],"title":"DartPad와 Gist를 활용한 소스 공유","uri":"/2022-09-21_dartpad-gist/#99-reference"},{"categories":["Machine Learning"],"content":"자신이 만든 python 모듈을 Colab에서 사용할 수 있다. Google Drive 에 .py 파일 혹은 패키지(폴더)를 올려둔 뒤, Google Drive를 mount 하고, 해당 폴더를 sys.path 에 추가하면 된다. ","date":"2022-07-18","objectID":"/2022-07-18_google-drive/:0:0","series":null,"tags":["colab","google_drive"],"title":"Colab에서 Google Drive 연결 및 custom module 사용","uri":"/2022-07-18_google-drive/#"},{"categories":["Machine Learning"],"content":" 1. Colab에 Google Drive 연결","date":"2022-07-18","objectID":"/2022-07-18_google-drive/:1:0","series":null,"tags":["colab","google_drive"],"title":"Colab에서 Google Drive 연결 및 custom module 사용","uri":"/2022-07-18_google-drive/#1-colab에-google-drive-연결"},{"categories":["Machine Learning"],"content":" (option 1) 파일 패널의 마운트 버튼 이용 (최초에만 확인 필요) 폴더 버튼 마운트 버튼 확인 하면, sample_data 위에 drive 폴더 보임 ","date":"2022-07-18","objectID":"/2022-07-18_google-drive/:1:1","series":null,"tags":["colab","google_drive"],"title":"Colab에서 Google Drive 연결 및 custom module 사용","uri":"/2022-07-18_google-drive/#option-1-파일-패널의-마운트-버튼-이용-최초에만-확인-필요"},{"categories":["Machine Learning"],"content":" (option 2) 코드로 mount (실행시마다 인증 필요)from google.colab import drive drive.mount('/content/gdrive') 단, 실행시마다 인증해야함. ","date":"2022-07-18","objectID":"/2022-07-18_google-drive/:1:2","series":null,"tags":["colab","google_drive"],"title":"Colab에서 Google Drive 연결 및 custom module 사용","uri":"/2022-07-18_google-drive/#option-2-코드로-mount-실행시마다-인증-필요"},{"categories":["Machine Learning"],"content":" 2. PYTHONPATH 에 custom module 위치 추가 해당 폴더의 경로 확인 폴더에 오른쪽 버튼 클릭해서 경로 복사 버튼 해당 폴더를 sys.path 에 추가함 parent 폴더 밑에 my_awosome_package 폴더가 있다면, parent 폴더를 추가 import sys sys.path.append('/content/drive/MyDrive/awesome_work/parent/') ","date":"2022-07-18","objectID":"/2022-07-18_google-drive/:2:0","series":null,"tags":["colab","google_drive"],"title":"Colab에서 Google Drive 연결 및 custom module 사용","uri":"/2022-07-18_google-drive/#2-pythonpath-에-custom-module-위치-추가"},{"categories":["Machine Learning"],"content":" 3. 기타해당 custom module이 자주 변할 예정이라면, Github 에 올려두고, Google Drive 에 해당 repo를 pull 하는 별도의 Colab 노트북을 준비해두는 것도 좋아 보인다. ","date":"2022-07-18","objectID":"/2022-07-18_google-drive/:3:0","series":null,"tags":["colab","google_drive"],"title":"Colab에서 Google Drive 연결 및 custom module 사용","uri":"/2022-07-18_google-drive/#3-기타"},{"categories":["Machine Learning"],"content":" 99. Reference How to import custom modules in google colab? | stackoverflow ","date":"2022-07-18","objectID":"/2022-07-18_google-drive/:4:0","series":null,"tags":["colab","google_drive"],"title":"Colab에서 Google Drive 연결 및 custom module 사용","uri":"/2022-07-18_google-drive/#99-reference"},{"categories":["게임 개발"],"content":"LittleVulkanEngine 을 따라 만들어 보면서, Vulkan을 배워봅시다. Youtube Link ","date":"2021-12-13","objectID":"/2021-12-13_game-loop/:0:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Game loops \u0026 User input - Vulkan Game Engine Tutorial 15' 정리","uri":"/2021-12-13_game-loop/#"},{"categories":["게임 개발"],"content":" 1. 주요내용 delta time 도 같이 이용해서, 매 틱마다 GameObject를 업데이트 함 키보드 입력을 받아서 카메라를 움직임 ","date":"2021-12-13","objectID":"/2021-12-13_game-loop/:1:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Game loops \u0026 User input - Vulkan Game Engine Tutorial 15' 정리","uri":"/2021-12-13_game-loop/#1-주요내용"},{"categories":["게임 개발"],"content":" 2. 이론 설명","date":"2021-12-13","objectID":"/2021-12-13_game-loop/:2:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Game loops \u0026 User input - Vulkan Game Engine Tutorial 15' 정리","uri":"/2021-12-13_game-loop/#2-이론-설명"},{"categories":["게임 개발"],"content":" 2.1. 게임 속도 문제게임 속도가 실행되는 기기마다 다르면 안됩니다. 요 속도를 맞추기 위해, FIFO present 모드(V-Sync 를 따름)를 사용하지만, 완전한 해결책은 아닙니다. 모니터의 refresh rate 가 다르면, 속도가 달라질 것이기 때문입니다. 49s 모니터가 60Hz이면 game loop 가 60번 불릴 것이고, 120Hz라면 120번 불릴겁니다. 매 틱마다 같은 각도를 회전한다면, 120Hz 가 두 배 더 빨리 돌게 되지요. ","date":"2021-12-13","objectID":"/2021-12-13_game-loop/:2:1","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Game loops \u0026 User input - Vulkan Game Engine Tutorial 15' 정리","uri":"/2021-12-13_game-loop/#21-게임-속도-문제"},{"categories":["게임 개발"],"content":" 2.2. delta time 도입115s update 를 부를 때, 이전 프레임 시작에서 부터 얼마만큼의 시간이 지났는지를 나타내는 dt를 같이 넘깁니다. 요 delta time 을 이용하면, 게임 속도 문제를 해결할 수 있습니다. 135s 불리는 횟수가 다르더라도, dt 값이 있으므로 보정이 가능하죠. ","date":"2021-12-13","objectID":"/2021-12-13_game-loop/:2:2","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Game loops \u0026 User input - Vulkan Game Engine Tutorial 15' 정리","uri":"/2021-12-13_game-loop/#22-delta-time-도입"},{"categories":["게임 개발"],"content":" 2.3. 로테이션이 0이 아닌 것 확인회전 값이 0이라면, 굳이 회전 값을 갱신할 필요가 없습니다. 내적 이용하면, 벡터가 0이 아님을 확인 할 수 있습니다. 617s ","date":"2021-12-13","objectID":"/2021-12-13_game-loop/:2:3","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Game loops \u0026 User input - Vulkan Game Engine Tutorial 15' 정리","uri":"/2021-12-13_game-loop/#23-로테이션이-0이-아닌-것-확인"},{"categories":["게임 개발"],"content":" 2.4. 전방 확인xz평면에서 움직을 거니까, y축 회전 기준으로 전방을 정합니다. 726s ","date":"2021-12-13","objectID":"/2021-12-13_game-loop/:2:4","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Game loops \u0026 User input - Vulkan Game Engine Tutorial 15' 정리","uri":"/2021-12-13_game-loop/#24-전방-확인"},{"categories":["게임 개발"],"content":" 3. 코드 수정","date":"2021-12-13","objectID":"/2021-12-13_game-loop/:3:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Game loops \u0026 User input - Vulkan Game Engine Tutorial 15' 정리","uri":"/2021-12-13_game-loop/#3-코드-수정"},{"categories":["게임 개발"],"content":" 3.1. SimpleRenderSystem::renderGameObjects() 수정 회전 애니메이션을 위해 넣어던 회전 값 변화 제거 ","date":"2021-12-13","objectID":"/2021-12-13_game-loop/:3:1","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Game loops \u0026 User input - Vulkan Game Engine Tutorial 15' 정리","uri":"/2021-12-13_game-loop/#31-simplerendersystemrendergameobjects-수정"},{"categories":["게임 개발"],"content":" 3.2. FirstApp:run() 수정 매 틱마다 현재 시각 확인 및 지난 틱의 시각과의 차(dt)를 유지 루프 진입하기 전에 KeyboardMovementController 준비 (cameraController) 루프 진입하기 전에 카메라의 이동 및 회전을 위한 GameObject 준비 (viewObject) 루프 안에서 KeyboardMovementController.moveInPlaneXZ 호출 (viewObject 회전 및 이동) 루프 안에서 viewObject 값을 이용해 카메라 세팅 ","date":"2021-12-13","objectID":"/2021-12-13_game-loop/:3:2","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Game loops \u0026 User input - Vulkan Game Engine Tutorial 15' 정리","uri":"/2021-12-13_game-loop/#32-firstapprun-수정"},{"categories":["게임 개발"],"content":" 3.3. KeyboardMovementController 클래스 추가 키보드 입력 확인해서 viewObject에 이동 및 회전 세팅 계산할 때, dt를 같이 곱해줌으로써 게임 속도가 동일하도록 함 ","date":"2021-12-13","objectID":"/2021-12-13_game-loop/:3:3","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Game loops \u0026 User input - Vulkan Game Engine Tutorial 15' 정리","uri":"/2021-12-13_game-loop/#33-keyboardmovementcontroller-클래스-추가"},{"categories":["게임 개발"],"content":" 3.4. LveWindow 클래스 수정 getGLFWwindow() 메소드 추가 : KeyboardMovementController 에서 GLFW의 window 받아서 키보드 입력을 확인하기 위함 ","date":"2021-12-13","objectID":"/2021-12-13_game-loop/:3:4","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Game loops \u0026 User input - Vulkan Game Engine Tutorial 15' 정리","uri":"/2021-12-13_game-loop/#34-lvewindow-클래스-수정"},{"categories":["게임 개발"],"content":" 3.5. 클래스 다이어그램 ","date":"2021-12-13","objectID":"/2021-12-13_game-loop/:3:5","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Game loops \u0026 User input - Vulkan Game Engine Tutorial 15' 정리","uri":"/2021-12-13_game-loop/#35-클래스-다이어그램"},{"categories":["게임 개발"],"content":"LittleVulkanEngine 을 따라 만들어 보면서, Vulkan을 배워봅시다. Youtube Link ","date":"2021-12-08","objectID":"/2021-12-08_view-matrix/:0:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Camera (View) Transform - Vulkan Game Engine Tutorial 14' 정리","uri":"/2021-12-08_view-matrix/#"},{"categories":["게임 개발"],"content":" 1. 주요내용 LveCamera 클래스에 view matrix 추가 push.tansform push constant 만들 때, projection * view * model 매트릭스 다 곱한 값 사용 ","date":"2021-12-08","objectID":"/2021-12-08_view-matrix/:1:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Camera (View) Transform - Vulkan Game Engine Tutorial 14' 정리","uri":"/2021-12-08_view-matrix/#1-주요내용"},{"categories":["게임 개발"],"content":" 2. 이론 설명","date":"2021-12-08","objectID":"/2021-12-08_view-matrix/:2:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Camera (View) Transform - Vulkan Game Engine Tutorial 14' 정리","uri":"/2021-12-08_view-matrix/#2-이론-설명"},{"categories":["게임 개발"],"content":" 2.1. overall 우리가 그려야할 3차원 오브젝트는 각자의 좌표계를 가지고 있습니다. 보통 중앙이나 발 밑이 원점이 되는 것 같습니다. 실제로 pipeline 에는 요 좌표계 기준의 vertex 데이터들이 들어갑니다. Object Space - Model Transform -\u003e World Space 각 오브젝트를 월드 좌표계에 배치하는 작업입니다. 스케일, 회전도 같이 세팅 합니다. 각 객체마다 월드 좌표계에서 자신의 위치가 있으므로, GameObject 각자마다 자신의 (월드 좌표계에서) 위치를 가지고 있으면 됩니다. World Space - Camera(View) Transform -\u003e Camera Space 장면을 바라볼 카메라도 움직일 수 있습니다. 최종 화면에 보일 결과물도 카메라 기준으로 그려져야 합니다. 고로, 카메라가 원점에 위치 되게 좌표계를 조정합니다. Camera Space - Projection Transform -\u003e Canonical View Volume 어느 영역을 보이는 영역으로 할 건지, 직교투영을 사용할 건지, 원근 투영을 사용할 건지를 정해서, 해당 영역을 Canonical View Volume 영역으로 매핑합니다. Canonical View Volume - Viewport Transform -\u003e Viewport Canonical View Volume 에 들어와 있는 객체들을 Viewport 에 매핑합니다. 요건 pipeline 에서 자동으로 하는 것 같습니다. ","date":"2021-12-08","objectID":"/2021-12-08_view-matrix/:2:1","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Camera (View) Transform - Vulkan Game Engine Tutorial 14' 정리","uri":"/2021-12-08_view-matrix/#21-overall"},{"categories":["게임 개발"],"content":" 2.2. 사과 GameObject사과 GameObject 의 예를 봅시다. model transform 을 통해 월드 좌표계에 배치하고, projection transform 을 통해 canonical view volume 에 매핑합니다. 이후 viewport transform 을 통해 화면에 그려집니다. ","date":"2021-12-08","objectID":"/2021-12-08_view-matrix/:2:2","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Camera (View) Transform - Vulkan Game Engine Tutorial 14' 정리","uri":"/2021-12-08_view-matrix/#22-사과-gameobject"},{"categories":["게임 개발"],"content":" 3. 코드 수정","date":"2021-12-08","objectID":"/2021-12-08_view-matrix/:3:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Camera (View) Transform - Vulkan Game Engine Tutorial 14' 정리","uri":"/2021-12-08_view-matrix/#3-코드-수정"},{"categories":["게임 개발"],"content":" 3.1. LveCamera 클래스 수정 viewMatrix 변수 추가 (mat4) : view matrix 갖고 있음 viewMatrix 를 세팅할 유틸 함수들 추가 ","date":"2021-12-08","objectID":"/2021-12-08_view-matrix/:3:1","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Camera (View) Transform - Vulkan Game Engine Tutorial 14' 정리","uri":"/2021-12-08_view-matrix/#31-lvecamera-클래스-수정"},{"categories":["게임 개발"],"content":" 3.2. FirstApp::run() 메소드 수정 while loop 진입하기 전에 camera 의 view matrix 세팅 ","date":"2021-12-08","objectID":"/2021-12-08_view-matrix/:3:2","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Camera (View) Transform - Vulkan Game Engine Tutorial 14' 정리","uri":"/2021-12-08_view-matrix/#32-firstapprun-메소드-수정"},{"categories":["게임 개발"],"content":" 3.3. SimpleRenderSystem::renderObjects() 메소드 수정 for loop 진입하기 전에 projection matrix 와 view matrix 곱해 둠 push.tansform push constant 만들 때, projection * view * model 매트릭스 다 곱한 값 사용 ","date":"2021-12-08","objectID":"/2021-12-08_view-matrix/:3:3","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Camera (View) Transform - Vulkan Game Engine Tutorial 14' 정리","uri":"/2021-12-08_view-matrix/#33-simplerendersystemrenderobjects-메소드-수정"},{"categories":["게임 개발"],"content":" 3.4. 클래스 다이어그램 ","date":"2021-12-08","objectID":"/2021-12-08_view-matrix/:3:4","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Camera (View) Transform - Vulkan Game Engine Tutorial 14' 정리","uri":"/2021-12-08_view-matrix/#34-클래스-다이어그램"},{"categories":["게임 개발"],"content":" 3.5. 시퀀스 다이어그램 ","date":"2021-12-08","objectID":"/2021-12-08_view-matrix/:3:5","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Camera (View) Transform - Vulkan Game Engine Tutorial 14' 정리","uri":"/2021-12-08_view-matrix/#35-시퀀스-다이어그램"},{"categories":["게임 개발"],"content":"LittleVulkanEngine 을 따라 만들어 보면서, Vulkan을 배워봅시다. Youtube Link ","date":"2021-12-06","objectID":"/2021-12-06_projection-matrix/:0:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Projection Matrices - Vulkan Game Engine Tutorial 13' 정리","uri":"/2021-12-06_projection-matrix/#"},{"categories":["게임 개발"],"content":" 1. 주요내용 LveCamera 클래스 추가 (Perspective matrix, Orthographic matrix 처리) 창 사이즈를 바꿔도 aspect ratio를 유지하도록 함 ","date":"2021-12-06","objectID":"/2021-12-06_projection-matrix/:1:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Projection Matrices - Vulkan Game Engine Tutorial 13' 정리","uri":"/2021-12-06_projection-matrix/#1-주요내용"},{"categories":["게임 개발"],"content":" 2. 이론 설명","date":"2021-12-06","objectID":"/2021-12-06_projection-matrix/:2:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Projection Matrices - Vulkan Game Engine Tutorial 13' 정리","uri":"/2021-12-06_projection-matrix/#2-이론-설명"},{"categories":["게임 개발"],"content":" 2.1. 직교투영과 원근투영 월드 좌표계에 있는 물체를 카메라에 입장에서 Vulkan’s Canonical Viewing Volume x(-1, 1), y(-1, 1), z(0, 1) 이라는 데로 가져와야 합니다. 원근감 없이 그냥 가져오면 orthographic projection 이라고 합니다. 원근감을 고려해서 절두체에서 orthographic view volume을 거쳐서 오면 perspective projection 이 됩니다. 몇 개의 변수만 정하면 저 매트릭스는 정해지는 것 같으니, 자세한건 별도로 준비된 영상을 참고합시다. The Math behind (most) 3D games - Perspective Projection orthographic projection 과 perspective projection 의 결과물은 요렇게 보입니다. ","date":"2021-12-06","objectID":"/2021-12-06_projection-matrix/:2:1","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Projection Matrices - Vulkan Game Engine Tutorial 13' 정리","uri":"/2021-12-06_projection-matrix/#21-직교투영과-원근투영"},{"categories":["게임 개발"],"content":" 2.2. aspect ratio 유지지금은 창을 늘리면 큐브도 늘어나는데, 가로 세로 제각각 늘어납니다. Canonical View Volume 이 윈도우 사이즈에 딱 맞도록 세팅되어 있기 때문입니다. 요걸 aspect ratio 를 유지하도록 하려면, Orthographic View Volume 을 적절히 조정해야 합니다. 407s ","date":"2021-12-06","objectID":"/2021-12-06_projection-matrix/:2:2","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Projection Matrices - Vulkan Game Engine Tutorial 13' 정리","uri":"/2021-12-06_projection-matrix/#22-aspect-ratio-유지"},{"categories":["게임 개발"],"content":" 3. 코드 수정","date":"2021-12-06","objectID":"/2021-12-06_projection-matrix/:3:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Projection Matrices - Vulkan Game Engine Tutorial 13' 정리","uri":"/2021-12-06_projection-matrix/#3-코드-수정"},{"categories":["게임 개발"],"content":" 3.1. LveCamera 클래스 추가setOrthographicProjection() 65s 직교투영을 사용하도록 세팅 윈도우 크기가 변할 수 있으므로(aspect 가 바뀔 수 있으므로), FirstApp:run()의 루프에서 매 프레임 세팅 setPerspectiveProjection() 85s 원근투영을 사용하도록 세팅 윈도우 크기가 변할 수 있으므로(aspect 가 바뀔 수 있으므로), FirstApp:run()의 루프에서 매 프레임 세팅 getProjection() Projection Matrix 리턴 SimpleRenderSystem::renderGameObjects() 에서 게임 오브젝트를 위한 push constant 를 세팅할 때 사용 ","date":"2021-12-06","objectID":"/2021-12-06_projection-matrix/:3:1","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Projection Matrices - Vulkan Game Engine Tutorial 13' 정리","uri":"/2021-12-06_projection-matrix/#31-lvecamera-클래스-추가"},{"categories":["게임 개발"],"content":" 3.2. LveRenderer 클래스 수정 getAspectRatio() 추가 : swapchain의 aspect ratio 를 가져다가 쓰기 위함 ","date":"2021-12-06","objectID":"/2021-12-06_projection-matrix/:3:2","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Projection Matrices - Vulkan Game Engine Tutorial 13' 정리","uri":"/2021-12-06_projection-matrix/#32-lverenderer-클래스-수정"},{"categories":["게임 개발"],"content":" 3.3. SimpleRenderSystem 클래스 수정 renderGameObjects() 메소드에서 LveCamera\u0026 도 같이 받음 push.tansform push constant 만들 때, projection matrix 도 곱해 줌 일단은 cpu 에서 곰셉 (보통은 gpu 에서 하지만) 현재는 카메라가 원점에 위치하고 있음 ","date":"2021-12-06","objectID":"/2021-12-06_projection-matrix/:3:3","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Projection Matrices - Vulkan Game Engine Tutorial 13' 정리","uri":"/2021-12-06_projection-matrix/#33-simplerendersystem-클래스-수정"},{"categories":["게임 개발"],"content":" 3.4. 클래스 다이어그램 ","date":"2021-12-06","objectID":"/2021-12-06_projection-matrix/:3:4","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Projection Matrices - Vulkan Game Engine Tutorial 13' 정리","uri":"/2021-12-06_projection-matrix/#34-클래스-다이어그램"},{"categories":["게임 개발"],"content":"LittleVulkanEngine 을 따라 만들어 보면서, Vulkan을 배워봅시다. Youtube Link ","date":"2021-12-01","objectID":"/2021-12-01_euler-angles-homogeneous-coordinates/:0:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Euler Angles \u0026 Homogeneous Coordinates - Vulkan Game Engine Tutorial 12' 정리","uri":"/2021-12-01_euler-angles-homogeneous-coordinates/#"},{"categories":["게임 개발"],"content":" 1. 주요내용 Transformation matrix 에 이동도 포함 (Homogeneous Coodinates 이용) 3차원에서 회전 설명 모델을 3차원의 큐브로 변경 ","date":"2021-12-01","objectID":"/2021-12-01_euler-angles-homogeneous-coordinates/:1:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Euler Angles \u0026 Homogeneous Coordinates - Vulkan Game Engine Tutorial 12' 정리","uri":"/2021-12-01_euler-angles-homogeneous-coordinates/#1-주요내용"},{"categories":["게임 개발"],"content":" 2. 이론 설명","date":"2021-12-01","objectID":"/2021-12-01_euler-angles-homogeneous-coordinates/:2:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Euler Angles \u0026 Homogeneous Coordinates - Vulkan Game Engine Tutorial 12' 정리","uri":"/2021-12-01_euler-angles-homogeneous-coordinates/#2-이론-설명"},{"categories":["게임 개발"],"content":" 2.1. translation 표현29s 2x2 매트릭스로는 translation 까지 나타낼 수 없었습니다. 111s 요렇게 대상 점 (x, y) 에 1을 추가하고, 원래 매트릭스를 위와 같이 3x3으로 만들면, 이동까지 나타낼 수 있습니다. 1을 추가한 벡터를 homogeneous coodinate 라고 말하는 것 같습니다. 144s 이제 매트릭를 잘 곱해서 요런 것도 할 수 있습니다. (원점이 아니라 특정 점을 기준으로 회전) 회전 축이 될 특정 점을 원점으로 이동시키고(T1), 회전을 한 뒤(Rotate), 위치 옮겼던 만큼 다시 옮기면(T2) 됩니다. 오른쪽부터 하니까 T = T2 * R * T1 이 되지요. ","date":"2021-12-01","objectID":"/2021-12-01_euler-angles-homogeneous-coordinates/:2:1","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Euler Angles \u0026 Homogeneous Coordinates - Vulkan Game Engine Tutorial 12' 정리","uri":"/2021-12-01_euler-angles-homogeneous-coordinates/#21-translation-표현"},{"categories":["게임 개발"],"content":" 2.2. 점이 아닌 벡터의 경우벡터는 크기와 방향만 있으므로, 위치 이동은 의미가 없습니다. 219s 대상 벡터 (x, y) 를 (x, y, 0) 으로 나타내면 원하는 대로 변환이 됩니다. 237s 즉, 점은 마지막 컴포넌트에 1을 넣고, 벡터는 0을 넣어 사용합니다. ","date":"2021-12-01","objectID":"/2021-12-01_euler-angles-homogeneous-coordinates/:2:2","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Euler Angles \u0026 Homogeneous Coordinates - Vulkan Game Engine Tutorial 12' 정리","uri":"/2021-12-01_euler-angles-homogeneous-coordinates/#22-점이-아닌-벡터의-경우"},{"categories":["게임 개발"],"content":" 2.3. 3차원에 적용268s 2차원에서 3차원로 갈 때, 생긴 모양은 특별할 건 없습니다. 다만 회전을 나타내는 게 조금 복잡해 집니다. 여러 방식이 있는데, 우리는 각 축별로 회전시키는 Euler angles 방식을 따를 겁니다. 각 축별 회전 시키는 각도에 따라, sin, cos 값을 계산해서 적절히 곱하고 더하고 하네요. 그런가 부다 합시다 ㅠㅜ ","date":"2021-12-01","objectID":"/2021-12-01_euler-angles-homogeneous-coordinates/:2:3","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Euler Angles \u0026 Homogeneous Coordinates - Vulkan Game Engine Tutorial 12' 정리","uri":"/2021-12-01_euler-angles-homogeneous-coordinates/#23-3차원에-적용"},{"categories":["게임 개발"],"content":" 2.4. intrinsic vs extrinsic rotation intrinsic rotation은 회전할 때 축도 같이 회전하고(local 좌표계), extrinsic 은 축은 그대로 있습니다. (global 좌표계) 고거에 따라서 회전을 왼쪽부터 혹은 오른쪽 부터 해석하면 된다고 합니다. 일단 그런게 있구나 하겠습니다. ㅠㅜ ","date":"2021-12-01","objectID":"/2021-12-01_euler-angles-homogeneous-coordinates/:2:4","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Euler Angles \u0026 Homogeneous Coordinates - Vulkan Game Engine Tutorial 12' 정리","uri":"/2021-12-01_euler-angles-homogeneous-coordinates/#24-intrinsic-vs-extrinsic-rotation"},{"categories":["게임 개발"],"content":" 3. 코드 수정","date":"2021-12-01","objectID":"/2021-12-01_euler-angles-homogeneous-coordinates/:3:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Euler Angles \u0026 Homogeneous Coordinates - Vulkan Game Engine Tutorial 12' 정리","uri":"/2021-12-01_euler-angles-homogeneous-coordinates/#3-코드-수정"},{"categories":["게임 개발"],"content":" 3.1. LveModel 클래스 수정 3차원을 표현할 수 있도록 Vertex 구조체의 position 타입 변경 ","date":"2021-12-01","objectID":"/2021-12-01_euler-angles-homogeneous-coordinates/:3:1","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Euler Angles \u0026 Homogeneous Coordinates - Vulkan Game Engine Tutorial 12' 정리","uri":"/2021-12-01_euler-angles-homogeneous-coordinates/#31-lvemodel-클래스-수정"},{"categories":["게임 개발"],"content":" 3.2. FirstApp 클래스 수정 loadGameObjects() 에서 큐브 모델 만들어서 사용 위치랑 스케일 살짝 조정 769s 영역 안에 들어가게 할려고 scale 살짝 줄였습ㄴ디ㅏ. ","date":"2021-12-01","objectID":"/2021-12-01_euler-angles-homogeneous-coordinates/:3:2","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Euler Angles \u0026 Homogeneous Coordinates - Vulkan Game Engine Tutorial 12' 정리","uri":"/2021-12-01_euler-angles-homogeneous-coordinates/#32-firstapp-클래스-수정"},{"categories":["게임 개발"],"content":" 3.3. GameObject 클래스 수정 TransformComponent 이름 변경 3차원 표현을 위한 변수 타입 변경 transformation matrix 를 위해 4x4 매트릭스를 리턴하는 mat4() 구현 ","date":"2021-12-01","objectID":"/2021-12-01_euler-angles-homogeneous-coordinates/:3:3","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Euler Angles \u0026 Homogeneous Coordinates - Vulkan Game Engine Tutorial 12' 정리","uri":"/2021-12-01_euler-angles-homogeneous-coordinates/#33-gameobject-클래스-수정"},{"categories":["게임 개발"],"content":" 3.4. SimpleRenderSystem 클래스 수정 renderGameObjects() 에서 애니메니션을 위해서 GameOjbect의 회전 값 변경후, mat4() 호출해서 transform 준비 ","date":"2021-12-01","objectID":"/2021-12-01_euler-angles-homogeneous-coordinates/:3:4","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Euler Angles \u0026 Homogeneous Coordinates - Vulkan Game Engine Tutorial 12' 정리","uri":"/2021-12-01_euler-angles-homogeneous-coordinates/#34-simplerendersystem-클래스-수정"},{"categories":["게임 개발"],"content":" 3.5. 다이어그램 ","date":"2021-12-01","objectID":"/2021-12-01_euler-angles-homogeneous-coordinates/:3:5","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Euler Angles \u0026 Homogeneous Coordinates - Vulkan Game Engine Tutorial 12' 정리","uri":"/2021-12-01_euler-angles-homogeneous-coordinates/#35-다이어그램"},{"categories":["게임 개발"],"content":" 3.6. 실행 결과 --- ","date":"2021-12-01","objectID":"/2021-12-01_euler-angles-homogeneous-coordinates/:3:6","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Euler Angles \u0026 Homogeneous Coordinates - Vulkan Game Engine Tutorial 12' 정리","uri":"/2021-12-01_euler-angles-homogeneous-coordinates/#36-실행-결과"},{"categories":["게임 개발"],"content":" 4. Summary 점 (x, y, z) 는 (x, y, z, 1) 로 바꿔서 사용합니다. 위의 4x4 매트릭스에서, 녹색 3x3 부분은 rotation과 scale을 나타내고, 빨간색 부분은 translation을 나타냅니다. 점은 마지막 컴포넌트로 1을 사용하고, 벡터는 0을 사용합니다. 3차원에서 회전은 여러 방식으로 나타낼 수 있습니다. ","date":"2021-12-01","objectID":"/2021-12-01_euler-angles-homogeneous-coordinates/:4:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Euler Angles \u0026 Homogeneous Coordinates - Vulkan Game Engine Tutorial 12' 정리","uri":"/2021-12-01_euler-angles-homogeneous-coordinates/#4-summary"},{"categories":["게임 개발"],"content":"LittleVulkanEngine 을 따라 만들어 보면서, Vulkan을 배워봅시다. Youtube Link ","date":"2021-11-25","objectID":"/2021-11-25_renderer-and-system/:0:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Renderer \u0026 Systems - Vulkan Game Engine Tutorial 11' 정리","uri":"/2021-11-25_renderer-and-system/#"},{"categories":["게임 개발"],"content":" 1. 주요내용 클래스 구조 리팩토링 LveRenderer 클래스 추가 FirstApp 클래스에서 SwapChain, Command Buffers, draw frame 관련 부분 뽑아냄 SimpleRenderSystem 클래스 추가 FirstApp 클래스에서 Pipeline, Pipeline Layout, render GameObjects 관련 부분 뽑아냄 ","date":"2021-11-25","objectID":"/2021-11-25_renderer-and-system/:1:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Renderer \u0026 Systems - Vulkan Game Engine Tutorial 11' 정리","uri":"/2021-11-25_renderer-and-system/#1-주요내용"},{"categories":["게임 개발"],"content":" 2. 코드 수정","date":"2021-11-25","objectID":"/2021-11-25_renderer-and-system/:2:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Renderer \u0026 Systems - Vulkan Game Engine Tutorial 11' 정리","uri":"/2021-11-25_renderer-and-system/#2-코드-수정"},{"categories":["게임 개발"],"content":" 2.1. 개요지금까지는 FirstApp에 너무 많은 기능이 몰려 있습니다. 요번 강에서 렌더링 관련 부분을 담당하는 클래스를 좀 떼어냅니다. 53s FisrtApp 의 기능 중 일부를 떼어내서 SwapChain, Command Buffers, draw Frame 을 담당하는 LveRenderer 클래스와, Pipeline, Pipeline Layout, Push Constant 구조체, render GameObjects 를 담당하는 SimpleRenderSystem을 만들 겁니다. 77s Renderer 는 하나만 존재하고, System 은 여러 종류가 있을 수 있습니다. (여기서의 “System” 은 ECS에서의 System을 의미하지는 않습니다.) 131s (아마도 GameObject는 그냥 각 System을 다 호출하고, System에서 분기를 하는 게 정석인 듯 하지만) 우리는 단순함을 위해, 호출부에서 특정 System을 호출해도 문제 없는지 잘 판단해서 호출하는 걸로 합니다. ","date":"2021-11-25","objectID":"/2021-11-25_renderer-and-system/:2:1","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Renderer \u0026 Systems - Vulkan Game Engine Tutorial 11' 정리","uri":"/2021-11-25_renderer-and-system/#21-개요"},{"categories":["게임 개발"],"content":" 2.2. LveRenderer 클래스 추가 FirstApp에서 SwapChain, Command Buffers, draw Frame 관련 로직 옮겨 옵니다. ","date":"2021-11-25","objectID":"/2021-11-25_renderer-and-system/:2:2","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Renderer \u0026 Systems - Vulkan Game Engine Tutorial 11' 정리","uri":"/2021-11-25_renderer-and-system/#22-lverenderer-클래스-추가"},{"categories":["게임 개발"],"content":" 2.3. SimpleRenderSystem 클래스 추가 FirstApp에서 Pipeline, Pipeline Layout, Push Constant, render GameObjects 관련 로직 옮겨 옵니다. ","date":"2021-11-25","objectID":"/2021-11-25_renderer-and-system/:2:3","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Renderer \u0026 Systems - Vulkan Game Engine Tutorial 11' 정리","uri":"/2021-11-25_renderer-and-system/#23-simplerendersystem-클래스-추가"},{"categories":["게임 개발"],"content":" 2.4. 결과 화면 10강과 같은 동작으로 삼각형이 오른쪽(시계 방향)으로 회전합니다. ","date":"2021-11-25","objectID":"/2021-11-25_renderer-and-system/:2:4","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Renderer \u0026 Systems - Vulkan Game Engine Tutorial 11' 정리","uri":"/2021-11-25_renderer-and-system/#24-결과-화면"},{"categories":["게임 개발"],"content":" 3. 다이어그램","date":"2021-11-25","objectID":"/2021-11-25_renderer-and-system/:3:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Renderer \u0026 Systems - Vulkan Game Engine Tutorial 11' 정리","uri":"/2021-11-25_renderer-and-system/#3-다이어그램"},{"categories":["게임 개발"],"content":" 3.1. 클래스 다이어그램 아래 시퀀스 다이어그램과 같이 보면 좋습니다. ","date":"2021-11-25","objectID":"/2021-11-25_renderer-and-system/:3:1","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Renderer \u0026 Systems - Vulkan Game Engine Tutorial 11' 정리","uri":"/2021-11-25_renderer-and-system/#31-클래스-다이어그램"},{"categories":["게임 개발"],"content":" 3.2. 시퀀스 다이어그램 ","date":"2021-11-25","objectID":"/2021-11-25_renderer-and-system/:3:2","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Renderer \u0026 Systems - Vulkan Game Engine Tutorial 11' 정리","uri":"/2021-11-25_renderer-and-system/#32-시퀀스-다이어그램"},{"categories":["게임 개발"],"content":"LittleVulkanEngine 을 따라 만들어 보면서, Vulkan을 배워봅시다. Youtube Link ","date":"2021-11-22","objectID":"/2021-11-22_transform-matrix/:0:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'2D Transformations - Vulkan Game Engine Tutorial 10' 정리","uri":"/2021-11-22_transform-matrix/#"},{"categories":["게임 개발"],"content":" 1. 주요내용 transformation matrix 을 통한 rotation, scale 설명 PushConstant 에 transform matrix 추가해서 shader에서 사용 LveGameObject 클래스 추가 화면에 표시되는 객체 ","date":"2021-11-22","objectID":"/2021-11-22_transform-matrix/:1:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'2D Transformations - Vulkan Game Engine Tutorial 10' 정리","uri":"/2021-11-22_transform-matrix/#1-주요내용"},{"categories":["게임 개발"],"content":" 2. Transformation Matrix 설명","date":"2021-11-22","objectID":"/2021-11-22_transform-matrix/:2:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'2D Transformations - Vulkan Game Engine Tutorial 10' 정리","uri":"/2021-11-22_transform-matrix/#2-transformation-matrix-설명"},{"categories":["게임 개발"],"content":" 2.1. 변환 행렬을 통한 vertex의 이동모델의 rotation, scale 변경을 매트릭스로 표현할 수 있습니다. x축, y축을 그대로 늘리거나 돌리거나 하는 느낌으로 이해할 수 있는 것 같습니다. 40s 매트릭스는 열 기준으로 봐야 하며, (a, c) 가 x축, (b, d)가 y축을 의미합니다. 현재 모델의 각 점(v0 ~ v3)에 transform matrix를 적용하면, 아래 그림처럼 점들이 이동합니다. 44s 기준이 되는 x축을 요렇게 잡아당기는 느낌입니다. 여기서는 i벡터(1, 0)를 (a, c) 로 옮겼습니다. (j는 그냥 둠) 기준 축이 (1, 0)에서 (a, c)로 바뀌면서, 사각형이 따라서 커지고 기울어짐. ","date":"2021-11-22","objectID":"/2021-11-22_transform-matrix/:2:1","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'2D Transformations - Vulkan Game Engine Tutorial 10' 정리","uri":"/2021-11-22_transform-matrix/#21-변환-행렬을-통한-vertex의-이동"},{"categories":["게임 개발"],"content":" 2.2. Game Object게임 화면에 표시되서 독립적으로 존재하는 객체를 Game Object라고 부릅니다. 181s 245s Game Object 를 구현하는 여러가지 접근법이 있는데, 우리는 ECS(Entity Component System) 이라는 걸 아주 간략화해서 구현할 겁니다. ","date":"2021-11-22","objectID":"/2021-11-22_transform-matrix/:2:2","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'2D Transformations - Vulkan Game Engine Tutorial 10' 정리","uri":"/2021-11-22_transform-matrix/#22-game-object"},{"categories":["게임 개발"],"content":" 2.3. scale matrix669s 모델의 크기를 늘리기 위한 매트릭스 입니다. 매트릭스를 만들 때, 열 방향으로 짝 지어서 만들어 줘야 합니다. glm::mat2 scaleMat{ {scale.x, .0f}, {.0f, scale.y} }; ","date":"2021-11-22","objectID":"/2021-11-22_transform-matrix/:2:3","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'2D Transformations - Vulkan Game Engine Tutorial 10' 정리","uri":"/2021-11-22_transform-matrix/#23-scale-matrix"},{"categories":["게임 개발"],"content":" 2.4. rotation matrix회전을 위한 매트릭스를 만듭니다. 745s 775s ɵ 라디안 만큼 돌리고 싶을 때, 코사인, 사인으로 위와 같이 매트릭스를 구성합니다. 움.. 그런가 부다 합시다 ㅠㅜㅋ 839s vulkan 에서는 y축이 보통의 수학과는 반대로 아래쪽이 플러스입니다. 플러스 90도 만큼 회전시켰을 때, 고등학교때를 생각해보면 왼쪽으로 돌아가야 하는데, vulakn 에서는 y축 플러스 방향이 아래쪽이라, 오른쪽으로 90도 돌았습니다. ","date":"2021-11-22","objectID":"/2021-11-22_transform-matrix/:2:4","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'2D Transformations - Vulkan Game Engine Tutorial 10' 정리","uri":"/2021-11-22_transform-matrix/#24-rotation-matrix"},{"categories":["게임 개발"],"content":" 2.5. matrix 적용 순서100s 매트릭스 곱하기은 교환법칙이 성립하지 않습니다. 아래 그림에서도 scale 먼저 하고 rotate 한 것과, rotate 먼저 하고 scale 한 것은 결과가 다릅니다. (스케일 먼저 하고, 그 다음에 로테이션하는 게 이해가 쉬움) cpp에서나 shader 코드에서 먼저 적용해야 하는 매트릭스가 오른쪽에 와야 합니다. (column major order) glm::mat2 mat2() { const float s = glm::sin(rotation); const float c = glm::cos(rotation); glm::mat2 rotMatrix{ {c, s}, {-s, c} }; glm::mat2 scaleMat{ {scale.x, .0f}, {.0f, scale.y} }; return rotMatrix * scaleMat; // scale 먼저 한 후, rotate }; ","date":"2021-11-22","objectID":"/2021-11-22_transform-matrix/:2:5","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'2D Transformations - Vulkan Game Engine Tutorial 10' 정리","uri":"/2021-11-22_transform-matrix/#25-matrix-적용-순서"},{"categories":["게임 개발"],"content":" 3. 코드 수정","date":"2021-11-22","objectID":"/2021-11-22_transform-matrix/:3:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'2D Transformations - Vulkan Game Engine Tutorial 10' 정리","uri":"/2021-11-22_transform-matrix/#3-코드-수정"},{"categories":["게임 개발"],"content":" 3.1. simple_shader.vertpush constant 에 transform 추가 layout(location = 1) in vec3 color; layout(push_constant) uniform Push { mat2 transform; // tranform 매트릭스 vec2 offset; vec3 color; } push; void main() { gl_Position = vec4(push.transform * position + push.offset, 0.0, 1.0); // 포지션에 transform 매트릭스 적용 } ","date":"2021-11-22","objectID":"/2021-11-22_transform-matrix/:3:1","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'2D Transformations - Vulkan Game Engine Tutorial 10' 정리","uri":"/2021-11-22_transform-matrix/#31-simple_shadervert"},{"categories":["게임 개발"],"content":" 3.2. LveGameObejct 추가 게임상의 오브젝트를 표현하는 객체 id와 모델을 가짐 모델의 position, scale, rotation 을 나타내는 Transform2dComponent 가짐 ","date":"2021-11-22","objectID":"/2021-11-22_transform-matrix/:3:2","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'2D Transformations - Vulkan Game Engine Tutorial 10' 정리","uri":"/2021-11-22_transform-matrix/#32-lvegameobejct-추가"},{"categories":["게임 개발"],"content":" 3.3. FirstApp 클래스 수정(1) SimplePushCosntantData 구조체에 transform 추가 . shader 의 push_constant 와 맞춰줌 struct SimplePushConstantData { glm::mat2 transform{1.f}; // Identity Matrix 로 초기화 glm::vec2 offset; alignas(16) glm::vec3 color; }; (2) LveModel 대신 LveGameObject 들을 가지도록 함 . loadGameObjects() 메소드에서 GameObject 하나 만들고 모델 및 속성 값들 설정한 후, 내부 멤버 변수(vector)에 추가 (3) renderGameObjects() 메소드 추가 . recordCommandBuffer() 내부에서 호출해서, 모든 GameObject 들을 그리도록 함. . 각 GameObject 별로, push_const 업데이트 -\u003e 모델 bind -\u003e draw ","date":"2021-11-22","objectID":"/2021-11-22_transform-matrix/:3:3","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'2D Transformations - Vulkan Game Engine Tutorial 10' 정리","uri":"/2021-11-22_transform-matrix/#33-firstapp-클래스-수정"},{"categories":["게임 개발"],"content":" 3.4. 다이어그램 ","date":"2021-11-22","objectID":"/2021-11-22_transform-matrix/:3:4","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'2D Transformations - Vulkan Game Engine Tutorial 10' 정리","uri":"/2021-11-22_transform-matrix/#34-다이어그램"},{"categories":["게임 개발"],"content":" 3.5. 결과 화면 삼각형이 오른쪽으로 회전합니다. ","date":"2021-11-22","objectID":"/2021-11-22_transform-matrix/:3:5","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'2D Transformations - Vulkan Game Engine Tutorial 10' 정리","uri":"/2021-11-22_transform-matrix/#35-결과-화면"},{"categories":["게임 개발"],"content":" 4. Summary974s transformation matrix 의 각 열은 i벡터, j벡터가 어디로 가야하는 알려 줍니다. transformation은 곱하기로 같이 적용될 수 있습니다. 매트릭스 곱하기는 결합법칙은 성립하지만, 교환법칙은 성립하지 않습니다. ","date":"2021-11-22","objectID":"/2021-11-22_transform-matrix/:4:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'2D Transformations - Vulkan Game Engine Tutorial 10' 정리","uri":"/2021-11-22_transform-matrix/#4-summary"},{"categories":["게임 개발"],"content":"LittleVulkanEngine 을 따라 만들어 보면서, Vulkan을 배워봅시다. Youtube Link ","date":"2021-11-15","objectID":"/2021-11-15_push-constants/:0:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Push Constants - Vulkan Game Engine Tutorial 09' 정리","uri":"/2021-11-15_push-constants/#"},{"categories":["게임 개발"],"content":" 1. 주요내용 Push Constants 는 쉐이더에 작은 상수 값을 전달하기 위한 방법 따로 메모리에 쓰거나 카피하지 않고, Vulkan Command Buffer를 사용함 자주 업데이트 되는 데이터에 유용하지만, 사이즈 제한 있음 ","date":"2021-11-15","objectID":"/2021-11-15_push-constants/:1:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Push Constants - Vulkan Game Engine Tutorial 09' 정리","uri":"/2021-11-15_push-constants/#1-주요내용"},{"categories":["게임 개발"],"content":" 2. Push Constant 설명","date":"2021-11-15","objectID":"/2021-11-15_push-constants/:2:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Push Constants - Vulkan Game Engine Tutorial 09' 정리","uri":"/2021-11-15_push-constants/#2-push-constant-설명"},{"categories":["게임 개발"],"content":" 2.1. 존재의 이유커맨드 버퍼를 통해 쉐이더에 상수 값들을 전달할 수 있습니다. 8s 같은 모델에다 다른 상수를 적용해서 여러 번 그리는 게 가능합니다. 70s transform 매트릭스 넘기는데 많이 사용한다고 합니다. 757s 요거는 Linear Algebra 이해가 좀 필요한데, 아래 유튜브 영상을 추천했습니다. 3Blue1Browns Linear algebra series ","date":"2021-11-15","objectID":"/2021-11-15_push-constants/:2:1","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Push Constants - Vulkan Game Engine Tutorial 09' 정리","uri":"/2021-11-15_push-constants/#21-존재의-이유"},{"categories":["게임 개발"],"content":" 2.2. 단점사이즈 제한 있습니다. (128bytes 만 개런티 함) ","date":"2021-11-15","objectID":"/2021-11-15_push-constants/:2:2","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Push Constants - Vulkan Game Engine Tutorial 09' 정리","uri":"/2021-11-15_push-constants/#22-단점"},{"categories":["게임 개발"],"content":" 2.3. VkPushConstantRange 구조체PipelineLayout 만들때 세팅해줘야 합니다. (이런 push constant 를 사용할꺼야 라고 알려주는 느낌) . stage flags : 어떤 쉐이더에서 접근할 것인가? 119s . offset : separate 방식으로 쓸 경우 필요 . size : 사이즈 132s ","date":"2021-11-15","objectID":"/2021-11-15_push-constants/:2:3","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Push Constants - Vulkan Game Engine Tutorial 09' 정리","uri":"/2021-11-15_push-constants/#23-vkpushconstantrange-구조체"},{"categories":["게임 개발"],"content":" 2.4. Separate vs Shared쉐이더별로 push constant 를 구분하는 것보다, 여러 쉐이더에서 같이 쓰는걸 추천 한다고 합니다. 159s ","date":"2021-11-15","objectID":"/2021-11-15_push-constants/:2:4","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Push Constants - Vulkan Game Engine Tutorial 09' 정리","uri":"/2021-11-15_push-constants/#24-separate-vs-shared"},{"categories":["게임 개발"],"content":" 3. 코드 수정","date":"2021-11-15","objectID":"/2021-11-15_push-constants/:3:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Push Constants - Vulkan Game Engine Tutorial 09' 정리","uri":"/2021-11-15_push-constants/#3-코드-수정"},{"categories":["게임 개발"],"content":" 3.1. FirstApp 클래스 수정(1) lve 네임스페이스에 SimplePushConstantData 구조체 추가 struct SimplePushConstantData { glm::vec2 offset; alignas(16) glm::vec3 color; }; . 쉐이더 코드에서 해석을 위해, 메모리 레이아웃 align을 맞춰야 합니다. (alignas(16) 사용) 566s (2) createPipelineLayout() 에서 VkPushConstantRange 세팅 (3) recordCommandBuffer() 에서 SimplePushConstantData 에 적절히 값 채워서 vkCmdPushConstants() 호출 . vkCmdPushConstants() 호출 한 후에 draw() static int frame = 0; frame = (frame + 1) % 100; // ... for (int j = 0; j \u003c 4; j++) { SimplePushConstantData push{}; push.offset = { -0.5f + frame * 0.02f, -0.4f + j * 0.25f }; push.color = { 0.0f, 0.0f, 0.2f + 0.2f * j }; vkCmdPushConstants( commandBuffers[imageIndex], pipelineLayout, VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, 0, sizeof(SimplePushConstantData), \u0026push); lveModel-\u003edraw(commandBuffers[imageIndex]); } ","date":"2021-11-15","objectID":"/2021-11-15_push-constants/:3:1","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Push Constants - Vulkan Game Engine Tutorial 09' 정리","uri":"/2021-11-15_push-constants/#31-firstapp-클래스-수정"},{"categories":["게임 개발"],"content":" 3.2. simple_shader.vert// ... layout(push_constant) uniform Push { // 요렇게 push constant 받는 거 명시 vec2 offset; vec3 color; } push; void main() { gl_Position = vec4(position + push.offset, 0.0, 1.0); // offset 값 사용 } ","date":"2021-11-15","objectID":"/2021-11-15_push-constants/:3:2","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Push Constants - Vulkan Game Engine Tutorial 09' 정리","uri":"/2021-11-15_push-constants/#32-simple_shadervert"},{"categories":["게임 개발"],"content":" 3.3. simple_shader.fraglayout (location = 0) out vec4 outColor; layout(push_constant) uniform Push { // 여기서도 요렇게 받음 vec2 offset; vec3 color; } push; void main() { outColor = vec4(push.color, 1.0); // color 값 사용 } ","date":"2021-11-15","objectID":"/2021-11-15_push-constants/:3:3","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Push Constants - Vulkan Game Engine Tutorial 09' 정리","uri":"/2021-11-15_push-constants/#33-simple_shaderfrag"},{"categories":["게임 개발"],"content":" 3.4. 결과 화면 요 삼각형들이 오른쪽으로 움직입니다. ","date":"2021-11-15","objectID":"/2021-11-15_push-constants/:3:4","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Push Constants - Vulkan Game Engine Tutorial 09' 정리","uri":"/2021-11-15_push-constants/#34-결과-화면"},{"categories":["게임 개발"],"content":" 3.5. 다이어그램 ","date":"2021-11-15","objectID":"/2021-11-15_push-constants/:3:5","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Push Constants - Vulkan Game Engine Tutorial 09' 정리","uri":"/2021-11-15_push-constants/#35-다이어그램"},{"categories":["게임 개발"],"content":" 4. Summary730s 해당 모델의 draw call 전에 불려야 해서, 모델 여러개를 Vertex Buffer 하나로 바인드 했을 경우에는 사용이 불가합니다. ","date":"2021-11-15","objectID":"/2021-11-15_push-constants/:4:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Push Constants - Vulkan Game Engine Tutorial 09' 정리","uri":"/2021-11-15_push-constants/#4-summary"},{"categories":["게임 개발"],"content":"LittleVulkanEngine 을 따라 만들어 보면서, Vulkan을 배워봅시다. Youtube Link ","date":"2021-11-04","objectID":"/2021-11-04_swap-chain-recreation/:0:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Swap Chain Recreation \u0026 Dynamic Viewports - Vulkan Game Engine Tutorial 08' 정리","uri":"/2021-11-04_swap-chain-recreation/#"},{"categories":["게임 개발"],"content":" 1. 주요내용 윈도우 사이즈 바뀌었을 때 처리 추가 SwapChain 재생성 pipeline에서 dynamic viewport 사용 ","date":"2021-11-04","objectID":"/2021-11-04_swap-chain-recreation/:1:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Swap Chain Recreation \u0026 Dynamic Viewports - Vulkan Game Engine Tutorial 08' 정리","uri":"/2021-11-04_swap-chain-recreation/#1-주요내용"},{"categories":["게임 개발"],"content":" 2. 윈도우 사이즈 변경에 따른 변경윈도우 사이즈가 바뀌면(framebuffer 의 크기가 달라지면), SwapChain을 다시 만들어야 합니다. 33s 현재로써는 swapchain의 width, height 에 디펜던시가 있는 pipeline 도 다시 만들어야 합니다. 원래는 swap chain 이 바뀌어도 RenderPass 가 compatible 하다면(타겟 프레임 버퍼의 형식이 바뀐게 아니라면), 기존에 만들었던 pipeline을 그대로 쓸수 있다고 합니다. (이번 강의의 경우처럼 단순한 윈도우 리사이즈 같은 경우를 말하는 것 같습니다.) 773s 나중에 그렇게 하기 위해, pipeline 에서 swapchain 으로의 디펜던시(화면 크기)를 없앱니다. (dynamic viewport 사용) pipeline을 재사용 하는 건 나중에 할 겁니다 ㅎ 지금은 그냥 다시 만듭시다. std::move() 도 한 번 알아보도록 합시다. (learncpp.com) ","date":"2021-11-04","objectID":"/2021-11-04_swap-chain-recreation/:2:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Swap Chain Recreation \u0026 Dynamic Viewports - Vulkan Game Engine Tutorial 08' 정리","uri":"/2021-11-04_swap-chain-recreation/#2-윈도우-사이즈-변경에-따른-변경"},{"categories":["게임 개발"],"content":" 3. 수정 내용 요약1056s glfw 단에 윈도우의 사이즈 바뀌는 것에 콜백 등록 매 프레임마다, 윈도우 사이즈가 바뀌었는지, swapChain이 valid 한지 확인 파이프라인에서 dynamic viewport 사용 → swapChain의 크기에 대한 dependency 없어짐 TODO: Render pass 의 compatibility 체크해서 pipeline 재사용 (나중에 할 거임) ","date":"2021-11-04","objectID":"/2021-11-04_swap-chain-recreation/:3:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Swap Chain Recreation \u0026 Dynamic Viewports - Vulkan Game Engine Tutorial 08' 정리","uri":"/2021-11-04_swap-chain-recreation/#3-수정-내용-요약"},{"categories":["게임 개발"],"content":" 4. 구현","date":"2021-11-04","objectID":"/2021-11-04_swap-chain-recreation/:4:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Swap Chain Recreation \u0026 Dynamic Viewports - Vulkan Game Engine Tutorial 08' 정리","uri":"/2021-11-04_swap-chain-recreation/#4-구현"},{"categories":["게임 개발"],"content":" 4.1. LveWindow 수정 width, height 에서 const 제거 framebufferResized 플래그 추가 윈도우 리사이즈 콜백을 받기 위한 framebufferResizedCallback() 클래스 메소드 추가 ","date":"2021-11-04","objectID":"/2021-11-04_swap-chain-recreation/:4:1","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Swap Chain Recreation \u0026 Dynamic Viewports - Vulkan Game Engine Tutorial 08' 정리","uri":"/2021-11-04_swap-chain-recreation/#41-lvewindow-수정"},{"categories":["게임 개발"],"content":" 4.2. FirstApp 수정 recreateSwapChain() 추가 윈도우 리사이즈 콜백 받았을 때 불러서, lveSwapChain 새로 생성 및 createPipeline() 호출 recordCommandBuffer() 추가 매 프레임 커맨트 버퍼를 레코딩하기로 함 lvePipeline 에 bind()하기 전에, viewport와 scissor 세팅 lveSwapChain 멤버 변수에 스마트 포인터 사용 drawFrame() 수정 swapchain에 acquireNextImage() 가 실패하거나, submitCommandBuffers() 가 실패할 경우, recreateSwapChain() freeCommandBuffers() 추가 ","date":"2021-11-04","objectID":"/2021-11-04_swap-chain-recreation/:4:2","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Swap Chain Recreation \u0026 Dynamic Viewports - Vulkan Game Engine Tutorial 08' 정리","uri":"/2021-11-04_swap-chain-recreation/#42-firstapp-수정"},{"categories":["게임 개발"],"content":" 4.3. LvePipeline 수정 dynamicStateInfo 채움 (VkPipelineDynamicStateCreaeInfo) viewport 와 scissor 를 다이나믹하게 사용 defaultPipelineConfigInfo() 에서 width, height 사용하지 않음 ","date":"2021-11-04","objectID":"/2021-11-04_swap-chain-recreation/:4:3","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Swap Chain Recreation \u0026 Dynamic Viewports - Vulkan Game Engine Tutorial 08' 정리","uri":"/2021-11-04_swap-chain-recreation/#43-lvepipeline-수정"},{"categories":["게임 개발"],"content":" 4.4. LveSwapChain 수정 previous Swapchain 도 받는 생성자 추가 createSwapChain() 에서 기존 SwapChain 넘김 init() 추가 oldSwapChain 멤버 추가 ","date":"2021-11-04","objectID":"/2021-11-04_swap-chain-recreation/:4:4","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Swap Chain Recreation \u0026 Dynamic Viewports - Vulkan Game Engine Tutorial 08' 정리","uri":"/2021-11-04_swap-chain-recreation/#44-lveswapchain-수정"},{"categories":["게임 개발"],"content":" 5. 다이어그램","date":"2021-11-04","objectID":"/2021-11-04_swap-chain-recreation/:5:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Swap Chain Recreation \u0026 Dynamic Viewports - Vulkan Game Engine Tutorial 08' 정리","uri":"/2021-11-04_swap-chain-recreation/#5-다이어그램"},{"categories":["게임 개발"],"content":" 5.1. 클래스 LveWindow 생성 LveDevice 생성 FirstApp() 생성자 호출 4. LveModel 생성 5. LveSwapChain 생성 6. LvePipeline 생성 이후, FirstApp::run() 에서 매프레임마다 commandBuffer 레코딩 및 서밋. ","date":"2021-11-04","objectID":"/2021-11-04_swap-chain-recreation/:5:1","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Swap Chain Recreation \u0026 Dynamic Viewports - Vulkan Game Engine Tutorial 08' 정리","uri":"/2021-11-04_swap-chain-recreation/#51-클래스"},{"categories":["게임 개발"],"content":" 5.2. 시퀀스FirstApp 클래스의 인스턴스 생성 부분입니다. 다음은 run()의 루프 부분입니다. ","date":"2021-11-04","objectID":"/2021-11-04_swap-chain-recreation/:5:2","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Swap Chain Recreation \u0026 Dynamic Viewports - Vulkan Game Engine Tutorial 08' 정리","uri":"/2021-11-04_swap-chain-recreation/#52-시퀀스"},{"categories":["blog"],"content":"퍼블릭한 기록을 남겨야 해야, 제가 제대로 이해하고 있는지 확인할 수 있습니다. 그런 면에서 블로그에 글을 남기는 것은 아주 좋은 습관인것 같습니다. 여러 블로그 툴들을 살펴 보다가, Hugo에 한 번 정착해보기로 했습니다. 주요 기준은 아래와 같았습니다. Markdown 으로 글을 작성하기 쉬울 것 category 별로 글들을 분류할 수 있을 것 빌드가 빠릿빠릿 할 것 예쁜 테마가 있을 것 나중에 광고도 붙일 수 있을 것 네이버 블로그나 Tistory, velog 도 좋은 옵션이 될 수 있겠지만, 개발자 스럽게 static 페이지를 호스팅해주는 Github Pages를 활용해 보기로 했습니다. static 사이트를 만들어주는 여러 툴들이 있는데, Jekyll, Gatsby, Hugo 정도가 유명한 것 같습니다. 요 중에 Jekyll은 제가 Ruby를 전혀 모르니, 뭔가 수정해보고 싶을 때 어려울 것 같았습니다. Gatsby는 React로 되어 있어서 끌리긴 했는데, 글이 많아지면 빌드가 느리다는 평이 있었습니다. Hugo는 빌드가 정말 빨리 되더군요. 다른 디펜던시 없이 그냥 Hugo만 설치하면 되는 것도 좋았습니다. 테마도 서핑하던 중 괜찮은 테마(zzo theme)가 보여서 요걸 선택하기로 했습니다. 테마 제작자분이 한국 분인것도 큰 요인 이었습니다. ㅎ 감사합니다~! 잘 쓰겠습니다^^ 🙏 예전에 Jekyll로 시도 했었던 글 들, Tistory에서 썼던 글들을 긁어 오려면 조금 귀찮기도 하겠지만, 그래도 시도해 봐야죠. ㅎ 으쌰으쌰~! ","date":"2021-11-02","objectID":"/2021-11-02_new-begining/:0:0","series":null,"tags":["hugo"],"title":"Hugo와 함께 새로운 블로그 시작","uri":"/2021-11-02_new-begining/#"},{"categories":["게임 개발"],"content":"LittleVulkanEngine 을 따라 만들어 보면서, Vulkan을 배워봅시다. Youtube Link ","date":"2021-10-27","objectID":"/2021-10-27_fragment-interpolation/:0:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Fragment Interpolation - Vulkan Game Engine Tutorial 07' 정리","uri":"/2021-10-27_fragment-interpolation/#"},{"categories":["게임 개발"],"content":" 1. 주요내용 Fragment Interpolation 설명 Vertex 데이터에 색깔 추가해서, fragment shader 에서 사용 ","date":"2021-10-27","objectID":"/2021-10-27_fragment-interpolation/:1:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Fragment Interpolation - Vulkan Game Engine Tutorial 07' 정리","uri":"/2021-10-27_fragment-interpolation/#1-주요내용"},{"categories":["게임 개발"],"content":" 2. vertex shader 에서 fragment shader 로 데이터 전달​ vertex shader 에서, fragment shader 로 데이터를 넘길 수 있습니다. ​ 36s vertex shader 에서 out, fragment shader 에서는 in 으로 지정합니다. 양쪽의 location 일치해야 하고, 변수명은 상관 없습니다. ​ vertex shader 는 vertex(점)별로 호출되고, resterization을 거친 후, fragment shader 는 픽셀별로 호출됩니다. ​ 59s ​ 그렇다면 삼각형 중간에 있는 픽셀들의 인풋 값들은 어떻게 만들어지는 걸까요? 답은 linear interpolation 입니다. ​ ​ ","date":"2021-10-27","objectID":"/2021-10-27_fragment-interpolation/:2:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Fragment Interpolation - Vulkan Game Engine Tutorial 07' 정리","uri":"/2021-10-27_fragment-interpolation/#2-vertex-shader-에서-fragment-shader-로-데이터-전달"},{"categories":["게임 개발"],"content":" 3. Linear Interpolation 점 몇개만 찍혀 있을 때, 중간 값들을 어떻게 유추해야 할까요? 심플하게 점 사이를 직선으로 이어버리는 방법이 linear interpolation 입니다. 111s ​​ 직선에서의 예시입니다. 143s ​​ 2-dimensions 에서도 똑같이 계산 됩니다. 166s ​ position 말고도 어떤 타입이라도 interpolation 가능합니다. 위 그림처럼 color 두요. ​ ​ ","date":"2021-10-27","objectID":"/2021-10-27_fragment-interpolation/:3:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Fragment Interpolation - Vulkan Game Engine Tutorial 07' 정리","uri":"/2021-10-27_fragment-interpolation/#3-linear-interpolation"},{"categories":["게임 개발"],"content":" 4. Barycentric Coordinates​ 삼각형에서는 어떻게 interpolation 할까요? ​ ​ ​ Barycentric Coordinates 를 이용해서 interpolation 수행한다고 합니다. gpu 가 알아서 잘 할겁니다. ​ 255s ​ ​ 2차원으로 생각하면, 변수가 t 하나 였던 게, 베타, 감마 두 개로 늘어났다고 생각하면 된다고 합니다. 3차원이면, 변수가 하나 더 늘어나구요. 다시 pipeline으로 돌아가 봅시다. ​ 각 픽셀의 위치 따라 다른 알파, 베타, 감마값으로 interpolation 된 값이 Fragment shader 의 인풋으로 들어갑니다. 320s ​ ​ ​ ","date":"2021-10-27","objectID":"/2021-10-27_fragment-interpolation/:4:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Fragment Interpolation - Vulkan Game Engine Tutorial 07' 정리","uri":"/2021-10-27_fragment-interpolation/#4-barycentric-coordinates"},{"categories":["게임 개발"],"content":" 5. SIMD model​ 이번 강좌의 결과에서, vertex shader 는 3번 불리고,​ ​ ​ fragment shader 는 60000번 다른 인풋으로 불려야 합니다. ​ ​요 때, interpolation 은 gpu 하드웨어에 의해서 매우 빠르게 수행됩니다. ​ SIMD model (Single Instruction Multiple Data) 이라는 gpu의 작동 방식 때문이라고 합니다. ​ 721s ​ ​ 같은 instruction을 여러 점에 대해서 동시에 수행하는 거죠. 유연성 희생한 대신, 요런 동작에 최적화되어 있습니다. ​ ​ ","date":"2021-10-27","objectID":"/2021-10-27_fragment-interpolation/:5:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Fragment Interpolation - Vulkan Game Engine Tutorial 07' 정리","uri":"/2021-10-27_fragment-interpolation/#5-simd-model"},{"categories":["게임 개발"],"content":" 6. 구현","date":"2021-10-27","objectID":"/2021-10-27_fragment-interpolation/:6:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Fragment Interpolation - Vulkan Game Engine Tutorial 07' 정리","uri":"/2021-10-27_fragment-interpolation/#6-구현"},{"categories":["게임 개발"],"content":" 6.1. simple_shader.vertlayout(location = 0) in vec2 position; layout(location = 1) in vec3 color; ​ layout(location = 0) out vec3 fragColor; // in, out 간에는 location 무관함 ​ void main() { gl_Position = vec4(position, 0.0, 1.0); fragColor = color; // input 으로 들어온 color 를 fragment shader에서 사용할 수 있도록 out 변수에 넘김 } in, out 간에는 location 무관함 in 으로 들어온 color 를 fragment shader에서 사용할 수 있도록 out 의 변수에 넘김 ​ ","date":"2021-10-27","objectID":"/2021-10-27_fragment-interpolation/:6:1","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Fragment Interpolation - Vulkan Game Engine Tutorial 07' 정리","uri":"/2021-10-27_fragment-interpolation/#61-simple_shadervert"},{"categories":["게임 개발"],"content":" 6.2. simple_shader.fraglayout (location = 0) in vec3 fragColor; // 데이터 형 맞춰야 함 layout (location = 0) out vec4 outColor; ​ void main() { outColor = vec4(fragColor, 1.0); // 하드코딩 대신 넘어온 값 사용 } in 으로 들어온 데이터가, vertex shader 에서 out 으로 내보낸 데이터와 형식 및 location 맞아야 함 하드코딩 대신 넘어온 컬러 값 사용 ​ ","date":"2021-10-27","objectID":"/2021-10-27_fragment-interpolation/:6:2","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Fragment Interpolation - Vulkan Game Engine Tutorial 07' 정리","uri":"/2021-10-27_fragment-interpolation/#62-simple_shaderfrag"},{"categories":["게임 개발"],"content":" 6.3. LveModel::Vertex 수정 LveModel::Vertex 에 color 추가 getAttributeDescriptions() 에 color 관련 정보 추가 offset 은 offsetof() 매크로로 계산 ​ ","date":"2021-10-27","objectID":"/2021-10-27_fragment-interpolation/:6:3","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Fragment Interpolation - Vulkan Game Engine Tutorial 07' 정리","uri":"/2021-10-27_fragment-interpolation/#63-lvemodelvertex-수정"},{"categories":["게임 개발"],"content":" 6.4. FirstApp 수정​ Vertex data 에 color 값들 추가 ​ ","date":"2021-10-27","objectID":"/2021-10-27_fragment-interpolation/:6:4","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Fragment Interpolation - Vulkan Game Engine Tutorial 07' 정리","uri":"/2021-10-27_fragment-interpolation/#64-firstapp-수정"},{"categories":["게임 개발"],"content":" 6.5. 결과​ ​ ​ ","date":"2021-10-27","objectID":"/2021-10-27_fragment-interpolation/:6:5","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Fragment Interpolation - Vulkan Game Engine Tutorial 07' 정리","uri":"/2021-10-27_fragment-interpolation/#65-결과"},{"categories":["게임 개발"],"content":" 7. 다이어그램​ ","date":"2021-10-27","objectID":"/2021-10-27_fragment-interpolation/:7:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Fragment Interpolation - Vulkan Game Engine Tutorial 07' 정리","uri":"/2021-10-27_fragment-interpolation/#7-다이어그램"},{"categories":["게임 개발"],"content":"LittleVulkanEngine 을 따라 만들어 보면서, Vulkan을 배워봅시다. Youtube Link ","date":"2021-10-26","objectID":"/2021-10-26_vertex-buffers/:0:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Vertex Buffers - Vulkan Game Engine Tutorial 06' 정리","uri":"/2021-10-26_vertex-buffers/#"},{"categories":["게임 개발"],"content":" 1. 주요내용 Vertext Buffer 설명 LveModel 클래스 추가 지금까지는 vertex data 를 vertex shader 안에다 하드코딩 했습니다. 요걸 쉐이더 코드 밖으로 빼내도록 합시다. ","date":"2021-10-26","objectID":"/2021-10-26_vertex-buffers/:1:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Vertex Buffers - Vulkan Game Engine Tutorial 06' 정리","uri":"/2021-10-26_vertex-buffers/#1-주요내용"},{"categories":["게임 개발"],"content":" 2. Vertex Buffer 설명Vertex buffer는 커다란 데이터 덩어리입니다. 하나의 vertex 에는 여러 attribute가 있을 수 있는데, 여러 vertex의 데이터를 어떻게 묶을 것인가를 생각하보면, vertex 별로 모아 놓거나, attribute 별로 모아 둘 수 있습니다. ","date":"2021-10-26","objectID":"/2021-10-26_vertex-buffers/:2:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Vertex Buffers - Vulkan Game Engine Tutorial 06' 정리","uri":"/2021-10-26_vertex-buffers/#2-vertex-buffer-설명"},{"categories":["게임 개발"],"content":" 2.1. per vertex (or per instance)97s 여러 attribute 가 있을 때, vertex 별로 묶어서 두는 방법입니다. position(x, y), color(r,g,b) 가 vertex의 attribute 로 있는 경우의 예 입니다. ","date":"2021-10-26","objectID":"/2021-10-26_vertex-buffers/:2:1","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Vertex Buffers - Vulkan Game Engine Tutorial 06' 정리","uri":"/2021-10-26_vertex-buffers/#21-per-vertex-or-per-instance"},{"categories":["게임 개발"],"content":" 2.2. separate binding115s 한 종류의 데이터만 가지는 Vertex Buffer 여러 개 만들어서 각각 바인딩을 하는 방법도 있습니다. 각 attribute 별로 모여 있게 두는 방법입니다. ","date":"2021-10-26","objectID":"/2021-10-26_vertex-buffers/:2:2","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Vertex Buffers - Vulkan Game Engine Tutorial 06' 정리","uri":"/2021-10-26_vertex-buffers/#22-separate-binding"},{"categories":["게임 개발"],"content":" 2.3. Vertex Binding Descriptions어떤 조합도 가능하긴 합니다. 각 Vertex Buffer 마다 바인딩 정보를 알려줘야 합니다. binding 0번, stride(한 vertex에 해당하는 토막이 몇 byte인지) 20 ","date":"2021-10-26","objectID":"/2021-10-26_vertex-buffers/:2:3","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Vertex Buffers - Vulkan Game Engine Tutorial 06' 정리","uri":"/2021-10-26_vertex-buffers/#23-vertex-binding-descriptions"},{"categories":["게임 개발"],"content":" 2.4. Vertex Attribute Descriptions각 attribute 에 대한 description도 있어야 합니다. 195s binding, location, offset, format 을 알려줘야 합니다. 위 그림에서 color attribute의 경우를 보면, bionding은 0 : 0번으로 binding 된 Vertex Buffer임 location은 1 : Vertex Shader 로 넘길 때, 1번 위치임, 0번은 position offset은 8 : 앞의 position이 4bytes 정수 2개로 이루어져 있어서, 8bytes 지난 부분에 color 데이터 있음 format은 R32G32B32 : 4byte float 3개 필요함 format은 컬러가 아니어도(position) 컬러 포맷을 사용합니다. 아래 포맷들이 자주 쓰인다고 합니다. ","date":"2021-10-26","objectID":"/2021-10-26_vertex-buffers/:2:4","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Vertex Buffers - Vulkan Game Engine Tutorial 06' 정리","uri":"/2021-10-26_vertex-buffers/#24-vertex-attribute-descriptions"},{"categories":["게임 개발"],"content":" 2.5. Binding vs Buffer258s 메모리 alloc 을 줄이기 위해, 메모리를 크게 잡고 바인딩을 여러 개 할 수도 있습니다. ","date":"2021-10-26","objectID":"/2021-10-26_vertex-buffers/:2:5","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Vertex Buffers - Vulkan Game Engine Tutorial 06' 정리","uri":"/2021-10-26_vertex-buffers/#25-binding-vs-buffer"},{"categories":["게임 개발"],"content":" 2.6. Interleaved vs Separate binding?295s 간단한 상황에서 보통은 싱글 interleaved 가 추천된다고 합니다. 물론, 상황이 복잡해지면 separate binding 이 나을 수도 있습니다. ","date":"2021-10-26","objectID":"/2021-10-26_vertex-buffers/:2:6","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Vertex Buffers - Vulkan Game Engine Tutorial 06' 정리","uri":"/2021-10-26_vertex-buffers/#26-interleavedvsseparatebinding"},{"categories":["게임 개발"],"content":" 2.7. 메모리풀gpu 메모리 할당은 비싼 작업이라서, 메모리풀을 만들어서 쓰는 게 좋다고 합니다. 나중에 언젠가 Vulkan Memory Allocator 도 한 번 보도록 합시다. 우리는 그냥 LveDevice::createBuffer() 사용할 겁니다. ","date":"2021-10-26","objectID":"/2021-10-26_vertex-buffers/:2:7","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Vertex Buffers - Vulkan Game Engine Tutorial 06' 정리","uri":"/2021-10-26_vertex-buffers/#27-메모리풀"},{"categories":["게임 개발"],"content":" 3. 구현","date":"2021-10-26","objectID":"/2021-10-26_vertex-buffers/:3:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Vertex Buffers - Vulkan Game Engine Tutorial 06' 정리","uri":"/2021-10-26_vertex-buffers/#3-구현"},{"categories":["게임 개발"],"content":" 3.1. LveModel 클래스 추가 VkBuffer, VkDeviceMemory 따로 있음 create GPU 쪽에 메모리 만들어서, 거기다가 vertex data 복사 1052s bind() : vkCmdBindVertexBuffers() 호출 (커맨드 버퍼에 해당 Vertex Buffer 바인딩) draw() : vkCmdDraw() 호출 ","date":"2021-10-26","objectID":"/2021-10-26_vertex-buffers/:3:1","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Vertex Buffers - Vulkan Game Engine Tutorial 06' 정리","uri":"/2021-10-26_vertex-buffers/#31-lvemodel-클래스-추가"},{"categories":["게임 개발"],"content":" 3.2. LveModel::Vertex 구조체 추가 position(vec2) 정보 가짐 static getBindingDescriptions() : vertex 바인딩 디스크립션 리턴 static getAttributeDescription() : vertex 어트리뷰트 디스크립션 리턴 ","date":"2021-10-26","objectID":"/2021-10-26_vertex-buffers/:3:2","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Vertex Buffers - Vulkan Game Engine Tutorial 06' 정리","uri":"/2021-10-26_vertex-buffers/#32-lvemodelvertex-구조체-추가"},{"categories":["게임 개발"],"content":" 3.3. simple_shader.vert 하드 코딩했던 vertex data 제거 ","date":"2021-10-26","objectID":"/2021-10-26_vertex-buffers/:3:3","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Vertex Buffers - Vulkan Game Engine Tutorial 06' 정리","uri":"/2021-10-26_vertex-buffers/#33-simple_shadervert"},{"categories":["게임 개발"],"content":" 3.4. LvePipeline에서 LveModel 사용 vertexInputInfo 채움 ","date":"2021-10-26","objectID":"/2021-10-26_vertex-buffers/:3:4","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Vertex Buffers - Vulkan Game Engine Tutorial 06' 정리","uri":"/2021-10-26_vertex-buffers/#34-lvepipeline에서-lvemodel-사용"},{"categories":["게임 개발"],"content":" 3.5. FirstApp 수정 loadModels() 추가: 여기다 vertex data 하드코딩. LveModel 인스턴스 만듬 CommandBuffer 에서 vkCmdDraw() 제거하고, lveModel의 bind(), draw() 사용 ","date":"2021-10-26","objectID":"/2021-10-26_vertex-buffers/:3:5","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Vertex Buffers - Vulkan Game Engine Tutorial 06' 정리","uri":"/2021-10-26_vertex-buffers/#35-firstapp-수정"},{"categories":["게임 개발"],"content":" 4. 다이어그램 LveWindow 생성 LveDevice 생성 LveSwapChain 생성 FirstApp() 생성자 호출 5. LveModel 생성 6. LvePipeline 생성 이후, FirstApp::run() 에서 매프레임마다 swapChain에게 녹화해둔 commandBuffer 서밋. ","date":"2021-10-26","objectID":"/2021-10-26_vertex-buffers/:4:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Vertex Buffers - Vulkan Game Engine Tutorial 06' 정리","uri":"/2021-10-26_vertex-buffers/#4-다이어그램"},{"categories":["투자 일반"],"content":"강환국님의 ‘할수있다 알고투자’ 채널이 벌써 600회를 찍었습니다!! 600회 영상에서 정리해주신 목차들의 영상 링크를 정리해 보았습니다. Ctrl 눌러서 새 탭으로 보시는 걸 추천드립니다. ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:0:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#"},{"categories":["투자 일반"],"content":" 1. 채널 목표 및 히스토리39s 초보부터 고수까지 관심을 가질만한 다양한 스펙트럼 흥미 위주 보다는 자산 증식에 초첨을 맞춤 18년 12월 31일에 1회, 21년 10월 18일 600회! 구독자 7만 8천~!! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:1:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#1-채널-목표-및-히스토리"},{"categories":["투자 일반"],"content":" 2. 가장 중요한 영상들143s ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:2:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#2-가장-중요한-영상들"},{"categories":["투자 일반"],"content":" 2.1. 강환국 은퇴, FIRE 스토리 560. 강환국 퇴사 영상! FIRE! 561. FIRE 이후 - 강환국 미래계획은? 569. 강환국 FIRE 스토리 (I) 571. 강환국 FIRE 스토리(2) - 7년만에 1억원에서 10억원까지 577. 강환국 FIRE 스토리(3) ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:2:1","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#21-강환국-은퇴-fire-스토리"},{"categories":["투자 일반"],"content":" 2.2. 투자를 왜 해야 하는가? 35. [초보] 투자는 선택이 아니라 생존이다!! (1) 36. [초보] 투자는 선택이 아니라 생존이다!! (2) ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:2:2","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#22-투자를-왜-해야-하는가"},{"categories":["투자 일반"],"content":" 2.3. 왕초보 1억 시리즈345번 시작! 초보를 위한 ‘부자 되기’ 영상 345. (왕초보) 5년만에 무에서 1억 만들기 - 돈의 노예에서 벗어나자! 348. (왕초보 1억) - 초보자 투자는 이렇게 - 영구 포트폴리오의 모든 것! 350. (왕초보 1억) - 부자 인생을 계획해보자 - 동기부여란 이런것! 351. (왕초보 1억) - 강환국이 경험한 독일 부자와 금수저들! 353. (왕초보 1억) 4계절 포트폴리오(올웨더) 초간단 설명! 354. (왕초보 1억) 당신 연금펀드가 쓰레기일 가능성 - 95%! 355. (왕초보 1억) 워렌 버핏이 1억 달러를 한국에 올인한 이유! 358. (왕초보 1억) 환율이 오르면 주식이 오르나? 359. (왕초보 1억) 수출이 증가하면 주식도 오르겠지! 363. (왕초보 1억) 재테크, 투자 입문서 10권 소개! 368. (왕초보 1억) 사회초년생, 이것만은 무조건 피하자! 372. (왕초보 1억) 1억을 모으면 다음 월급부터 다 써도 된다? 373. (왕초보 1억) 사회초년생, 이것만은 무조건 하자! 375. (왕초보 1억) 4계절 포트폴리오(올웨더) QnA 시간! 376. (왕초보 1억) 올웨더로만 책을 쓰다! - ‘절대수익 투자법칙’ 발간! 389. (왕초보 1억) 주식펀드 - 절대 하지 마세요! 391. (왕초보 1억) 월세 살면서 주식에 올인? 392. (왕초보 1억) 부자는 나쁜놈들인가? 393. (왕초보 1억) 이것만 안 하면 상위 10% 투자자! 394. (왕초보 1억) 부모님을 위한 투자상품 추천! (이루다, RPAR) 396. (왕초보 1억) 부자의 공통점 5개 399. (왕초보 1억) 상위 10%에서 상위 1% 투자자 가즈아! (Feat. 레이 달리오) 403. (왕초보 1억) 워렌 버핏의 7대 명언 404. (왕초보 1억) 어느나라에 투자해야 하나요? 405. (왕초보 1억) 무조건 성공하는 투자습관! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:2:3","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#23-왕초보-1억-시리즈"},{"categories":["투자 일반"],"content":" 2.4. 4계절 포트폴리오(올웨더) 37. [초보] 투자자 99%에 맞는 필승 투자법 - 4계절 포트폴리오 38. [초보] 투자자 99%에 맞는 필승 투자법 - 4계절 포트폴리오의 한국화 353. (왕초보 1억) 4계절 포트폴리오(올웨더) 초간단 설명! 401. 제로금리 시대 채권에 투자해도 되나요 + 신규 올웨더 전략 ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:2:4","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#24-4계절-포트폴리오올웨더"},{"categories":["투자 일반"],"content":" 2.5. 영구 포트폴리오 348. (왕초보 1억) - 초보자 투자는 이렇게 - 영구 포트폴리오의 모든 것! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:2:5","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#25-영구-포트폴리오"},{"categories":["투자 일반"],"content":" 2.7. 강환국님 현재 포트폴리오 518. 5~10월 투자전략(I) - 동적자산배분 519. 5~10월 투자전략 - 주식도 좀 할까?(Feat.강환국 수익공개) 520. 5~10월 투자전략(III) 강환국 울트라 전략 521. 나라면 이런거 사겠다 - 강환국 울트라 전략 522. 나라면 이런거 사겠다 - 동적자산배분(2021.5) 523. 나라면 이런거 사겠다 - 강환국의 5~10월 실제 포트폴리오 ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:2:6","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#27-강환국님-현재-포트폴리오"},{"categories":["투자 일반"],"content":" 2.8. 부동산 슈퍼전략 88. 벌 수 있다! 아파트로 복리 30%!! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:2:7","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#28-부동산-슈퍼전략"},{"categories":["투자 일반"],"content":" 2.9. 40세 은퇴 시리즈 278. [왕초보] 40세 은퇴, 가능한가? (1) 281. [왕초보] 40세 은퇴, 가능한가? (2) 282. [왕초보] 40세 은퇴, 가능한가? (3) 289. [왕초보] 40세 은퇴, 가능한가? (4) ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:2:8","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#29-40세-은퇴-시리즈"},{"categories":["투자 일반"],"content":" 2.10. 부의 추월차선 시리즈 297. (초보) 부자들이 모두 추천하는 그 책, 부의 추월차선 (1) 298. (초보) 부자들이 모두 추천하는 그 책, 부의 추월차선 (2) 309. 부자들이 모두 추천하는 그 책, 부의 추월차선 (3) 312. (초보) 부자들이 모두 추천하는 그 책, 부의 추월차선 (4) 315. (초보) 부자들이 가장 중요시 여기는 것은 무엇일까 - 부의 추월차선 (5) 316. 40세 은퇴 + 부의 추월차선 시리즈 결론 및 맞춤형 응용! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:2:9","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#210-부의-추월차선-시리즈"},{"categories":["투자 일반"],"content":" 2.11. 투자를 망치는 40개 편향 285. [초보] 투자를 망치는 40여개의 편향, 총정리 (1) 290. [초보] 투자를 망치는 40여개 편향 총정리 (2) 292. [초보] 투자를 망치는 40여개 편향, 총정리 (3) 299. [초보] 투자를 망치는 40여개 편향, 총정리 (4) 318. (투자심리) 강환국 폭망에서 무엇을 배울 수 있는가? ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:2:10","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#211-투자를-망치는-40개-편향"},{"categories":["투자 일반"],"content":" 3. 초보들은 이런 영상부터 먼저!234s ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:3:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#3-초보들은-이런-영상부터-먼저"},{"categories":["투자 일반"],"content":" 3.1. 정말 바쁘셔서 영상 한 개만 보신다면 539. (입문) 30분만에 투자 초보에서 고수 되기! 좀더 시간이 되시면 217. 토끼 전략 (1) - 50년간 복리 14%, MDD 16% 12. [초보] 초보도 이해할 수 있는 주식투자! 34. [초보] 투자의 진정한 빅 픽쳐 - 나에게는 어떤 투자전략이 어울리는가? 364. (초보)혼란스러운 투자의 세계, 15분만에 간단정리! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:3:1","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#31-정말-바쁘셔서-영상-한-개만-보신다면"},{"categories":["투자 일반"],"content":" 3.2. 투자를 왜 (젊을 때부터) 해야 하는가? 35. [초보] 투자는 선택이 아니라 생존이다!! (1) 36. [초보] 투자는 선택이 아니라 생존이다!! (2) 468. (투자 입문) 젊을 때 투자를 배워야 하는 3가지 이유! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:3:2","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#32-투자를-왜-젊을-때부터-해야-하는가"},{"categories":["투자 일반"],"content":" 3.3. 닥치고 1억부터 모읍시다! 돈의 노예냐 주인이냐? 345. (왕초보) 5년만에 무에서 1억 만들기 - 돈의 노예에서 벗어나자! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:3:3","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#33-닥치고-1억부터-모읍시다-돈의-노예냐-주인이냐"},{"categories":["투자 일반"],"content":" 4. FIRE 관련268s ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:4:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#4-fire-관련"},{"categories":["투자 일반"],"content":" 4.1. FIRE 마인드 343. 레이 달리오 투자, 인생 3대 원칙! 350. (왕초보 1억) - 부자 인생을 계획해보자 - 동기부여란 이런것! 351. (왕초보 1억) - 강환국이 경험한 독일 부자와 금수저들! 372. (왕초보 1억) 1억을 모으면 다음 월급부터 다 써도 된다? 373. (왕초보 1억) 사회초년생, 이것만은 무조건 하자! 391. (왕초보 1억) 월세 살면서 주식에 올인? 392. (왕초보 1억) 부자는 나쁜놈들인가? 401. 제로금리 시대 채권에 투자해도 되나요 + 신규 올웨더 전략 429. (왕초보) 자식에게 사교육을 줄래, 5 ~10억을 줄래? 431. (초보)경제의 신 리카르도에게 배우는 투자 3대 원칙! 435. (왕초보) 자식에게 사교육을 줄래, 5-10억 줄래(2) 475. (왕초보) - ‘꼬마 개미’도 밀물? 미성년자 주식투자 예찬론! 476. (왕초보) 현금 꼭 보유해야 하나, 대출 받아서 투자해도 되는가? 485. (투자입문) 안전자산이란 존재하는가? 584. 워렌 버핏이 1,000억 불 부자가 된 진짜 이유! 507. (입문) FIRE를 이룬 젊은 부자들의 공통점(1) 517. FIRE를 이룬 부자들이 말하는 직장생활 노하우! 530. FIRE 부자들은 은퇴 후 무엇을 먹고 사는가? 584. 워렌 버핏이 1,000억 불 부자가 된 진짜 이유! 593. (FIRE) 평범한 삶을 살고 싶다고? 성공하는 것이 훨씬 쉬워! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:4:1","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#41-fire-마인드"},{"categories":["투자 일반"],"content":" 4.2. 강환국의 FIRE 스토리 560. 강환국 퇴사 영상! FIRE! 561. FIRE 이후 - 강환국 미래계획은? 569. 강환국 FIRE 스토리 (I) 571. 강환국 FIRE 스토리(2) - 7년만에 1억원에서 10억원까지 577. 강환국 FIRE 스토리(3) 595. FIRE 달성 3개월 후, 삶이 어떻게 변했나 ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:4:2","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#42-강환국의-fire-스토리"},{"categories":["투자 일반"],"content":" 5. 초보 투자 좀 더 구체적으로283s ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:5:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#5-초보-투자-좀-더-구체적으로"},{"categories":["투자 일반"],"content":" 5.1. 40세까지 어떻게 경제적 자유 달성? (직장인 모드) 138. [왕초보] 얼마를 모아야 은퇴가 가능한가? 278. [왕초보] 40세 은퇴, 가능한가? (1) 281. [왕초보] 40세 은퇴, 가능한가? (2) 282. [왕초보] 40세 은퇴, 가능한가? (3) 289. [왕초보] 40세 은퇴, 가능한가? (4) 419. (왕초보) 당신의 퇴직금 계산기 - 이거 모으면 사표 낼 수 있다! 451. (왕초보) FIRE? 애, 차, 개 아웃? 조선일보 기사 부연설명! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:5:1","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#51-40세까지-어떻게-경제적-자유-달성-직장인-모드"},{"categories":["투자 일반"],"content":" 5.2. 40세까지 어떻게 경제적 자유 달성? (창업) 297. (초보) 부자들이 모두 추천하는 그 책, 부의 추월차선 (1) 298. (초보) 부자들이 모두 추천하는 그 책, 부의 추월차선 (2) 309. 부자들이 모두 추천하는 그 책, 부의 추월차선 (3) 312. (초보) 부자들이 모두 추천하는 그 책, 부의 추월차선 (4) 315. (초보) 부자들이 가장 중요시 여기는 것은 무엇일까 - 부의 추월차선 (5) 419. (왕초보) 당신의 퇴직금 계산기 - 이거 모으면 사표 낼 수 있다! 451. (왕초보) FIRE? 애, 차, 개 아웃? 조선일보 기사 부연설명! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:5:2","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#52-40세까지-어떻게-경제적-자유-달성-창업"},{"categories":["투자 일반"],"content":" 5.3. 투자 시작을 결심하셨다고요?돈 모을 때까지 기다려? 당장 시작!! (166, 197) 166. [왕초보] 주식 미신 9개 타파! 197. [초보] 강환국의 4대 투자 흑역사 공개! 돈 모으기 영상 (64) 64. [왕초보] 재테크의 기본 중 기본 - 종잣돈 모으기 ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:5:3","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#53-투자-시작을-결심하셨다고요"},{"categories":["투자 일반"],"content":" 5.4. 몫돈 있어? 남에게 맡기면 절대 안되!펀드매니저, 버핏, 신? 다 필요 없음. 당신이 해야 됨. 71. [초보] 투자, 남에게 맡기면 큰일나!! 72. [왕초보] 투자 사기의 공통점 130. [초보] 초중급자에게 위험한 버핏의 가르침 (上) 137. 기관투자자, 우량주처럼 보이는 개잡주를 산다! 157. [초보] 초중급자에게 위험한 버핏의 가르침 (下) 202. [왕초보] DLS, DLF 등 원금보장형 파생상품의 진실! 354.(왕초보 1억) 당신 연금펀드가 쓰레기일 가능성 - 95%! 289. [왕초보] 40세 은퇴, 가능한가? (4) 애널리스트, 경제학자, 국민연금 다 믿으면 안 됨. 207. 애널리스트 추천은 쓸모가 있나? 288. [초보] 애널리스트 리포트 활용은 이렇게! 341.(초보)IMF 2020년 경제전망 보고서, 개구라네요! 480. (왕초보) 국민연금, 폰지사기인가? 사기 당하면 안 됨(72, 240, 241, 512, 537) 72. [왕초보] 투자 사기의 공통점 240. [왕초보] 최신 투자사기 사례 (1) - 강환국, 주식사기꾼과 대화하다! 241. 정의의 사도 강환국, 가짜뉴스 저격! 512. (입문) 리딩방 절대 하지 마세요!! 537. 한국 상장 중국기업, 절대 사지 마세요! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:5:4","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#54-몫돈-있어-남에게-맡기면-절대-안되"},{"categories":["투자 일반"],"content":" 5.5. 40세 은퇴 시리즈 요약 316. 40세 은퇴 + 부의 추월차선 시리즈 결론 및 맞춤형 응용! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:5:5","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#55-40세-은퇴-시리즈-요약"},{"categories":["투자 일반"],"content":" 6. 초보 투자 - 그래서 어떻게 하란 말여?355s ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:6:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#6-초보-투자---그래서-어떻게-하란-말여"},{"categories":["투자 일반"],"content":" 6.1. 당장 자산 배분(영구포트폴리오/올웨더) 시작강환국은 어떻게? 447. 나라면 이런거 사겠다 - 자산배분 완성본 영구포트폴리오 348. (왕초보 1억) - 초보자 투자는 이렇게 - 영구 포트폴리오의 모든 것! 119. [초보] 초보가 알아야 하는 자산배분의 모든 것 337.폭락장 대처법 - 코로나도 피해가는 자산배분 전략 4개! 399. (왕초보 1억) 상위 10%에서 상위 1% 투자자 가즈아! (Feat. 레이 달리오) 344. 매우 게으른 자산배분 전략으로 복리 10% 달성! 477. (투자 입문) 투자는 쉽다! 무난하게 복리 8% 버는 방법! 올웨더(4계절 포트폴리오) 메인 영상 353. (왕초보 1억) 4계절 포트폴리오(올웨더) 초간단 설명! 37. [초보] 투자자 99%에 맞는 필승 투자법 - 4계절 포트폴리오 38. [초보] 투자자 99%에 맞는 필승 투자법 - 4계절 포트폴리오의 한국화 올웨더 사이드 232. [초보] 4계절 포트폴리오, 경제공황과 금리인상에도 먹히나? 283. 4계절 포트폴리오에 10억을 투자한 사나이, 수익공개! 296. (초보) 자산배분에 어떤 자산군을? 335.레이 달리오의 4계절 포트폴리오 vs. 코로나바이러스! 337.폭락장 대처법 - 코로나도 피해가는 자산배분 전략 4개! 371. 100년 동안 최대손실 11% 자산배분이 있습니다! 375. (왕초보 1억) 4계절 포트폴리오(올웨더) QnA 시간! 376. (왕초보 1억) 올웨더로만 책을 쓰다! - ‘절대수익 투자법칙’ 발간! 394. (왕초보 1억) 부모님을 위한 투자상품 추천! (이루다, RPAR) 399. (왕초보 1억) 상위 10%에서 상위 1% 투자자 가즈아! (Feat. 레이 달리오) 401. 제로금리 시대 채권에 투자해도 되나요 + 신규 올웨더 전략 472. 자산배분에 성공하기 위한 5가지 핵심 원칙! 501. 올웨더, 아직도 투자자 99%에게 최선인가? ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:6:1","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#61-당장-자산-배분영구포트폴리오올웨더-시작"},{"categories":["투자 일반"],"content":" 6.2. 일단 지른 후 공부를 위한 책/유튜브책/논문 302. [왕초보] 주식 입문자 가이드! 363. (왕초보 1억) 재테크, 투자 입문서 10권 소개! 367. 강환국 인생 최고 주식책 7권! 529. (입문) 투자 공부는 어떻게 하나요? 550. (고급) 투자 공부는 이렇게 한다! 587. 당장 실전에서 써먹을 수 있는 투자 책 11권! 유튜브 186. [초보] 진짜 돈이 벌리는 유튜브 채널 소개! 211. (초보) 유익한 유튜브 주식채널들 10개 소개! 213. (초보) 역대급 주식 전설들의 유튜브 채널들 10개 소개! 227. [초보] 유익한 유튜브 주식채널 10개 추가요! 302. [왕초보] 주식 입문자 가이드! 공부 안하는 자들의 비참한 말로 379. (전국민 필수영상) 전업투자! 이렇게는 하지 맙시다(1) 380. (전국민 필수영상) 전업투자! 이렇게는 하지 맙시다(II) ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:6:2","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#62-일단-지른-후-공부를-위한-책유튜브"},{"categories":["투자 일반"],"content":" 6.3. 초보 멘토링 (배주이씨) 229. [초보] 원숭이 계몽 프로젝트! - 자산배분 230. 배주의 씨의 투자전략 소개! 249. (초보) 그녀가 돌아왔다! 새로운 동적자산배분 탄생 - 리스크패리티+ 11~4월전략! 252. (초보) 투자 때문에 피눈물을 흘린 사람이 있다!? 261. 동적자산배분의 끝판왕? 262 . (초보) 시장의 마법사 끝장토론! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:6:3","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#63-초보-멘토링-배주이씨"},{"categories":["투자 일반"],"content":" 7. 초보 투자 - 투자 심리427s ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:7:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#7-초보-투자---투자-심리"},{"categories":["투자 일반"],"content":" 7.1. 투자 편항 40여개 총 집합! 285. [초보] 투자를 망치는 40여개의 편향, 총정리 (1) 290. [초보] 투자를 망치는 40여개 편향 총정리 (2) 292. [초보] 투자를 망치는 40여개 편향, 총정리 (3) 299. [초보] 투자를 망치는 40여개 편향, 총정리 (4) ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:7:1","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#71-투자-편항-40여개-총-집합"},{"categories":["투자 일반"],"content":" 7.2. 왜 대부분 투자자는 망할 수 밖에 없는지 30. [초보] 왜 당신이 주식을 하면 맨날 깨지는지 (1) - 손실회피 \u0026 처분효과 편향 31. [초보] 왜 당신이 주식을 하면 맨날 깨지는지 (2) - 과잉확신 편향 편 58. [초보] 정석적인 투자, 왜 이리 어려울까? 162. 투자가 심리적으로 어려운 이유 - 절대모멘텀 사례 190. 구독자 10,000명 기념! 투자 10계명 대공개! 191. 내가 100만불 잃으면서 배운 것! (上) 514. 우리 투자를 망치는 편향, 1~5위! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:7:2","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#72-왜-대부분-투자자는-망할-수-밖에-없는지"},{"categories":["투자 일반"],"content":" 7.3. 우리 두뇌/심리를 극복하는 방법! 63. [초보] 주식시장에서 무조건 이기는 방법 74. [초보] 성공투자? 3가지만 잘하면 된다! 76. [초보] 성공투자? 한 개만 버리면 된다! 132. [초보] 성공투자 - 과학이 아닌 종교의 영역 109. 마법의 연금 굴리기, 김성일 작가님 질문답변 192. 내가 100만불 잃으면서 배운 것! (下) 263. [왕초보] 투자는 왜 드럽게 어려운가? 405. (왕초보 1억) 무조건 성공하는 투자습관! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:7:3","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#73-우리-두뇌심리를-극복하는-방법"},{"categories":["투자 일반"],"content":" 7.4. 심리 + 백테스트 = 성공투자! 46. [초보] 주식투자 10계명 ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:7:4","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#74-심리--백테스트--성공투자"},{"categories":["투자 일반"],"content":" 7.5. 버블이란 무엇? 215. (초보) 지금이 버블인지 아닌지 어떻게 파악하나? ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:7:5","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#75-버블이란-무엇"},{"categories":["투자 일반"],"content":" 7.6. 백테스트 하는 방법 47. [초보] 백테스트 매뉴얼 (1) - 자산배분 51. [초보] 백테스트 매뉴얼 (2) - 마켓타이밍 편 75. 개별주식 전략 백테스트 정복 92. [초보] 투자전략 백테스트, 환상과 현실 128. [초보] 백테스트와 리밸런싱, 이렇게 하는 겁니다! 131. [중요] 직접 백테스트를 해야 합니다!! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:7:6","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#76-백테스트-하는-방법"},{"categories":["투자 일반"],"content":" 7.7. 투자심리 유형 파악 422. (왕초보) 테슬라, 카카오 사기 전 이 심리테스트 먼저! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:7:7","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#77-투자심리-유형-파악"},{"categories":["투자 일반"],"content":" 8. 초보 딱지를 벗으려면 - 투자 상식508s ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:8:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#8-초보-딱지를-벗으려면---투자-상식"},{"categories":["투자 일반"],"content":" 8.1. 왜 초보자에게 계량 투자를 강추하는 것인가? 13. [초보] 왜 계량투자인가? OR 단순공식이 전문가에게 이기는 원인 44. [초보] 워렌 버핏이 어쩔 수 없이 가치투자자가 된 이유 + 버핏의 한국 투자기행 ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:8:1","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#81-왜-초보자에게-계량-투자를-강추하는-것인가"},{"categories":["투자 일반"],"content":" 8.2. 분산 투자, 자산 배분에 대한 이해 33. [초보] 마코비츠, 12페이지 논문으로 노벨상 받다 91. [초보] 주식투자 전략만 연구하면 안 되는 이유! 111. [초보] 주식 vs 예금, 수익이 더 높은 투자는? 143. 개별주 포트폴리오에 종목 몇 개? 147. [왕초보] 주식은 무엇이고, 채권은 무엇이냐? - 자금조달의 3,000년 역사 296. (초보) 자산배분에 어떤 자산군을? 387. 장기투자 수익률 어느 자산이 더 높나 - 주식 vs.채권 393. (왕초보 1억) 이것만 안 하면 상위 10% 투자자! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:8:2","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#82-분산-투자-자산-배분에-대한-이해"},{"categories":["투자 일반"],"content":" 8.3. 요즘 한국(중국)보다 미국 시장이 더 낫다는데? 134. [초보] 미국 주식은 좋고, 한국 주식은 구린가? 209. (초보) 레이 달리오 - 미국이냐, 중국이냐? 그게 문제로다! 221. 국제 장기투자는 선진국인가? 개발도상국인가? 226. [초보] Meb Faber - 미국 주식 터무니없이 비싸다! 228. [초보] 그래도 미국 주식이 한국 주식보다 낫다? 589. 나스닥이나 S\u0026P 500에 적립식 투자 - 도대체 왜? ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:8:3","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#83-요즘-한국중국보다-미국-시장이-더-낫다는데"},{"categories":["투자 일반"],"content":" 8.4. 그래도 죽어도 개별주/잡주에 투자하고 싶다면 216. [초보] 개별주 투자 필승법 (Feat. Peter Lynch and the Turtles) 235. [왕초보] 당신이 잡주를 사고도 살아남는 방법! 407. 테슬라 주식, 지금 사도 돼? ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:8:4","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#84-그래도-죽어도-개별주잡주에-투자하고-싶다면"},{"categories":["투자 일반"],"content":" 8.5. 투자 전략 필수사항 330. (초보필독) 할투 채널 주의사항 안내! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:8:5","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#85-투자-전략-필수사항"},{"categories":["투자 일반"],"content":" 8.6. 투자의 정석 340.주식의 정석 - 30년 데이터로 입증! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:8:6","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#86-투자의-정석"},{"categories":["투자 일반"],"content":" 8.7. 목표 수익률 596. 강환국 목표 수익률은 얼마일까 557s ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:8:7","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#87-목표-수익률"},{"categories":["투자 일반"],"content":" 8.8. 연금? DB? DC? 그런 거 뭐여? 108. 책 ‘마법의 연금 굴리기’ 독후감 109. 마법의 연금 굴리기, 김성일 작가님 질문답변 174. [왕초보] 직장인 필수정보 - 퇴직금? DB, DC가 뭐죠? ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:8:8","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#88-연금-db-dc-그런-거-뭐여"},{"categories":["투자 일반"],"content":" 8.9. 버블은 어떻게 알아채? 215. (초보) 지금이 버블인지 아닌지 어떻게 파악하나? 453. KOSPI 5,000 전에는 버블을 논하지 말라! 467. (왕초보) KOSPI 너무 많이 올랐나, 인버스 곱버스 사야 하나? ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:8:9","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#89-버블은-어떻게-알아채"},{"categories":["투자 일반"],"content":" 8.10. 투자와 투기의 차이는? 231. [초보] 투자, 투기, 도박의 차이는 무엇? 498. (투자 입문) 투자, 투기, 도박의 차이는? ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:8:10","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#810-투자와-투기의-차이는"},{"categories":["투자 일반"],"content":" 8.11. 나는 회계 아무것도 모르는데! 29. [초보] 회계의 기초 478. (투자 입문) 주식투자자를 위한 회계지식! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:8:11","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#811-나는-회계-아무것도-모르는데"},{"categories":["투자 일반"],"content":" 8.12. 리밸런싱은 뭐야? 381. 포트폴리오 리밸런싱은 어느 날에 할까요? ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:8:12","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#812-리밸런싱은-뭐야"},{"categories":["투자 일반"],"content":" 8.13. 싼 주식, 비싼 주식 549. (입문) 싼 주식과 비싼 주식을 어떻게 구분해? ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:8:13","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#813-싼-주식-비싼-주식"},{"categories":["투자 일반"],"content":" 8.14. 개별주냐, ETF냐? 588. (왕초보) 개별종목을 살까, ETF를 살까! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:8:14","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#814-개별주냐-etf냐"},{"categories":["투자 일반"],"content":" 9. 중고급 투자 전략 스터디 전 준비607s ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:9:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#9-중고급-투자-전략-스터디-전-준비"},{"categories":["투자 일반"],"content":" 9.1. 퀀트 전략 관련 주의사항 전달 330. (초보필독) 할투 채널 주의사항 안내! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:9:1","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#91-퀀트-전략-관련-주의사항-전달"},{"categories":["투자 일반"],"content":" 9.2. 주식의 정석, 30년 데이터로 입증 340.주식의 정석 - 30년 데이터로 입증! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:9:2","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#92-주식의-정석-30년-데이터로-입증"},{"categories":["투자 일반"],"content":" 9.3. 과거에 먹혔던 전략 미래에도 먹힐까? 506. 퀀트의 신이 말하는 2020년대 최고 투자논문! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:9:3","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#93-과거에-먹혔던-전략-미래에도-먹힐까"},{"categories":["투자 일반"],"content":" 10. 모멘텀 전략가격 데이터만 사용하는 가장 퓨어하고 간단한 전략 647s ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:10:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#10-모멘텀-전략"},{"categories":["투자 일반"],"content":" 10.1. 상대 모멘텀 8. 모멘텀의 오묘한 세계 (1) - 상대모멘텀 9. 모멘텀의 오묘한 세계 (2) - 1990~2018년 라이브 백테스트 14. 모멘텀의 오묘한 세계 (3) - JT, 20년만에 화려하게 컴백하다 39. 217년 데이터 분석, 시장에서 이기는 방법은 영원하리! 99. 모멘텀의 오묘한 세계 (13) - 최근 한 달이 중요! 184. 비밀논문 - 한국에서 2000년에 무슨 일이 있었나? 270. [초보] 미국 ETF로 돈 버는 초간단 방법 소개! 408. 최근 한달 동안 급등한 ETF, 살까 말까? 535. 한국에서 모멘텀 투자를 살려볼까? 전략 모멘텀 49. 모멘텀의 오묘한 세계 (9) - 투자 전략에도 모멘텀이 통한다! 585. 합성 전략이란 이런 것 - 복리 20% 동적자산배분 탄생! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:10:1","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#101-상대-모멘텀"},{"categories":["투자 일반"],"content":" 10.2. 절대 모멘텀 17. 모멘텀의 오묘한 세계 (4) - 절대모멘텀 18. 모멘텀의 오묘한 세계 (5) - 절대모멘텀 라이브 백테스트 43. 상승장과 하락장을 구분하는 비법!! - 평균 모멘텀 스코어 99. 모멘텀의 오묘한 세계 (13) - 최근 한 달이 중요! 162. 투자가 심리적으로 어려운 이유 - 절대모멘텀 사례 217. 토끼 전략 (1) - 50년간 복리 14%, MDD 16% 397. 최고의 방어벽 절대모멘텀, 또 한번 업그레이드! 52주 신고가/최고가 183. 52주 최고가에 근접한 주식을 사라고? 217. 토끼 전략 (1) - 50년간 복리 14%, MDD 16% 266. [왕초보] 복리 11%, 최대손실 11% 초간단 전략! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:10:2","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#102-절대-모멘텀"},{"categories":["투자 일반"],"content":" 10.3. 듀얼 모멘텀 21. 모멘텀의 오묘한 세계 (6) - GTAA (자산배분 + 절대모멘텀) 22. 모멘텀의 오묘한 세계 (7) - 듀얼모멘텀 23. 모멘텀의 오묘한 세계 (8) - 듀얼모멘텀 백테스트 39. 217년 데이터 분석, 시장에서 이기는 방법은 영원하리! 96. 회사채 수익을 높이는 방법은? 210. 미·중 듀얼모멘텀으로 복리 15% (백테스트 포함) 287. 2만명 기념 복리 20% 전략 투척! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:10:3","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#103-듀얼-모멘텀"},{"categories":["투자 일반"],"content":" 10.4. 듀얼 모멘텀 업그레이드 97. 최근 20년간 복리 20% 벌고 최대손실 20% 나온 전략 대공개! 125. 듀얼모멘텀 전략의 업그레이드 (1-1) 126. 듀얼모멘텀 전략의 업그레이드 (1-2) - FAA 전략 활용법 136. 듀얼모멘텀 전략의 업그레이드 (2) - PAA 전략 142. 듀얼모멘텀 전략의 업그레이드 (3) - MPAA 전략 148. 듀얼모멘텀 전략의 업그레이드 (4) - 종합 듀얼모멘텀 293.(고급) 복리 15% 전략, 15분만에 완전 정복! 374. 최강전략 VAA - 50년만에 원금 3,800배! 377. DAA 전략, 복리 22%, MDD 13%가 실화인가! 409. 부지런하면 복리 15%, 최대손실 10% 전략도 가능! 469. 올웨더에 마켓타이밍 - 켈러의 RAA 전략! 525. 동적자산배분, 복리 13% MDD 7% 가능? 590. KOSPI에서 글로벌 시장에 미래가 보인다! 정적 + 동적자산배분 콤보 409. 부지런하면 복리 15%, 최대손실 10% 전략도 가능! 501. 올웨더, 아직도 투자자 99%에게 최선인가? ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:10:4","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#104-듀얼-모멘텀-업그레이드"},{"categories":["투자 일반"],"content":" 10.5. 변동성 돌파 전략 53. 역대 최강의 트레이더의 가장 위대한 전략 - 변동성 돌파전략 60. 암호화폐 - 사기인가 미래의 금인가 61. 암호화폐에 부동산보다 더 안전하게 투자한다고!? 131. [중요] 직접 백테스트를 해야 합니다!! 694s ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:10:5","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#105-변동성-돌파-전략"},{"categories":["투자 일반"],"content":" 10.6. 단기 역추세 68. 최근 1주일 폭망한 주식을 사보자 169. 최근 상한가 친 주식 사면 폭망! 208. IBS - 전세계에서 매년 돈을 버는 단타전략이 있다고? 233. 터틀 vs 터틀스프 - 정반대 전략으로 돈을 번다고? 319. 코로나19 감염자, 500만명이 넘었나! 320. 코로나 대하락장에도 수익을 내는 단기전략 (1) 437. 11 4월 모멘텀, 역추세 전략 완성본 - 복리 20% 고고! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:10:6","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#106-단기-역추세"},{"categories":["투자 일반"],"content":" 10.7. 장기 역추세 85. 모멘텀의 오묘한 세계 (10) - 중기 윈너, 장기 루저 주식, 시너지 대박 ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:10:7","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#107-장기-역추세"},{"categories":["투자 일반"],"content":" 10.8. 대하락 후 역추세 90. 모멘텀의 오묘한 세계 (11) - 대하락장 직후는 안 먹혀! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:10:8","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#108-대하락-후-역추세"},{"categories":["투자 일반"],"content":" 10.9. 모멘텀 콤보 전략 85. 모멘텀의 오묘한 세계 (10) - 중기 윈너, 장기 루저 주식, 시너지 대박 95. 모멘텀의 오묘한 세계 (12) - 트윈모멘텀 ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:10:9","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#109-모멘텀-콤보-전략"},{"categories":["투자 일반"],"content":" 10.10. 단기 트레이딩 495. 실전 단기 트레이딩 전략 노하우! 563. S\u0026P 500에서 승률 91% 단기전략이 있다고?(낚시아님) ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:10:10","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#1010-단기-트레이딩"},{"categories":["투자 일반"],"content":" 10.11. 모멘텀 전략이 통하는 이유 204. [초보] 그것이 알고싶다 - 최근 오른 자산이 왜 계속 오르는가? ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:10:11","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#1011-모멘텀-전략이-통하는-이유"},{"categories":["투자 일반"],"content":" 10.12. 개별주/ETF MDD 관리 505. 개별종목 전략에서 MDD 줄이는 방법! 531. (단타) 상승장, 하락장을 구분하는 최고의 방법! 554. 내가 투자하는 전략의 MDD가 엄청 커지면? 583. PER 지표 하나로 복리수익 30%, MDD 10%(II) ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:10:12","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#1012-개별주etf-mdd-관리"},{"categories":["투자 일반"],"content":" 11. 가치주 전략 - 저평가된 주식 찾기!759s ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:11:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#11-가치주-전략---저평가된-주식-찾기"},{"categories":["투자 일반"],"content":" 11.1. 대하락 후 싹쓸이 전략 323. 3만명 기념 - 폭락장 후 싹쓸이 전략! 324. 대폭락 후 싹쓸이 전략 업그레이드 (1) Delay 326. 대폭락 후 싹쓸이 전략 업그레이드 (2) - MDD Delay 327. 대폭락 후 싹쓸이 전략 업그레이드(3) - 코스닥 329. 대폭락 후 싹쓸이 전략 업그레이드(4) - 미국시장편 331. 폭락장 후 싹쓸이 전략 업그레이드(5) - 중국, 일본, 원유시장 332. 폭락장 후 싹쓸이 전략 업그레이드(6) - 2008년 개별주 333. 폭락장 후 싹쓸이 전략 업그레이드! (7) - 2000, 03년 개별주 334.할투 최고 영상 - 폭락장 후 한국 대형주 싹쓸이! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:11:1","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#111-대하락-후-싹쓸이-전략"},{"categories":["투자 일반"],"content":" 11.2. 대상승 후는 어떻게? 470. 코스피 100% 상승! 다음 행마는? 40번의 사례 분석! 471. 응답하라 1998! 2021년과 가장 비슷한 상승장 분석! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:11:2","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#112-대상승-후는-어떻게"},{"categories":["투자 일반"],"content":" 11.3. 우량주 + 가치주 전략들버핏, 타이거 우량가치, 마법공식 + 아류, 서준식, 상속세, 파마 전략 등 2. 버핏의 계량화 (1) 3. 버핏의 계량화 (2) - 우량주란 무엇인가 4. 버핏의 계량화 (3) - 소형주/저 PBR 효과 또는 계량투자계에서 가장 중요한 논문! 7. 실전타임 : 한국시장에서 버핏류 주식을 찾아보자 52. 한국 최고 스마트베타 ETF, ‘타이거 우량가치’ 업그레이드 79. [초보] 그린블라트의 마법공식, 실화냐 신화냐? 156. 서준식의 버핏형 채권형 주식 발굴법 223. [초보] 워렌 버핏의 연 50% 수익 비법 공개 370. 세계 최강 퀀트투자 오타쿠가 만든 복리 20% 전략! 438. 소형주의 마법, 복리 40%도 나오네! 439. 신 강환국 슈퍼가치전략, 복리 50% 가능? 442. (5만명 기념) 복리 50% 전략 또 하나 풀어야죠! 487. 상속세법 보고 만든 복리 48% 투자전략!! 490. 상속세법 보고 만든 복리 48% 투자전략 후속편! 532. 파마의 최종병기 전략, 복리 30%가 넘네? 542. 단순 가치투자로 복리 30% 이상이 벌리는 이유 543. 가치투자를 하려면 최고에게 배우라 1(Feat Bill Ackman) 544. 가치투자를 하려면 최고에게 배우라 2 (Feat. Bill Ackman) 546. 새로운 마법공식, 전세계에서 먹힌다! 551. 분기 가치 지표로 복리 50% 벌 수 있다고? ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:11:3","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#113-우량주--가치주-전략들"},{"categories":["투자 일반"],"content":" 11.4. 우량주 + 가치주 + 모멘텀 전략들AQR, Robeco, 울트라 전략 등 10. 저평가 우량주 모멘텀 주식에 투자한다면? 11. 저평가 우량주 모멘텀주 발굴 실습! 116. 매우 심플한 복리 15% 대형주 전략 118. 매우 심플한 복리 15% 대형주 전략 종목 찾기 187. [초보] 복리 15% 이상 버는 한국 밸류 모멘텀 초간단 전략 종목 뽑기 504. 한국형 밸류 모멘텀 전략 개발! 520. 5~10월 투자전략(III) 강환국 울트라 전략 521. 나라면 이런거 사겠다 - 강환국 울트라 전략 572. 퀀트킹 새로운 지표 추가, 울트라 전략 재분석! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:11:4","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#114-우량주--가치주--모멘텀-전략들"},{"categories":["투자 일반"],"content":" 11.5. 배당주 전략 237. [초보] 고배당주로 복리 15-20% 달성 가능하단다! 458. 연말 배당주 투자 콜? 복리 20% 가능? ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:11:5","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#115-배당주-전략"},{"categories":["투자 일반"],"content":" 11.6. 가치 팩터PBR 4. 버핏의 계량화 (3) - 소형주/저 PBR 효과 또는 계량투자계에서 가장 중요한 논문! 5. 라이브 백테스트! 소형주/저 PBR 투자전략 아직도 먹히나? 362. (고급) 복리 20% 저 PER 저 PBR 전략이 죽었나! (Feat. Cliff Asness from AQR) NCAV 20. 나라면 이런 거 사겠다 (1) - NCAV 54. 나라면 이런 거 사겠다 (5) - NCAV 전략 EV 388. 당신을 깜짝 놀라게 할 연 50% 전략 - Negative EV ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:11:6","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#116-가치-팩터"},{"categories":["투자 일반"],"content":" 12. 우량주 투자845s ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:12:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#12-우량주-투자"},{"categories":["투자 일반"],"content":" 12.1. 버핏 2. 버핏의 계량화 (1) 3. 버핏의 계량화 (2) - 우량주란 무엇인가 ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:12:1","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#121-버핏"},{"categories":["투자 일반"],"content":" 12.2. 피오트로스티 F-Score 24. 우량주란 무엇인가 (2) - F Score 25. 우량주란 무엇인가 (3) - F Score, 미국 외 시장에서도 먹히는가 ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:12:2","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#122-피오트로스티-f-score"},{"categories":["투자 일반"],"content":" 12.3. 노비 마르크스 GP/A 27. 우량주란 무엇인가 (4) - GP/A ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:12:3","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#123-노비-마르크스-gpa"},{"categories":["투자 일반"],"content":" 12.4. 우량주 전략 배틀 28. 우량주란 무엇인가 (5) - 7개 우량주 전략 배틀 73. 매출, 영업이익, 배당의 주식투자 활용법 146. 우량주란 무엇인가? ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:12:4","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#124-우량주-전략-배틀"},{"categories":["투자 일반"],"content":" 12.5. 자산 성장률 259. 자산성장과 주식수익률을 파헤쳐보자! (1) ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:12:5","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#125-자산-성장률"},{"categories":["투자 일반"],"content":" 12.6. 강환국 슈퍼 퀄리티 503. 강환국 슈퍼 퀄리티전략 업그레이드! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:12:6","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#126-강환국-슈퍼-퀄리티"},{"categories":["투자 일반"],"content":" 13. 소형주, 계절성872s ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:13:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#13-소형주-계절성"},{"categories":["투자 일반"],"content":" 13.1. 11-4월 투자 전략 40. 전세계에서 통하는 만능 전략 - 11월 초 매수, 4월 말 매도 110. [초보] 주식 투자는 역시 11월~4월이 적정기! 117. 11월~4월에 투자해서 복리 20% 이상! 122. [초보] 5월~10월, 주식을 안하면 어디에 투자해? 163. 자산배분에 11월~4월 전략을 섞으면? 179. 진정한 강철멘탈만 버틸 수 있는 복리 15% 전략! 193. [초보] 주가 폭락, 11월에 다시 들어가 말아? 269. 주식, 11월-4월보다 더 좋은 타이밍이 있다고? (2) 434. 주식을 사야 할 11 4월이 왔습니다! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:13:1","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#131-11-4월-투자-전략"},{"categories":["투자 일반"],"content":" 13.2. 오버나잇, 월말월초, 1월, 기타 48. 세상에서 가장 시니컬한 전략! 종가 매수, 시가 매도 (라이브 백테스트) 55. 한달에 나흘만 투자하면 된다고?? 56. 정말 한달에 4일만 투자하면 되는가?? 104. 당장 다음 달 급등할 주식을 찾는 기적의 한수! 113. 개잡주에 투자해서 돈 좀 법시다 115. 소형주 + 1월 = 고수익? 275. (초보) 2020-2100년 투자 대예언! 277. [초보] 1월 효과를 노려 봅시다! 365. 단타비법 천기누설!(낚시 아님) 378. 미국 선물투자 필승법! 382. 믿기지 않는 월말월초 전략! 한달 수익을 10일만에 벌다! 414. 주식시장의 재앙, 10월이 온다! 450. (왕초보) 따뜻한 크리스마스는 주식과 함께! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:13:2","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#132-오버나잇-월말월초-1월-기타"},{"categories":["투자 일반"],"content":" 13.3. 5월~10월은 어떻게 122. [초보] 5월~10월, 주식을 안하면 어디에 투자해? 548. 5~10월 지옥 피할 수 있다! (미국 대형주 복리 15% 전략) ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:13:3","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#133-5월10월은-어떻게"},{"categories":["투자 일반"],"content":" 13.4. 소형가치 + 우량주 콤보 438. 소형주의 마법, 복리 40%도 나오네! 439. 신 강환국 슈퍼가치전략, 복리 50% 가능? 449. 소형주의 비밀 - 대형주보다 복리 20%를 더 번다고! 461. 나라면 이런거 사겠다 배당주, 소형주(복리 60%!) 전략 종목 공개! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:13:4","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#134-소형가치--우량주-콤보"},{"categories":["투자 일반"],"content":" 13.5. 유동성 문제 441. 복리 50% 전략, 실전에서 사용 가능? ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:13:5","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#135-유동성-문제"},{"categories":["투자 일반"],"content":" 14. 기타 전략들919s ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:14:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#14-기타-전략들"},{"categories":["투자 일반"],"content":" 14.1. 변동성 투자전략전 세계에서 잘 먹힘 42. 리스크가 낮은 주식이 수익이 더 높다!? 89. 해외투자, 이 3가지만 알고 시작하자! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:14:1","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#141-변동성-투자전략"},{"categories":["투자 일반"],"content":" 14.2. 내부자 거래 70. 내부자 거래의 비밀 (Feat. 피터 린치) 258. (감동) 퀀트+ 내부자 = 거래 돈을 부르는 공식! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:14:2","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#142-내부자-거래"},{"categories":["투자 일반"],"content":" 14.3. 슈퍼 투자자 따라하기, 대하락장 방어법 305. [초보] 거인의 힘을 빌리는 미국주식 전략! 180. 대하락장에서 나 혼자 버는 방법, 대공개! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:14:3","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#143-슈퍼-투자자-따라하기-대하락장-방어법"},{"categories":["투자 일반"],"content":" 14.4. 공모주. 증자/자사주 매입/액면 분할 등 421. 빅히트 공모주 청약? 공모주 투자 노하우+ 연30% 전략! 574. 지수 진입, 무상증자, 자사주 매입, 액면분할이 미치는 영향은? ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:14:4","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#144-공모주-증자자사주-매입액면-분할-등"},{"categories":["투자 일반"],"content":" 14.5. AI ETF, ESG 488. 한국 AI ETF가 미국 대형주에서 초과수익을? 547. ESG 투자, 돈이 되나? ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:14:5","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#145-ai-etf-esg"},{"categories":["투자 일반"],"content":" 14.6. 휴먼 인디케이터. 수급 558. 휴먼 인디케이터 - 최고점, 최저점 타이밍은 가능하다! 591. 청와대 따라해서 복리 30% 버는 비법 576. (상식타파) 수급의 비밀 - 이렇게도 복리 20% 이상이 가능? ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:14:6","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#146-휴먼-인디케이터-수급"},{"categories":["투자 일반"],"content":" 14.7. 거래량, 변동성, R\u0026D, 홍보 팩터 등 597. (반전주의!) 한국 주식시장에서 먹히는 대형주 팩터들- 148개 팩터 분석! 598. 한국 주식시장에서 먹히는 소형주 팩터들 - 148개 팩터 분석!(1) 599. 한국 주식 시장에서 먹히는 소형주 팩터들 - 148개 팩터 분석(2) ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:14:7","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#147-거래량-변동성-rd-홍보-팩터-등"},{"categories":["투자 일반"],"content":" 15. 경제와 주식의 상관 관계966s ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:15:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#15-경제와-주식의-상관-관계"},{"categories":["투자 일반"],"content":" 15.1. 레이 달리오, 켄 피셔 등 구루 분석 103. [초보] 경제성장이 높은 국가에 투자하면 폭망한다!! 172. [초보] 연준이 금리를 내리면 주식시장은? 175. 레이 달리오, 2020~2029년 투자 대예언! (上) 176. 레이 달리오, 2020~2029년 투자 대예언! (下) 178. 한국시장 일드커브 전략 189. [초보] 초간단 매크로 전략으로 부자 되자! (上) 198. [초보] 초간단 매크로 전략! (下) - 한국에서 통하는가? 201. OECD 선행지수로 한국에서 초과수익! 212. (초보) 대한민국 최강 마켓타이머들은 - 청와대에 계신다! 301. 금융위기 예측은 가능하다! (Feat. 레이 달리오) 322. [초보] 레이 달리오의 경제이론, 현실세계에 응용! 352. 레이 달리오 - 통화 붕괴, 혁명, 전쟁의 시대가 온다고? 411. 레이 달리오가 보는 중국의 과거 416. 레이 달리오가 말하는 미중 전쟁 + 우리의 투자전략 491. 레이 달리오, 포스트 코로나 시대 대예언 + 주식 추천! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:15:1","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#151-레이-달리오-켄-피셔-등-구루-분석"},{"categories":["투자 일반"],"content":" 15.2. 경제지표와 주식 수익의 상관관계 314. [초보] 경제와 주식시장, 너희들의 관계는? (1) 346.금리 타이밍으로 코스피 +7% 달성! 349. (경제와 주식) 유가와 물가지표는 투자에 도움이 되나? 357. (왕초보) 경제는 위기인데 주식은 왜 올라? 358. (왕초보 1억) 환율이 오르면 주식이 오르나? 359. (왕초보 1억) 수출이 증가하면 주식도 오르겠지! 361. 경제지표 마켓타이밍으로 복리 10% 이상 벌기! 538. 인플레이션이 오면 어떻게 투자해야 해? ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:15:2","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#152-경제지표와-주식-수익의-상관관계"},{"categories":["투자 일반"],"content":" 15.3. 투자 전망 보실래요?진지하게 보시면 안됨 273. 이 세상 모든 자산의 2020-24년 기대수익 공개! 275. (초보) 2020-2100년 투자 대예언! 280. [왕초보] 2020년 주식시장 강환국 대예언! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:15:3","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#153-투자-전망-보실래요"},{"categories":["투자 일반"],"content":" 15.4. 전쟁 나면 주식은? 284. 전쟁, 주식시장에 어떤 영향을? 286. 전쟁이 나면 빛을 보는 2개 자산 소개! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:15:4","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#154-전쟁-나면-주식은"},{"categories":["투자 일반"],"content":" 15.5. 어떤 나라에 투자?참고로 미국이 아님 404. (왕초보 1억) 어느나라에 투자해야 하나요? 412. 어느 나라 투자하면 떼돈을 버나 - 200개 논문 총정리 완성본 415. 정치가 개판인 나라, 주식시장 수익률은? ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:15:5","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#155-어떤-나라에-투자"},{"categories":["투자 일반"],"content":" 16. 다른 자신군도 알아야 함985s ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:16:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#16-다른-자신군도-알아야-함"},{"categories":["투자 일반"],"content":" 16.1. 세계 최초! 부동산 계량투자!상대 모멘텀 (최근 3개월 오른 부동산 굿). 전세율 갭투자 81. 부동산도 퀀트투자로 (1-1) - 상대모멘텀 82. 부동산도 퀀트투자로 (1-2) - 전세 낀 상대모멘텀 84. 부동산도 퀀트투자로 (2) - 갭투자 부동산 마법공식1.0 88. 벌 수 있다! 아파트로 복리 30%!! 주식이냐 부동산이냐? 151. [초보] 부동산 vs 주식, 어떤게 나은가? 152. 부동산 수익이 주식 수익보다 높다는 것은 있을 수 없다고? 서울이냐 지방이냐? 336.(충격) 한국 아파트의 진실 - 서울 vs. 지방아파트 배틀의 승자는! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:16:1","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#161-세계-최초-부동산-계량투자"},{"categories":["투자 일반"],"content":" 16.2. 암호화폐 - 변동성 돌파 전략, 벡테스트 등 60. 암호화폐 - 사기인가 미래의 금인가 61. 암호화폐에 부동산보다 더 안전하게 투자한다고!? 127. 김동주 퀀트팀장, 헤이비트의 투자전략 공개! 131. [중요] 직접 백테스트를 해야 합니다!! 161. 암호화폐에 펀더멘털 투자가 가능하다고? 165. 주식전략 20개, 암호화폐 시장에서 돌려보다! 342. 강환국 가상화폐 전략, 18~19년 하락장에 먹혔나! 465. 비트코인 3천만 원 기념 영상 완성본! 473. 10년에 2만 배 번다는 비트코인 전략? 죄송합니다, 5.8만 배였네요 482. 레이 달리오가 말하는 비트코인! 511. 암호화폐 차익거래(재정거래)란 무엇? 533. (충격) 가상화폐 폭락 이유 대공개! 565. (홍보) 디지털 자산 예치상품으로 연 9% 고정수입!? ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:16:2","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#162-암호화폐---변동성-돌파-전략-벡테스트-등"},{"categories":["투자 일반"],"content":" 16.3. 채권 97. 최근 20년간 복리 20% 벌고 최대손실 20% 나온 전략 대공개! 159. [초보] 주식쟁이 강환국의 채권 탐험 214. 금리가 이렇게 낮은데 채권에 투자해도 되나? 222. [초보] 미국 채권, 궁금한 거 다 알려줄게! 245. [초보] 35조 달러 규모 글로벌 채권 버블이 터지면? 410. 제로금리 시대에 채권투자 해도 되나(2) 510. (입문) 내 인생에서 가장 고마운 책 - 부자 아빠, 가난한 아빠 ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:16:3","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#163-채권"},{"categories":["투자 일반"],"content":" 16.4. 금 383. 금과 은을 살 타이밍이 왔나? 395. 레이 달리오, 워렌버핏이 금을 사는 이유? 417. 주식-금 8년 사이클이 존재한다고? ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:16:4","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#164-금"},{"categories":["투자 일반"],"content":" 16.5. 취미자산 (레고, 위스키) 243. [초보] 레고 수익이 주식보다 높다고?? 248. [초보] 최근 11년간 복리 22%의 수익을 낸 자산군이 있다고? ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:16:5","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#165-취미자산-레고-위스키"},{"categories":["투자 일반"],"content":" 17. 백테스트는 퀀트투자의 핵심! 1 ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:17:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#17-백테스트는-퀀트투자의-핵심-1"},{"categories":["투자 일반"],"content":" 17.1. 뉴지스탁 소개21세기의 첨단 종목 백테스트 75. 개별주식 전략 백테스트 정복 ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:17:1","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#171-뉴지스탁-소개"},{"categories":["투자 일반"],"content":" 17.2. 퀀트킹 백테스트 소개40초면 백테스트 한 개 433 퀀트킹, 백테스트 기능 탑재! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:17:2","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#172-퀀트킹-백테스트-소개"},{"categories":["투자 일반"],"content":" 17.3. 모멘텀상대모멘텀, 절대모멘텀, 듀얼모멘텀 9. 모멘텀의 오묘한 세계 (2) - 1990~2018년 라이브 백테스트 18. 모멘텀의 오묘한 세계 (5) - 절대모멘텀 라이브 백테스트 96. 회사채 수익을 높이는 방법은? 평균모멘텀스코어 43. 상승장과 하락장을 구분하는 비법!! - 평균 모멘텀 스코어 가속듀얼모멘텀 97. 최근 20년간 복리 20% 벌고 최대손실 20% 나온 전략 대공개! 287. 2만명 기념 복리 20% 전략 투척! 마켓타이밍 50. [초보] 주식투자에서 표준편차는 무엇? 변동성 돌파 53. 역대 최강의 트레이더의 가장 위대한 전략 - 변동성 돌파전략 가치 + 우량주, 퀄리티 + 모멘텀 206. [서평] 퀀트로 가치투자하라 420. 트럼프 코로나 확진보다 놀라운 복리 18% 미국 주식 전략! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:17:3","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#173-모멘텀"},{"categories":["투자 일반"],"content":" 17.4. 자산배분 47. [초보] 백테스트 매뉴얼 (1) - 자산배분 ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:17:4","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#174-자산배분"},{"categories":["투자 일반"],"content":" 18. 백테스트는 퀀트투자의 핵심! 2","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:18:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#18-백테스트는-퀀트투자의-핵심-2"},{"categories":["투자 일반"],"content":" 18.1. 저평가 우량주소형주 저 PBR, 소형 우량주 5. 라이브 백테스트! 소형주/저 PBR 투자전략 아직도 먹히나? 438. 소형주의 마법, 복리 40%도 나오네! 439. 신 강환국 슈퍼가치전략, 복리 50% 가능? 버핏류 주식 7. 실전타임 : 한국시장에서 버핏류 주식을 찾아보자 356. 워렌 버핏이 한국에 오면 살 주식 저평가 우량주 11. 저평가 우량주 모멘텀주 발굴 실습! 강환국 슈퍼가치전략 83. 강환국 슈퍼가치전략 백테스트! NCAV 92. [초보] 투자전략 백테스트, 환상과 현실 ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:18:1","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#181-저평가-우량주"},{"categories":["투자 일반"],"content":" 18.2. 시즈널리티11-4월 40. 전세계에서 통하는 만능 전략 - 11월 초 매수, 4월 말 매도 110. [초보] 주식 투자는 역시 11월~4월이 적정기! 오버나잇 48. 세상에서 가장 시니컬한 전략! 종가 매수, 시가 매도 (라이브 백테스트) 월초월말 56. 정말 한달에 4일만 투자하면 되는가?? ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:18:2","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#182-시즈널리티"},{"categories":["투자 일반"],"content":" 18.3. 암호화폐 60. 암호화폐 - 사기인가 미래의 금인가 61. 암호화폐에 부동산보다 더 안전하게 투자한다고!? 131. [중요] 직접 백테스트를 해야 합니다!! 342. 강환국 가상화폐 전략, 18~19년 하락장에 먹혔나! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:18:3","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#183-암호화폐"},{"categories":["투자 일반"],"content":" 19. 투자서적 독후감 ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:19:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#19-투자서적-독후감"},{"categories":["투자 일반"],"content":" 19.1. 독후감들 108. 책 ‘마법의 연금 굴리기’ 독후감 109. 마법의 연금 굴리기, 김성일 작가님 질문답변 123. 코인이 오른다! 책 ‘가상화폐 투자 마법공식’ 셀프 독후감 144. [초보] 세계 최고의 주식 책 149. [서평] 버핏클럽2 - 버핏의 친구들 150. [서평] 버핏클럽2 - 가치투자, 이렇게 배우자 158. [서평] 나는 카지노에서 투자를 배웠다 167. [서평] 주식시장은 어떻게 반복되는가 (上) 177. 우파정권? 좌파정권? 투자자에게는 뭐가 좋은거지? 191. 내가 100만불 잃으면서 배운 것! (上) 192. 내가 100만불 잃으면서 배운 것! (下) 194. [초보] 역대 최고 자기계발서 - 투자에 관련 있는 3가지! 195. [초보] 워렌 버핏 투자비법 초보 매뉴얼! 196. 존버, 그는 누구인가? 205. ‘퀀트로 가치투자하라’ - 한국형 복리 20% 주식 찾기! 253. [국내최초] 복리 66%! 제임스 사이먼스의 투자 전략 공개! 256. (초보) 투자의 신, 복리 30% 피터 린치의 비법 (1) 257. (초보) 투자의 신 피터 린치의 비법 (2) 265. 투자의 신 피터 린치의 비법 (3) 428. (독후감) 따라하면 수익이 따라오는 ETF 투자 430. (독후감) 장애인 + 난독증 래리 하이트, 1억불을 벌다! 455. (독후감) 현명한 퀀트 주식투자(上) 462. (독후감) 현명한 퀀트 주식투자 (下) 486. (독후감) 주식시장을 더 이기는 마법의 멀티플 502. (독후감) 뉴욕주민의 디 앤서 510. (입문) 내 인생에서 가장 고마운 책 - 부자 아빠, 가난한 아빠 513. 2020년 미국 투자 챔피언이 추천하는 책 5권은? 516. 회사, 언제까지 다닐거니? 524. (독후감) 돈의 감정 545. (독후감) 돈의 역사는 되풀이된다 556. 역대 최고 자본가 록펠러에게 배울 점 5개! 573. FIRE를 이룬 사나이, EXIT를 읽다! 578. 돈의 속성 - 당신이 당장 써먹을 수 있는 팁 5개! 586. 부의 시나리오, 경제 예측에 대하여! 587. 당장 실전에서 써먹을 수 있는 투자 책 11권! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:19:1","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#191-독후감들"},{"categories":["투자 일반"],"content":" 19.2. 시장의 마법사 129. 인생 \u0026 투자 성공 전략 - 시장의 마법사들에게 배우다 (1) 133. 인생 \u0026 투자 성공 전략 - 시장의 마법사들에게 배우다 (2-1) 135. 인생 \u0026 투자 성공 전략 - 시장의 마법사들에게 배우다 (2-2) 139. 인생 \u0026 투자 성공 전략 - 시장의 마법사들에게 배우다 (3) - “니 자신을 알라” 145. 제프 베조스, 투자가 빡세서 창업을 하다 - (시장의 마법사들에게 배우다 시리즈 4, 5) 153. 시장의 마법사들에게 배우다 (6,7) - 매일매일 깨지면 어떻게 하는가? 164. 시장의 마법사들에게 배운다 (8) - 하이라이트! 리스크 관리 567. 미국 슈퍼개미, 사회적 차익거래로 연 복리 68% 벌다! 570. 17년 동안 복리 80%를 번 사나이, 제프 뉴맨! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:19:2","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#192-시장의-마법사"},{"categories":["투자 일반"],"content":" 19.3. 최고의 주식, 최적의 타이밍 555. 최고의 주식 최적의 타이밍 - 위대한 주식을 어떻게 찾나(1) 557. 최고의 주식 최적의 타이밍 - 위대한 주식을 사는 법(2) 559. 최고의 주식 최적의 타이밍 - 위대한 주식은 언제 사나? 564. 최고의 주식 최적의 타이밍 - 최고의 주식은 언제 파나? ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:19:3","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#193-최고의-주식-최적의-타이밍"},{"categories":["투자 일반"],"content":" 19.4. 부의 추월차선 297. (초보) 부자들이 모두 추천하는 그 책, 부의 추월차선 (1) 298. (초보) 부자들이 모두 추천하는 그 책, 부의 추월차선 (2) 309. 부자들이 모두 추천하는 그 책, 부의 추월차선 (3) 312. (초보) 부자들이 모두 추천하는 그 책, 부의 추월차선 (4) 315. (초보) 부자들이 가장 중요시 여기는 것은 무엇일까 - 부의 추월차선 (5) ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:19:4","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#194-부의-추월차선"},{"categories":["투자 일반"],"content":" 19.5. 강환국님 책 123. 코인이 오른다! 책 ‘가상화폐 투자 마법공식’ 셀프 독후감 236. 할 수 있다 퀀트투자 탄생기! 579. (신간 발행) 하면 된다! 퀀트투자 592. 교보 종합순위 9위 등극, 저자의 책 소개(브이로그) ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:19:5","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#195-강환국님-책"},{"categories":["투자 일반"],"content":" 20. 별 희한한 걸 다 했네요! 11075s ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:20:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#20-별-희한한-걸-다-했네요-1"},{"categories":["투자 일반"],"content":" 20.1. 나라면 이런거 사겠다현재 버전 518. 5~10월 투자전략(I) - 동적자산배분 523. 나라면 이런거 사겠다 - 강환국의 5~10월 실제 포트폴리오 동적자산배분(월간 시리즈) : 메월 초 커뮤니티 + 영상 ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:20:1","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#201-나라면-이런거-사겠다"},{"categories":["투자 일반"],"content":" 20.2. 구독자 사례 105. 구독자 사례 (1) - 은퇴 후 투자는 어떻게? 112. 구독자님들의 할투 활용 후기! 114. 구독자사례 (2) - 30대 초반, 자산 2억대 후반, 어떻게 투자? 120. 구독자사례 (3) - 언제 자산배분의 정석을 깰 수 있나? 308. [왕초보] 맞벌이 신혼부부, 10년 후 은퇴가능? 493. (구독자 사례) 강환국 상담 후 2년만에 20억, 100%를 버셨다! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:20:2","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#202-구독자-사례"},{"categories":["투자 일반"],"content":" 20.3. 재미있는 강좌/사이트/채널들 (강환국 유료강좌, 할투맵 등) 168. 금융 학습 최강 사이트 발견! 171. [초보] 미국 대박종목 찾기 264. 금융 논문, 어떻게 찾나요? 423. 아이폰 12보다 훌륭한 한국주식 백테스트 사이트! 425. 주식 투자하는 법을 알면 종목은 여기서 발굴! 426. 20년 복리 20% 개별주 전략 5개 소개! 456. (셀프홍보) 자산배분 전략 완전 정복! 466. 투자자료 찾으신다고요, 이제는 쉽습니다! 481. 할투 맵 탄생! 원클릭 맞춤형 동영상 서비스! 483. 닥터퀀트 + 강환국 자동매매 퀀트투자 패키지! 489. 오리지널 터틀 트레이딩의 파워! 526. (홍보) 3,000억 운용 펀드매니저, 터틀 트레이딩으로 리스타트! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:20:3","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#203-재미있는-강좌사이트채널들-강환국-유료강좌-할투맵-등"},{"categories":["투자 일반"],"content":" 21. 별 희한할 걸 다 했네요! 21120s ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:21:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#21-별-희한할-걸-다-했네요-2"},{"categories":["투자 일반"],"content":" 21.1. 역사/위인 이야기일본 최초 퀀트. 아프리카의 워렌 버핏 203. 일본 최초 퀀트투자자, 1000억 원 번 스토리! 219. [초보] 아프리카의 워렌 버핏, 종목 한 개로 169조원 벌다! 무서운 언니들 (린다 라쉬케 등) 220. [초보] 역대 최강 여성 투자자 3인방 소개 238. 여성 최강 트레이더 린다 라쉬케 - 1시간짜리 인터뷰에 이렇게 많은 지혜가! 306. 역대 최강 여성 트레이더, 미국시장 거래 비법 공개! 포커로 파진 주식쟁이, 트럼프, 케인스 224. [초보] 주식투자자가 역대 최고 400억원 포커판에서 배우는 교훈 225. 트럼프 트윗을 보는 지표 + 더 이상한 지표들 집합! 234. (초보) 케인스 - 역대 최고 경제학자의 투자실력은? 역대 최강은 누구, 짐 사이먼스, 피터 린치 251 . (초보) 역대 최강의 투자자는 누구인가? (feat. 버핏, 소로스, 그로스, 린치) 253. [국내최초] 복리 66%! 제임스 사이먼스의 투자 전략 공개! 256. (초보) 투자의 신, 복리 30% 피터 린치의 비법 (1) 257. (초보) 투자의 신 피터 린치의 비법 (2) 265. 투자의 신 피터 린치의 비법 (3) 헤지펀드 최강자 272. 헤지펀드의 역사 (1) - 헤지펀드의 아버지 존스 276. 헤지펀드의 역사 (2) - 역발상 사이코 슈타인하트 279. 헤지펀드의 역사 (3) - 연금술사 소로스 294. 헤지펀드의 역사 (4) - 영국을 굴복시킨 사나이들 댄 쟁거 424. 2년만에 4,000배를 번 사나이, 댄 쟁거! (1) 427. 2년만에 4,000배를 번 사나이 댄 쟁거(2) 래리 하이트 430. (독후감) 장애인 + 난독증 래리 하이트, 1억불을 벌다! 강환국 흑역사 197. [초보] 강환국의 4대 투자 흑역사 공개! 318. (투자심리) 강환국 폭망에서 무엇을 배울 수 있는가? 그레이엄 474. 벤자민 그레이엄, 가치투자, 퀀트투자의 창조자! 워렌버핏 355. (왕초보 1억) 워렌 버핏이 1억 달러를 한국에 올인한 이유! 356. 워렌 버핏이 한국에 오면 살 주식 403. (왕초보 1억) 워렌 버핏의 7대 명언 406. 워렌버핏이 일본에 7조 투자한 이유! 497. 버크셔 연차보고서를 보고서! 캘러씨 인터뷰 385. 동적자산배분의 절대지존 Wouter Keller와의 인터뷰 요약(I) 386. 동적자산배분의 절대지존, Wouter Keller와의 인터뷰(II) ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:21:1","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#211-역사위인-이야기"},{"categories":["투자 일반"],"content":" 21.2. 인생 꼰대질(자기계발) - 성공, 외국어 등 413. 유튜브 하면서 배운 - 뭘 하든 상위 10% 가는 방법! 430. (독후감) 장애인 + 난독증 래리 하이트, 1억불을 벌다! 459. (크리스마스 특집) 외국어 잘하는 노하우는? 463. (신년특집) 투자에서 성공하면 인생에서 성공? 593. (FIRE) 평범한 삶을 살고 싶다고? 성공하는 것이 훨씬 쉬워! ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:21:2","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#212-인생-꼰대질자기계발---성공-외국어-등"},{"categories":["투자 일반"],"content":" 22. 요약1149s ","date":"2021-10-22","objectID":"/2021-10-22_halto-600/:22:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '할 수 있다! 알고투자 600회 스페셜 완성본' 정리","uri":"/2021-10-22_halto-600/#22-요약"},{"categories":["게임 개발"],"content":"LittleVulkanEngine 을 따라 만들어 보면서, Vulkan을 배워봅시다. Youtube Link ","date":"2021-10-18","objectID":"/2021-10-18_drawing-a-triangle-2/:0:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Command Buffers Overview - Vulkan Game Engine Tutorial 05 part 2' 정리","uri":"/2021-10-18_drawing-a-triangle-2/#"},{"categories":["게임 개발"],"content":" 1. 주요내용 Command Buffer 설명 삼각형 하나 드디어 그렸음 쉐이더 컴파일 자동화 고정 댓글에 PipelineConfigInfo 관련 추가 수정 있음 ","date":"2021-10-18","objectID":"/2021-10-18_drawing-a-triangle-2/:1:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Command Buffers Overview - Vulkan Game Engine Tutorial 05 part 2' 정리","uri":"/2021-10-18_drawing-a-triangle-2/#1-주요내용"},{"categories":["게임 개발"],"content":" 2. Command BufferVulkan 에서는 gpu 가 수행할 명령들을 Command Buffer 라는 데 넣어서 gpu에게 submit 합니다. ","date":"2021-10-18","objectID":"/2021-10-18_drawing-a-triangle-2/:2:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Command Buffers Overview - Vulkan Game Engine Tutorial 05 part 2' 정리","uri":"/2021-10-18_drawing-a-triangle-2/#2-command-buffer"},{"categories":["게임 개발"],"content":" 2.1. 일반Vulkan을 cmd를 바로 실행할 수 없습니다. Command Buffer에 레코딩 해 놓고, Device Grphics Queue에 서밋하는 것으로 실행을 합니다. 22s 한 번 레코딩 해두고, 매 프레임마다 녹화 해둔 걸 다시 사용하는 거죠. OpenGL 에서는 매 프레임 draw command를 부른다고 합니다. ","date":"2021-10-18","objectID":"/2021-10-18_drawing-a-triangle-2/:2:1","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Command Buffers Overview - Vulkan Game Engine Tutorial 05 part 2' 정리","uri":"/2021-10-18_drawing-a-triangle-2/#21-일반"},{"categories":["게임 개발"],"content":" 2.2. Command Buffer Lifecycle58s 커맨드 버퍼는 위와 같은 Lifecycle을 가집니다. 처음에 커맨드들을 녹화해두면 Executable 상태가 되고, Queue에 서밋하면 Pending, 사용이 완료되면 다시 Executable 상태가 됩니다. 97s Framebuffer가 3개여도 Command Buffer는 두 개면 충분하기는 하다고 합니다. 저희는 배우는 단계니까 1:1 로 갑니다. ","date":"2021-10-18","objectID":"/2021-10-18_drawing-a-triangle-2/:2:2","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Command Buffers Overview - Vulkan Game Engine Tutorial 05 part 2' 정리","uri":"/2021-10-18_drawing-a-triangle-2/#22-command-buffer-lifecycle"},{"categories":["게임 개발"],"content":" 2.3. VkCommandBufferAllocateInfoVkCommandBufferAllocateInfo 를 채워서 VkCommandBuffer를 생성하는 데 사용합니다. 174s 이 중에 level 설정은 Command Buffer의 성격을 결정 합니다. Primary : Device Graphics Queue 에 서밋 될 수 있음 Secondary : 서밋은 안됨. 다른 Primary 커맨드 버퍼에서 실행할 수 있음 503s Command Buffer 안에는 위의 그림과 같이 커맨드들이 레코딩됩니다. Start Render Pass # 어떤 구조 포맷의 프레임버퍼인지 설정 Bind Pipeline 1 # 파이프라인에 바인딩 Draw 100 vertices # 실제 그럼 ... End Render Pass # 해당 렌더 패스 끝 위와 같이 Render Pass 안에 실제 커맨드가 있는 경우 Inline 이라고 합니다. Render Pass 안에 실제 커맨드 대신 vkCmdExecute() 로 Secondary Command Buffer를 실행할 수도 있습니다. 단, 요 두가지는 섞어서 쓸 수는 없다고 합니다. ","date":"2021-10-18","objectID":"/2021-10-18_drawing-a-triangle-2/:2:3","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Command Buffers Overview - Vulkan Game Engine Tutorial 05 part 2' 정리","uri":"/2021-10-18_drawing-a-triangle-2/#23-vkcommandbufferallocateinfo"},{"categories":["게임 개발"],"content":" 3. 구현","date":"2021-10-18","objectID":"/2021-10-18_drawing-a-triangle-2/:3:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Command Buffers Overview - Vulkan Game Engine Tutorial 05 part 2' 정리","uri":"/2021-10-18_drawing-a-triangle-2/#3-구현"},{"categories":["게임 개발"],"content":" 3.1. FirstApp 구현 createCommandBuffers() 구현 VkCommandBuffer 두 개 생성 고 버퍼들에 명령 녹화 녹화 시작 (vkBeginCommandBuffer()) 렌더 패스 준비 (VkRenderPassBeginInfo) 렌더 패스 시작 (vkCmdBeginRenderPass()) 그래픽 파이프라인 바인드 vkCmdDraw() 호출 렌더 패스 끝 (vkCmdEndRenderPass()) 녹화 끝 (vkEndCommandBuffer()) drawFrame() 구현 이미지 인덱스 가져옴 (from swap chain) 커맨드 버퍼 서밋 run() 에 기다리는 코드 추가 ","date":"2021-10-18","objectID":"/2021-10-18_drawing-a-triangle-2/:3:1","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Command Buffers Overview - Vulkan Game Engine Tutorial 05 part 2' 정리","uri":"/2021-10-18_drawing-a-triangle-2/#31-firstapp-구현"},{"categories":["게임 개발"],"content":" 3.2. LivePipeline 구현 bind(VkCommandBuffer) 메소드 추가 vkCmdBindPipeline() : 커맨드 버퍼를 VkPipeline 에 바인드함 ","date":"2021-10-18","objectID":"/2021-10-18_drawing-a-triangle-2/:3:2","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Command Buffers Overview - Vulkan Game Engine Tutorial 05 part 2' 정리","uri":"/2021-10-18_drawing-a-triangle-2/#32-livepipeline-구현"},{"categories":["게임 개발"],"content":" 4. 쉐이더 컴파일 자동화비주얼 스튜디오를 위한 설명을 없네요. 나중에 찾아보도록 하겠습니다. ","date":"2021-10-18","objectID":"/2021-10-18_drawing-a-triangle-2/:4:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Command Buffers Overview - Vulkan Game Engine Tutorial 05 part 2' 정리","uri":"/2021-10-18_drawing-a-triangle-2/#4-쉐이더-컴파일-자동화"},{"categories":["게임 개발"],"content":" 5. 다이어그램 여기까지 전체 동작을 한 번 훑어 봅시다. FirstApp 인스턴스가 만들어지면, LveWindow 객체를 만듭니다. LveDevice 객체를 만듭니다. LveSwapChain 객체를 만듭니다. FirstApp 생성자를 호출합니다. pipelineLayout 을 만듭니다. LvePipeLine 객체를 만듭니다. Command Buffers 를 만들고 레코딩 합니다. 이후에, run() 루프에서 매프레임 command buffer를 서밋하여, gpu에게 삼각형를 그리라고 시킵니다. ","date":"2021-10-18","objectID":"/2021-10-18_drawing-a-triangle-2/:5:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Command Buffers Overview - Vulkan Game Engine Tutorial 05 part 2' 정리","uri":"/2021-10-18_drawing-a-triangle-2/#5-다이어그램"},{"categories":["게임 개발"],"content":"Youtube Link ​ ","date":"2021-10-16","objectID":"/2021-10-16_fixed-function-pipeline-stages/:0:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Fixed Function Pipeline Stages - Vulkan Game Engine Tutorial 04' 정리","uri":"/2021-10-16_fixed-function-pipeline-stages/#"},{"categories":["게임 개발"],"content":" 1. 주요 내용​ PipelineConfigInfo 구조체를 하나씩 채움 vkCreateGraphicsPipelines() 호출해서 파이프라인을 생성할 준비 ​ ​ ","date":"2021-10-16","objectID":"/2021-10-16_fixed-function-pipeline-stages/:1:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Fixed Function Pipeline Stages - Vulkan Game Engine Tutorial 04' 정리","uri":"/2021-10-16_fixed-function-pipeline-stages/#1-주요-내용"},{"categories":["게임 개발"],"content":" 2. 실습 코드 수정​ 이번에 하고 싶은건 그래픽 파이프라인(VkPipeline)을 하나 만드는 것입니다. ​ vkCreateGraphicsPipelines() 함수를 호출하고 싶은 건데, 만들어진 파이프라인이 어떻게 동작할 건지 설정 값들을 미리 다 세팅해줘야 합니다. ​ 이를 위해 VkGraphicsPipelineCreateInfo 구조체를 채워야 합니다. ​ ‘Graphics Pipeline Overview - Vulkan Game Engine Tutorial 02’ 정리 에서 봤던 그래픽 파이프라인을 다시 한 번 봐봅시다. ​ ​ VkGraphicsPipelineCreateInfo 구조체가 각 단계별 동작의 세팅 값 및 부가적으로 필요한 정보를 가지고 있습니다. 요걸 채워서 함수 호출할 때 넘겨줘야 합니다. 거대한 구조체네요ㅠㅜ ​ 위 구조체에서 일부 세팅 값들을 PipelineConfigInfo로 따로 빼두었습니다. 아마도 일부 세팅 값을 바꿔서 비슷한 그래픽 파이프라인을 또 만들 때 사용할 예정인 듯 합니다. ​ ","date":"2021-10-16","objectID":"/2021-10-16_fixed-function-pipeline-stages/:2:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Fixed Function Pipeline Stages - Vulkan Game Engine Tutorial 04' 정리","uri":"/2021-10-16_fixed-function-pipeline-stages/#2-실습-코드-수정"},{"categories":["게임 개발"],"content":" 2.1. inputAssemblyInfo​ 맨 처음 들어온 데이터 뭉치를 어떻게 해석할지 정합니다. ​세 개씩 끊어서 삼각형 하나로 볼지, ​ 두 번째 그림처럼 중첩해서 삼각형을 만들지 정합니다. ​ 참고로, 인풋 데이터는 위치 정보외에 다른 정보들도 포함될 수 있습니다. ​ 79s ​ 124s ​ ​ 이를 위해, VkPipelineInputAssemblyStateCreateInfo 를 세팅합니다. ​ ","date":"2021-10-16","objectID":"/2021-10-16_fixed-function-pipeline-stages/:2:1","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Fixed Function Pipeline Stages - Vulkan Game Engine Tutorial 04' 정리","uri":"/2021-10-16_fixed-function-pipeline-stages/#21-inputassemblyinfo"},{"categories":["게임 개발"],"content":" 2.2. viewportInfo​ Vertext Shader 까지는 [-1, -1] ~ [1, 1] 좌표계(NDC, Normalized Device Coordinates)를 사용합니다. ​ 요 좌표계를 가져다가 fragmentbuffer 의 어느 부분에 그릴 것인지를 정해야 합니다. ​ 이를 위해, VkPipelineViewportStateCreateInfo 를 세팅합니다. ​ 요 안에 viewport와 scissor 가 또 있습니다. 209s ​ 위 그림에서 어떻게 매핑할 것인지가 viewport 설정입니다. ​ NDC의 (-1, -1), (1,1)을 framebuffer 의 어디로 매핑할 것인지를 결정합니다. framebuffer 중에서 특정 영역만 필요한 상황이 있을 수 있습니다. (다른 창에 의해서 가려지거나 해서 그릴 필요가 없는경우?) ​ 이를 위해 scissor가 있습니다. ​ framebuffer의 특정 영역을 골라서, 그 부분만 그리면 된다고 알려 줍니다. ​ 아직은 빌드가 제대로 안되고, ​ Tutorial 5-1 까지 구현을 마치고 난 후에, 값을 바꿔서 테스트 해 봅시다. ​ ​ (1) 번은 Tutorial 5-1 까지의 결과물 입니다. ​빨간색이 viewport, 파란색이 scissor 입니다. ​(2)번은 다음과 같이 viewport를 세팅했습니다. ​ // 시작점 NDC(-1,-1) -\u003e (0, 300) configInfo.viewport.x = 0.0f; configInfo.viewport.y = 300.0f; ​ // offset (0, 300) 기준으로 (+400, +300) 위치로 NDC(1, 1)을 매핑 configInfo.viewport.width = static_cast\u003cfloat\u003e(width / 2); // 400 configInfo.viewport.height = static_cast\u003cfloat\u003e(height / 2); // 300 configInfo.viewport.minDepth = 0.0f; configInfo.viewport.maxDepth = 1.0f; ​ (3)번은 scissor 까지 세팅했습니다. ​ // offset (0,0) 정하고, 거기에서 (+200, +800) 위치 까지만 표시 configInfo.scissor.offset = { 0, 0 }; configInfo.scissor.extent = { width / 4, height }; // 200, 300 ​ 좋은 그래픽 카드에서는 viewport, scissor 여러 개일 수도 있다고 합니다. ​ ","date":"2021-10-16","objectID":"/2021-10-16_fixed-function-pipeline-stages/:2:2","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Fixed Function Pipeline Stages - Vulkan Game Engine Tutorial 04' 정리","uri":"/2021-10-16_fixed-function-pipeline-stages/#22-viewportinfo"},{"categories":["게임 개발"],"content":" 2.3. rasterizationInfo​ 그래픽 파이프라인에서 Raterization 은 vertex shader 가 넘겨 준 geometry 데이터들을 받아서 ​fragment 들로 바꿉니다. ​ 위에서 봤던 scissor 도 적용하고(scissor test), 카메라에서 너무 가깝거나 먼지도 확인하고(depth test), 삼각형의 앞면 뒷면 여부도 판단(face culling)도 여기서 합니다. ​ 요 동작들을 위한 세팅을 VkPipelineRasterizationStateCreateInfo 에다가 합니다. ​ 이중에 cullMode, frontFace는 삼각형의 뒷면을 런더링 하지 않기 위한 세팅입니다. (face culling) ​ 카메라에 삼각형의 뒷면이 보이는 경우에는 그리지 않음으로써, 성능 향상을 꾀하기 위함입니다. ​ 391s ​ ​ 어떤 방향을 앞면으로 볼 건지 결정할 수 있습니다. ","date":"2021-10-16","objectID":"/2021-10-16_fixed-function-pipeline-stages/:2:3","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Fixed Function Pipeline Stages - Vulkan Game Engine Tutorial 04' 정리","uri":"/2021-10-16_fixed-function-pipeline-stages/#23-rasterizationinfo"},{"categories":["게임 개발"],"content":" 2.4. multisampleInfo​ MSAA: Multisampling Anti-aliasing ​ Rasterization 과정에서 런더링 해야 하는 fragment 를 선정할 때, ​각 fragment의 중앙의 점이 삼각형에 포함되는지 여부로 판단하는 듯 합니다. ​삼각형 안쪽인지 바깥쪽인지가 true / false 로 정해지는 것이죠. ​ 이로 인해, 경계선 부분이 거칠게 보이는 계단 현상(aliasing)이 나타납니다. ​ 478s ​ 이를 해결하기 위해, Multisample Anti-aliasing을 사용할 수 있습니다. ​ fragment 를 선정할 때, 한 개 점이 아니라 여러 점을 사용해서, 몇 개의 점이 삼각형에 포함되는지에 따라, 색을 살짝 연하게 칠하던가 하는 듯 합니다. ​ 488s ​ 이를 위해, VkPipelineMultisampleStateCreateInfo 를 세팅합니다. ​ ","date":"2021-10-16","objectID":"/2021-10-16_fixed-function-pipeline-stages/:2:4","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Fixed Function Pipeline Stages - Vulkan Game Engine Tutorial 04' 정리","uri":"/2021-10-16_fixed-function-pipeline-stages/#24-multisampleinfo"},{"categories":["게임 개발"],"content":" 2.5. colorBlendInfo​ 모델 여러 개가 겹쳐 있는 경우, 특정 fragment (픽셀)을 생각해 봅시다. ​첫 번째 모델을 그리면, fragment shader 가 색을 결정해서 framebuffer를 채워 놓은 상태일 겁니다. ​여기서 다음 모델을 그리면, fragment shader 가 framebuffer를 채울 때, 해당 fragment에 기존에 채워져 있는 색깔이랑 같이 잘 표현해야 합니다. ​ 보통은 투명도에 따라 기존 색과 현재 색을 섞는 알파 블렌딩을 사용한다고 합니다. ​ 이를 위해, VkPipelineColorBlendStateCreateInfo 를 세팅합니다. (내부에 VkPipelineColorBlendAttachmentState) ​ ","date":"2021-10-16","objectID":"/2021-10-16_fixed-function-pipeline-stages/:2:5","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Fixed Function Pipeline Stages - Vulkan Game Engine Tutorial 04' 정리","uri":"/2021-10-16_fixed-function-pipeline-stages/#25-colorblendinfo"},{"categories":["게임 개발"],"content":" 2.6. depthStencilInfo​ framebuffer는 보통 color buffer 와 depth 버퍼를 가집니다. ​ depth 버퍼는 해당 픽셀에서 카메라와 가장 가까이 있는 object의 거리를 저장합니다. (어떤 object인지는 관심 없음) ​ 산이 그려 졌고 (depth 0.5), 이제 구름 depth 0.8에 을 그린다고 하면 ​ 산과 겹치는 부분의 픽셀은 산에 가려질 테니(depth 버퍼에 저장되어 있는 값이, 현재 그릴려는 object의 depth 보다 작으므로) 그릴 필요가 없습니다. ​ 593s ​ 이를 위해 VkPipelineDepthStencilStateCreateInfo 를 세팅합니다. ​ ","date":"2021-10-16","objectID":"/2021-10-16_fixed-function-pipeline-stages/:2:6","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Fixed Function Pipeline Stages - Vulkan Game Engine Tutorial 04' 정리","uri":"/2021-10-16_fixed-function-pipeline-stages/#26-depthstencilinfo"},{"categories":["게임 개발"],"content":" 2.7. shaderStage​ 앞 장에서 Vertex Shader, Fragment Shader를 작성해서 VkShaderModule 들을 만들었습니다. ​ 요 정보도 파이프라인 생성할 때, 넘겨 줘야 합니다. ​ 이를 위해, VkPipelineShaderStateCreateInfo 를 세팅합니다. ​ ","date":"2021-10-16","objectID":"/2021-10-16_fixed-function-pipeline-stages/:2:7","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Fixed Function Pipeline Stages - Vulkan Game Engine Tutorial 04' 정리","uri":"/2021-10-16_fixed-function-pipeline-stages/#27-shaderstage"},{"categories":["게임 개발"],"content":" 2.8. vertexInputInfo​ 그래픽 파이프라인에 맨 처음 들어오는 데이터 뭉치는 각 Vertex 별로 위치 뿐만 아니라 다른 여러 데이터를 포함할 수 있습니다. ​ 요 데이터들이 어떻게 정렬되어 있는지, ​ 인덱스 버퍼라는 게 따로 있는지 정보도 넘겨줘야 합니다. ​ 이를 위해, VkPipelineVertexInputStateCreateInfo 를 세팅합니다. ​ ","date":"2021-10-16","objectID":"/2021-10-16_fixed-function-pipeline-stages/:2:8","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Fixed Function Pipeline Stages - Vulkan Game Engine Tutorial 04' 정리","uri":"/2021-10-16_fixed-function-pipeline-stages/#28-vertexinputinfo"},{"categories":["게임 개발"],"content":" 2.9. pipelineInfo 대통합이제 지금까지 준비한 세팅 값들로 VkGraphicsPipelineCreateInfo 구조체를 채웁니다. ​요 구조체를 넘겨서, vkCreateGraphicsPipelines() 함수를 드디어 호출합니다. (pipelineLayout, renderPass 를 아직 채우지 않아서, 정상 실행은 되지 않습니다.) ​ ​ ","date":"2021-10-16","objectID":"/2021-10-16_fixed-function-pipeline-stages/:2:9","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Fixed Function Pipeline Stages - Vulkan Game Engine Tutorial 04' 정리","uri":"/2021-10-16_fixed-function-pipeline-stages/#29-pipelineinfo-대통합"},{"categories":["게임 개발"],"content":" 3. 다이어그램​ ","date":"2021-10-16","objectID":"/2021-10-16_fixed-function-pipeline-stages/:0:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Fixed Function Pipeline Stages - Vulkan Game Engine Tutorial 04' 정리","uri":"/2021-10-16_fixed-function-pipeline-stages/#3-다이어그램"},{"categories":["게임 개발"],"content":"Youtube Link ","date":"2021-10-16","objectID":"/2021-10-17_swapchain/:0:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Swap Chain Overview - Vulkan Game Engine Tutorial 05 part 1' 정리","uri":"/2021-10-17_swapchain/#"},{"categories":["게임 개발"],"content":" 1. 주요 내용 SwapChain 관련 소스 다운 받아서 적용 (이해는 천천히) 고정 댓글에 PipelineConfigInfo 관련 추가 수정 있음 Swap Chain, V-Sync, Presentation Mode, Render Pass 설명 ","date":"2021-10-16","objectID":"/2021-10-17_swapchain/:1:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Swap Chain Overview - Vulkan Game Engine Tutorial 05 part 1' 정리","uri":"/2021-10-17_swapchain/#1-주요-내용"},{"categories":["게임 개발"],"content":" 2. Swap ChainSwap Chain is a series of framebuffer. 8s Framebuffer 여러 개를 들고 있는 게 Swap Chain 이라고 생각하면 되는 듯 합니다. 그래픽 파이프라인을 쭉 지나면서 FrameBuffer 를 채우는데, 어떤 Framebuffer를 써야 하는지를 Swap Chain이 관리합니다. 17s 어떤 Framebuffer를 실제 Surface에 보여줄지도 Swap Chain 이 관리합니다. Framebuffer는 보통 Color Buffer와 Depth Buffer를 가지고 있습니다. (Attachment 라고 부릅니다.) 요 중에 Color Buffer를 Surface 그릴 때 사용하는 듯 합니다. 아마도 OS가 ‘이번에 그릴 Buffer 주렴’ 하면, 적절한 Framebuffer의 Color Buffer를 던져 줄 듯 합니다. 41s 대부분의 OS는 Framebuffer를 두 개 사용하는 더블 버퍼링을 하고 있습니다. 지금 display 되는 Framebuffer를 Front Buffer 라고 하고, 지금 그래픽 파이프라인이 열심히 그리고 있는 Framebuffer를 Back Buffer 라고 부릅니다. Swap Chain 이 요 Framebuffer들의 싱크 맞추는 것도 담당합니다. ","date":"2021-10-16","objectID":"/2021-10-17_swapchain/:2:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Swap Chain Overview - Vulkan Game Engine Tutorial 05 part 1' 정리","uri":"/2021-10-17_swapchain/#2-swap-chain"},{"categories":["게임 개발"],"content":" 3. V-Sync66s 싱크의 기본이 되는 것이 V-Sync(화면을 위쪽부터 한 줄씩 다 그린 후, 준비를 위해 화면 아래 한 줄을 더 가는 느낌) 입니다. 디스플레이 장치의 Refresh Rate가 60Hz인 경우, V-Sync 신호가 1/60초(16.6ms) 마다 발생합니다. 요 V-Sync 신호에 front buffer 와 back buffer 를 스왑합니다. 106s 요 V-Sync 에 맞춰 렌더링을 하면 빨간색으로 칠한 시간 동안은 gpu가 놀고 있는 상태입니다. 133s 다음 V-Sync 가 왔는데도, gpu 가 아직 일을 다 끝내지 못했다면, 아직 back buffer가 준비되지 않았으므로, swap 을 하지 못하고 같은 화면이 다음 frame에도 보이게 됩니다. 요게 많아지면 사용자 입장에서 화면이 프레임이 뚝뚝 끊겨 보이게 됩니다. 156s framebuffer를 하나 더 사용해서 tripple buffering을 하면 요 상황을 개선할 수 있습니다. 다만 메모리를 framebuffer 하나만큼 더 사용하겠지요. OpenGL 에서는 tripple buffering 관련한 세팅을 별로 신경 안써도 됐는데, Vulakn에서는 명시적으로 해줘야 한다고 합니다. 지금 시점에서 알아둬야 할 것 We will have multiple framebuffers (2 or 3) We can use swapChain.acquireNextImage() to get the next index of our framebuffers ","date":"2021-10-16","objectID":"/2021-10-17_swapchain/:3:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Swap Chain Overview - Vulkan Game Engine Tutorial 05 part 1' 정리","uri":"/2021-10-17_swapchain/#3-v-sync"},{"categories":["게임 개발"],"content":" 4. Presentation Mode492s 요 sync 관련 동작을 어떻게 할 것이냐에를 정하기 위해 몇 가지 모드가 있습니다. 529s 일단 FIFO (V-Sync 사용) 모드로 진행합니다. 모바일에서는 소모 전류 이슈로 인해서 Mainbox나 Immediate를 쓸 일은 없어 보입니다. ","date":"2021-10-16","objectID":"/2021-10-17_swapchain/:4:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Swap Chain Overview - Vulkan Game Engine Tutorial 05 part 1' 정리","uri":"/2021-10-17_swapchain/#4-presentation-mode"},{"categories":["게임 개발"],"content":" 5. Render Pass883s Render Pass 는 Framebuffer의 구조와 포맷에 관한 정보를 가지고 있습니다. (어떤 attachment 들을 갖고 있는지) 그래픽 파이프라인에게 ‘너가 채워야할 Framebuffer는 요렇게 생겼단다.’ 하고 알려주는 blueprint 느낌입니다. ","date":"2021-10-16","objectID":"/2021-10-17_swapchain/:5:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Swap Chain Overview - Vulkan Game Engine Tutorial 05 part 1' 정리","uri":"/2021-10-17_swapchain/#5-render-pass"},{"categories":["게임 개발"],"content":" 6. FirstApp 클래스 구현 lveSwapChain 멤버 추가 lvePipeline 에 스마트 포인터 사용 종종 https://www.learncpp.com/ 를 읽어 보는 걸 추천하고 있습니다. pipelineLayout 멤버 추가 commandBuffers 멤버 추가 FirstApp 생성자 및 private 메소드들 추가 createPipelineLayout() : pipelineLayout 만듬 (vkCreatePipelineLayout()) SetLayout : 쉐이더에 텍스처나 유니폼 버퍼 같은 애들 넘기는 용도 - PushConstant : 아주 작은 데이터를 쉐이더에 넘기는 용도 createPipeline() : LvePipeline 생성 createCommandBuffers() : 빈 함수 ","date":"2021-10-16","objectID":"/2021-10-17_swapchain/:6:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Swap Chain Overview - Vulkan Game Engine Tutorial 05 part 1' 정리","uri":"/2021-10-17_swapchain/#6-firstapp-클래스-구현"},{"categories":["게임 개발"],"content":"Youtube Link ","date":"2021-10-15","objectID":"/2021-10-15_device-setup/:0:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Device Setup \u0026 Pipeline cont. - Vulkan Game Engine Tutorial 03' 정리","uri":"/2021-10-15_device-setup/#"},{"categories":["게임 개발"],"content":" 1. 주요 내용 device 관련 준비된 소스 다운 받아서 적용 (이해는 나~중에) Vulkan-Tutorial.com 의 아래 섹션들에 해당 ","date":"2021-10-15","objectID":"/2021-10-15_device-setup/:1:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Device Setup \u0026 Pipeline cont. - Vulkan Game Engine Tutorial 03' 정리","uri":"/2021-10-15_device-setup/#1-주요-내용"},{"categories":["게임 개발"],"content":" 2. 실습 코드 수정","date":"2021-10-15","objectID":"/2021-10-15_device-setup/:2:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Device Setup \u0026 Pipeline cont. - Vulkan Game Engine Tutorial 03' 정리","uri":"/2021-10-15_device-setup/#2-실습-코드-수정"},{"categories":["게임 개발"],"content":" 2.1. LveWindow createWindowSurface() 준비 : LveDevice.createSurface() 에서 사용 ","date":"2021-10-15","objectID":"/2021-10-15_device-setup/:2:1","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Device Setup \u0026 Pipeline cont. - Vulkan Game Engine Tutorial 03' 정리","uri":"/2021-10-15_device-setup/#21-lvewindow"},{"categories":["게임 개발"],"content":" 2.2. LveDevice 생성자 동작 1. Initializing vulkan and picking a physical device 2. Setup validation layers to help debug ","date":"2021-10-15","objectID":"/2021-10-15_device-setup/:2:2","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Device Setup \u0026 Pipeline cont. - Vulkan Game Engine Tutorial 03' 정리","uri":"/2021-10-15_device-setup/#22-lvedevice"},{"categories":["게임 개발"],"content":" 2.2. LvePipeline PipelineConfigInfo : 앱단에서 파이프라인 주물럭 하기 위해 필요 생성자 시그니처 변경 멤버 변수들 추가 createShaderModule() 메소드 추가 static PipelineConfigInfo defaultPipelineConfigInfo() 추가 ","date":"2021-10-15","objectID":"/2021-10-15_device-setup/:2:3","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Device Setup \u0026 Pipeline cont. - Vulkan Game Engine Tutorial 03' 정리","uri":"/2021-10-15_device-setup/#22-lvepipeline"},{"categories":["게임 개발"],"content":" 2.3. FirstApp LveDevice 멤버 추가 LvePipleline 시그니처 변경 적용 ","date":"2021-10-15","objectID":"/2021-10-15_device-setup/:2:4","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Device Setup \u0026 Pipeline cont. - Vulkan Game Engine Tutorial 03' 정리","uri":"/2021-10-15_device-setup/#23-firstapp"},{"categories":["게임 개발"],"content":" 3. 다이어그램 ","date":"2021-10-15","objectID":"/2021-10-15_device-setup/:3:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Device Setup \u0026 Pipeline cont. - Vulkan Game Engine Tutorial 03' 정리","uri":"/2021-10-15_device-setup/#3-다이어그램"},{"categories":["게임 개발"],"content":"Youtube Link ","date":"2021-10-14","objectID":"/2021-10-14_graphics-pipeline/:0:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Graphics Pipeline Overview - Vulkan Game Engine Tutorial 02' 정리","uri":"/2021-10-14_graphics-pipeline/#"},{"categories":["게임 개발"],"content":" 1. 주요 내용 graphics pipeline 설명 vertex shader, fragment shader 작성(만) 해보기. SPIR-V로 컴파일 LvePipeline 클래스 작성 : 컴파일된 spv 파일 읽어서 사이즈 출력 ","date":"2021-10-14","objectID":"/2021-10-14_graphics-pipeline/:1:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Graphics Pipeline Overview - Vulkan Game Engine Tutorial 02' 정리","uri":"/2021-10-14_graphics-pipeline/#1-주요-내용"},{"categories":["게임 개발"],"content":" 2. Graphics Pipeline 설명컴퓨터가 그림 한 장을 어떻게 그리는지 자세히 들여다 봐 봅시다. 삼각형 하나만 생각해 봅시다. 53s 컴퓨터 입장에서 꼭지점(Vertex) 정보 (여기서는 숫자 6개) 가 있으면, 고 정보 기반으로 어떤 픽셀이 삼각형에 포함되는지 확인해서, 해당 픽셀에 색칠을 할 겁니다. 바로 요게 Graphics Pipeline 이 하는 일입니다. 193s Graphic Pipeline은 인풋 정보들을 가지고, FrameBuffer를 채우기 위한 일련의 과정입니다. 여러 stage 들을 거치는데, 공장의 컨베이어 벨트를 생각하시면 적절합니다. 위 그림에서 녹색은 Fixed Function이고, 보라색은 Programmable 합니다. 요 Programmable한 Vertex Shader, Fragment Shader 를 통해서 GPU한테 추가로 많은 일을 시킬 수 있습니다. 각 단계에 대해서 아직은 잘 몰라도 되지만, 간단한 설명은 Vulkan-Tutorial.com 을 참고해도 좋을 것 같습니다. 226s 왜 이런 복잡한 과정을 거칠까 하는 생각이 들 수 있습니다.. 이것은 CPU와 GPU의 동작 차이에 기인합니다. GPU는 단순하고 반복적인 계산에 특화되어 있습니다. 한꺼번에 수천개의 vertex를 처리할 수 있죠. 대신에 제한된 방법으로 제한된 용도로만 사용할 수 있죠. ","date":"2021-10-14","objectID":"/2021-10-14_graphics-pipeline/:2:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Graphics Pipeline Overview - Vulkan Game Engine Tutorial 02' 정리","uri":"/2021-10-14_graphics-pipeline/#2-graphics-pipeline-설명"},{"categories":["게임 개발"],"content":" 3. 실습 코드 수정shaders 폴더에 Vertex Shader와 Fragment Shader를 만들어 봅시다. ","date":"2021-10-14","objectID":"/2021-10-14_graphics-pipeline/:3:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Graphics Pipeline Overview - Vulkan Game Engine Tutorial 02' 정리","uri":"/2021-10-14_graphics-pipeline/#3-실습-코드-수정"},{"categories":["게임 개발"],"content":" 3.1. vertex shader 작성409s Vertex Shader는 NDC(Normalized Device Coordinates, 정규화 장치 좌표계) 기준으로 위치 데이터 출력합니다. [-1, -1] ~ [1, 1] 안에 들어오는 게 화면에 그려진다고 보면 됩니다. 화면 중앙이 (0, 0)이 되겠죠. OpenGL 이랑 비교하면 y축 방향 바뀌었다고 합니다. NDC를 사용하는 것은 다양한 화면 또는 실행창 크기을 하나의 공통 좌표계에 매핑하기 위함입니다. simple_shader.vert #version 450 vec2 positions[3] = vec2[]( vec2(0.0, -0.5), vec2(0.5, 0.5), vec2(-0.5, 0.5) ); void main() { gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0); } gl_Position: 결과 저장할 변수. built-in output variable gl_VertexIndex 현재 index. built-in variable 요 Vertex Shader 는 각 Vertex 마다 불립니다. ","date":"2021-10-14","objectID":"/2021-10-14_graphics-pipeline/:3:1","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Graphics Pipeline Overview - Vulkan Game Engine Tutorial 02' 정리","uri":"/2021-10-14_graphics-pipeline/#31-vertex-shader-작성"},{"categories":["게임 개발"],"content":" 3.2. fragment shader 작성591s fragment shader는 삼각형 안쪽에 해당하는 각 픽셀에 대해서 불립니다. 아마도 해당 픽셀의 중앙이 삼각형 안쪽에 포함되는지 여부로 갈리는 것 같습니다. ","date":"2021-10-14","objectID":"/2021-10-14_graphics-pipeline/:3:2","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Graphics Pipeline Overview - Vulkan Game Engine Tutorial 02' 정리","uri":"/2021-10-14_graphics-pipeline/#32-fragment-shader-작성"},{"categories":["게임 개발"],"content":" 3.3. SPIR-V 로 컴파일작성한 Shader를 Vulkan에 사용하기 위해서는 Standard Portable Intermediate Representation V (SPIR-V) 형식으로 컴파일 해서 전달해야 합니다. Vulkan SDK 의 glslc.exe 컴파일러를 사용해서 컴파일 해야 합니다. 두 파일을 편하게 컴파일 하기 위해, compile.bat 파일을 준비합니다. ","date":"2021-10-14","objectID":"/2021-10-14_graphics-pipeline/:3:3","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Graphics Pipeline Overview - Vulkan Game Engine Tutorial 02' 정리","uri":"/2021-10-14_graphics-pipeline/#33-spir-v-로-컴파일"},{"categories":["게임 개발"],"content":" 3.4. LvePipeline 클래스 작성일단은 컴파일된 spv 파일을 읽어들여서 사이즈 출력하는 정도의 동작만 합니다. ","date":"2021-10-14","objectID":"/2021-10-14_graphics-pipeline/:3:4","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Graphics Pipeline Overview - Vulkan Game Engine Tutorial 02' 정리","uri":"/2021-10-14_graphics-pipeline/#34-lvepipeline-클래스-작성"},{"categories":["게임 개발"],"content":" 4. 클래스 다이어그램 앱이 시작되면, LvePipeline 생성자에서 shader 파일들을 읽어서 사이즈 출력합니다. ","date":"2021-10-14","objectID":"/2021-10-14_graphics-pipeline/:4:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Graphics Pipeline Overview - Vulkan Game Engine Tutorial 02' 정리","uri":"/2021-10-14_graphics-pipeline/#4-클래스-다이어그램"},{"categories":["게임 개발"],"content":"Youtube Link ","date":"2021-10-13","objectID":"/2021-10-13_opening-a-window/:0:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Opening a window - Vulkan Game Engine Tutorial 01' 정리","uri":"/2021-10-13_opening-a-window/#"},{"categories":["게임 개발"],"content":" 1. 주요 내용 LveWindow 클래스 만듬: glfw 윈도우 캡슐화 FirstApp 클래스 만듬: 앱의 entry 포인트 ","date":"2021-10-13","objectID":"/2021-10-13_opening-a-window/:1:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Opening a window - Vulkan Game Engine Tutorial 01' 정리","uri":"/2021-10-13_opening-a-window/#1-주요-내용"},{"categories":["게임 개발"],"content":" 2. 클래스 다이어그램 특별한 내용 없이, 기존의 셋업 코드에서 위 두 클래스를 만들었습니다. 앱이 실행되면, FirstApp::run() 이 실행됩니다. ","date":"2021-10-13","objectID":"/2021-10-13_opening-a-window/:2:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Opening a window - Vulkan Game Engine Tutorial 01' 정리","uri":"/2021-10-13_opening-a-window/#2-클래스-다이어그램"},{"categories":["게임 개발"],"content":"Vulkan 을 조금은 알아야 해서 스터디 할 자료를 찾아보는데, Brendan Galea의 요 유튜브 시리즈가 그나마 친절한 것 같습니다. Vulkan (c++) Game Engine Tutorials 공식 페이지에도 소개되어 있으니, 어느 정도 인정받는 튜토리얼로 보입니다. 제작자 github에 강좌별 대략적인 내용과 소스 diff 도 제공하고 있습니다. 열심히 따라하면서 이해만 잘~~ 하면ㅠㅜ 될 듯 하네요. 저도 영상 내용을 블로그에 정리해 보면서, Vulkan에 대한 이해도를 높여 보고자 합니다. 첫 번째 영상은 강의 소개 느낌입니다. ","date":"2021-10-12","objectID":"/2021-10-12_vulkan-game-engine-tutorial-intro/:0:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Vulkan Game Engine Tutorial' 정리 시작","uri":"/2021-10-12_vulkan-game-engine-tutorial-intro/#"},{"categories":["게임 개발"],"content":" 00 - Starting PointYoutube link 간략한 Vulkan 소개 강의 소개 간단한 게임 엔진을 만들어 보면서, Vulkan을 이해해보는 강의 당장 게임을 만들고 싶은 거면, 유니티나 언리얼을 보시라 프로젝트 셋업은 Vulkan-Tutorial.com 의 개발 환경 세팅을 사용 ","date":"2021-10-12","objectID":"/2021-10-12_vulkan-game-engine-tutorial-intro/:1:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Vulkan Game Engine Tutorial' 정리 시작","uri":"/2021-10-12_vulkan-game-engine-tutorial-intro/#00-startingpoint"},{"categories":["게임 개발"],"content":" 1. Development environment저의 개발 환경의 아래와 같습니다. Window 10 Visual Studio 2019 Community 버전 (Unity 설치하면 같이 깔리는) 여기에 Vulkan SDK, GLFW, GLM 준비가 필요합니다. Vulkan-Tutorial.com 의 개발 환경 세팅을 보면서 차근차근 따라 합시다. ","date":"2021-10-12","objectID":"/2021-10-12_vulkan-game-engine-tutorial-intro/:2:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Vulkan Game Engine Tutorial' 정리 시작","uri":"/2021-10-12_vulkan-game-engine-tutorial-intro/#1-development-environment"},{"categories":["게임 개발"],"content":" 1.1. Vulkan SDK 설치https://vulkan.lunarg.com/sdk/home 에서 SDK Installer 설치 후, 잘 동작하는지 확인을 위해, Bin 폴더의 vkcube.exe 실행해보기 ","date":"2021-10-12","objectID":"/2021-10-12_vulkan-game-engine-tutorial-intro/:2:1","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Vulkan Game Engine Tutorial' 정리 시작","uri":"/2021-10-12_vulkan-game-engine-tutorial-intro/#11-vulkan-sdk-설치"},{"categories":["게임 개발"],"content":" 1.2. GLFW 다운플랫폼에 따른 윈도우 관련 처리를 위해 필요함. https://www.glfw.org/download.html 에서 64-bit Windows binaries 다운 적당한 곳에 압축 해제 (ex. 내문서 - Visual Studio 2019 밑, C:\\Users\\sshim\\Documents\\Visual Studio 2019\\Libraries) ","date":"2021-10-12","objectID":"/2021-10-12_vulkan-game-engine-tutorial-intro/:2:2","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Vulkan Game Engine Tutorial' 정리 시작","uri":"/2021-10-12_vulkan-game-engine-tutorial-intro/#12-glfw-다운"},{"categories":["게임 개발"],"content":" 1.3. GLM 다운linear algebra(선형대수)를 위해 필요. header only 라이브러리. https://github.com/g-truc/glm/releases/ 에서 최신 버전 다운 적당한 곳에 압축 해제 (ex. 내문서 - Visual Studio 2019 밑, C:\\Users\\sshim\\Documents\\Visual Studio 2019\\Libraries) ","date":"2021-10-12","objectID":"/2021-10-12_vulkan-game-engine-tutorial-intro/:2:3","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Vulkan Game Engine Tutorial' 정리 시작","uri":"/2021-10-12_vulkan-game-engine-tutorial-intro/#13-glm-다운"},{"categories":["게임 개발"],"content":" 1.4. Visual Studio 프로젝트 셋업1. Windows Desktop Wizard 로 새 프로젝트 생성 - Application Type : Console - Empty Project 체크 2. main.cpp 작성 3. project properties 수정해서 라이브러리와 헤더 폴더 추가 - Configuraiton, Platform을 All 로 해두고 수정 - C++ -\u003e General -\u003e Additional Include Directories 에 폴더 추가 . vulkan, glfw 은 include 폴더 . glm 은 glm 폴더 - Linker -\u003e General -\u003e Additional Library Directories 에 폴더 추가 . vulkan 은 Lib 폴더 . glfw 은 lib-vc2019 폴더 - Linker -\u003e Input -\u003e Additional Dependencies 에 라이브러리 추가 . vulkan-1.lib . glfw3.lib - C++ -\u003e Language -\u003e C++ Language Standard 에서 C++17 선택 4. platform 을 x64로 바꾸고 Run ","date":"2021-10-12","objectID":"/2021-10-12_vulkan-game-engine-tutorial-intro/:2:4","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Vulkan Game Engine Tutorial' 정리 시작","uri":"/2021-10-12_vulkan-game-engine-tutorial-intro/#14-visualstudio프로젝트셋업"},{"categories":["게임 개발"],"content":" 99. Reference 유튜브 playlist 저자의 강의 내용 github Vulkan-Tutorial.com 개발 환경 세팅 ","date":"2021-10-12","objectID":"/2021-10-12_vulkan-game-engine-tutorial-intro/:3:0","series":["Vulkan Game Engine Tutorial 정리"],"tags":["vulkan"],"title":"'Vulkan Game Engine Tutorial' 정리 시작","uri":"/2021-10-12_vulkan-game-engine-tutorial-intro/#99-reference"},{"categories":["android"],"content":" 0. 한 줄 요약 특별한 기능이 있는 것은 아니고, 불필요한 변수 선언을 없애고 코드의 가독성을 높이기 위함 비슷한 기능을 하므로, 팀 혹은 프로젝트 단위로 일관된 convention 을 가지고 사용해야 함 막 쓰지 말고, 중첩해서 쓰지 말자 ","date":"2021-08-24","objectID":"/2021-08-24_kotlin-scope-functions/:1:0","series":null,"tags":["kotlin","convention"],"title":"Kotlin에서의 Scope functions (let, run, with, apply, also)","uri":"/2021-08-24_kotlin-scope-functions/#0-한-줄-요약"},{"categories":["android"],"content":" 1. Scope functions?공식 문서의 설명은 아래와 같습니다. The Kotlin standard library contains several functions whose sole purpose is to execute a block of code within the context of an object. When you call such a function on an object with a lambda expression provided, it forms a temporary scope. In this scope, you can access the object without its name. Such functions are called scope functions. There are five of them: let, run, with, apply, and also. Basically, these functions do the same: execute a block of code on an object. What’s different is how this object becomes available inside the block and what is the result of the whole expression. 제한된 scope 를 만들고, 고 안에서 관심있는 object를 이름 없이 갖다 쓰는게 주 목적인 함수라고 생각하면 될 것 같습니다. 아마도 쓸 데없는 변수 선언을 없애서 사이드 이펙트를 줄이고, 해당 코드 블럭을 하나의 expression 으로 간주하기 위함으로 보입니다. 일단 코드를 봅시다. // let 사용 Person(\"Alice\", 20, \"Amsterdam\").let { println(it) it.moveTo(\"London\") it.incrementAge() println(it) } // let 사용하지 않는 경우 val alice = Person(\"Alice\", 20, \"Amsterdam\") println(alice) alice.moveTo(\"London\") alice.incrementAge() println(alice) let 의 예시 입니다. let을 사용하지 않은 코드와 비교해보면, alice 라는 추가 변수를 사용하지 않았고, 블럭 내부에서 it로 Person 객체에 접근하고 있습니다. ","date":"2021-08-24","objectID":"/2021-08-24_kotlin-scope-functions/:2:0","series":null,"tags":["kotlin","convention"],"title":"Kotlin에서의 Scope functions (let, run, with, apply, also)","uri":"/2021-08-24_kotlin-scope-functions/#1-scope-functions"},{"categories":["android"],"content":" 2. 다섯 함수들의 차이 점큰 틀에서 목적은 같아서, 다섯 함수들 모두 동작은 비슷하지만, context object 를 어떻게 접근하는지 어떤 값을 리턴하는지 extension function 인지 그냥 function 인지 가 차이점입니다. Function Object reference Return value Is extension function 비고 let it Lambda result Yes Executing a lambda on non-null objects. Introducing an expression as a variable in local scope run this Lambda result Yes Object configuration and computing the result run - Lambda result No: called without the context object Running statements where an expression is required with this Lambda result No: takes context object as an argument with this object, do the following apply this Context object Yes apply the following assignments to the object also it Context object Yes and also do the following with the object this 로 접근할 수 있다는 것은, 해당 object 의 method나 variable에 이름 없이 바로 접근이 가능하다는 것을 의미합니다. Context object 를 리턴한다는 것은, 자기 자신을 리턴하므로 builder 패턴 처럼 사용 가능합니다. 각 함수들의 예시는 “4. Reference” 의 블로그들에 정리가 잘 되어 있습니다. 한 번 이해하고 나면 나중에 헷갈릴 때 위의 표 (원문 링크)를 참고하면 될 것 같습니다. ","date":"2021-08-24","objectID":"/2021-08-24_kotlin-scope-functions/:3:0","series":null,"tags":["kotlin","convention"],"title":"Kotlin에서의 Scope functions (let, run, with, apply, also)","uri":"/2021-08-24_kotlin-scope-functions/#2-다섯-함수들의-차이-점"},{"categories":["android"],"content":" 3. 권장되는 사용처공식 문서에서 가이드하는 적절한 사용처는 아래와 같습니다. Executing a lambda on non-null objects: let Introducing an expression as a variable in local scope: let Object configuration and computing the result: run Running statements where an expression is required: non-extension run Grouping function calls on an object: with Object configuration: apply Additional effects: also ","date":"2021-08-24","objectID":"/2021-08-24_kotlin-scope-functions/:4:0","series":null,"tags":["kotlin","convention"],"title":"Kotlin에서의 Scope functions (let, run, with, apply, also)","uri":"/2021-08-24_kotlin-scope-functions/#3-권장되는-사용처"},{"categories":["android"],"content":" 4. Reference 코틀린 let, with, run, apply, also 차이 비교 정리 / 블로그 코틀린의 Scope Functions(let, with, run, apply, also)을 알아보자 / 블로그 let을 null check으로 쓰지 마세요 / 블로그 Scope functions / 코틀린 공식 문서 ","date":"2021-08-24","objectID":"/2021-08-24_kotlin-scope-functions/:5:0","series":null,"tags":["kotlin","convention"],"title":"Kotlin에서의 Scope functions (let, run, with, apply, also)","uri":"/2021-08-24_kotlin-scope-functions/#4-reference"},{"categories":["android"],"content":" 한 줄 요약MVVM 에 맞춰서 앱 구조를 잡도록 하자. ","date":"2021-08-22","objectID":"/2021-08-22_android-app-architecture/:1:0","series":null,"tags":["android","architecture"],"title":"안드로이드에서의 MVC, MVP, MVVM","uri":"/2021-08-22_android-app-architecture/#한-줄-요약"},{"categories":["android"],"content":" 들어가며안드로이드에서 권장되는 앱 아키텍처는 아래의 모습입니다. MVVM (Model - View - ViewModel) 패턴을 기본으로 하고 있습니다. 요 MVVM 패턴을 권장하기 전에는 특별한 가이드가 없었고, MVC, MVP 패턴이 많이 쓰였다고 합니다. 안드로이드에서 MVC, MVP, MVVM 패턴을 각각 적요하면 어떻게 구현이 되는지 정리해 준 블로그가 있어서, 다이어그램을 그리면서 따라가 보았습니다. ","date":"2021-08-22","objectID":"/2021-08-22_android-app-architecture/:2:0","series":null,"tags":["android","architecture"],"title":"안드로이드에서의 MVC, MVP, MVVM","uri":"/2021-08-22_android-app-architecture/#들어가며"},{"categories":["android"],"content":" MVC Activity가 Controller 역할 Controller 쪽 TC 만들기가 애매함 Controller가 비대해지기 쉬움 간단한 프로그램에 적합 ","date":"2021-08-22","objectID":"/2021-08-22_android-app-architecture/:3:0","series":null,"tags":["android","architecture"],"title":"안드로이드에서의 MVC, MVP, MVVM","uri":"/2021-08-22_android-app-architecture/#mvc"},{"categories":["android"],"content":" MVP Activity가 View 역할 Presenter 에는 안드로이드 API 사용이 없는 것이 좋음 Presenter 테스트가 용이해 짐 TicTackToeView 만 mocking 혹은 fake 객체 만들면 됨 Presenter가 비대해지기 쉬움 ","date":"2021-08-22","objectID":"/2021-08-22_android-app-architecture/:4:0","series":null,"tags":["android","architecture"],"title":"안드로이드에서의 MVC, MVP, MVVM","uri":"/2021-08-22_android-app-architecture/#mvp"},{"categories":["android"],"content":" MVVM 의존 관계가 한 방향으로만 있음 모듈화와 테스트가 용이함 Data Binding을 사용하면 View 코드가 간결해짐 ViewModel, LiveData 사용함으로써 Lifecycle 관련 처리도 같이 ","date":"2021-08-22","objectID":"/2021-08-22_android-app-architecture/:5:0","series":null,"tags":["android","architecture"],"title":"안드로이드에서의 MVC, MVP, MVVM","uri":"/2021-08-22_android-app-architecture/#mvvm"},{"categories":["android"],"content":" Reference Guide to ap architecture / 안드로이드 공식 문서 MVC vs. MVP vs. MVVM on Android_Eric Maxwell_2017-01-26 위 글의 한글 버전 위 글에서 사용한 소스 코드 / Github ","date":"2021-08-22","objectID":"/2021-08-22_android-app-architecture/:6:0","series":null,"tags":["android","architecture"],"title":"안드로이드에서의 MVC, MVP, MVVM","uri":"/2021-08-22_android-app-architecture/#reference"},{"categories":["android"],"content":" Android Studio 에서 코드를 작성하다 보면 습관적으로 Reformat Code (Ctrl+Alt+L) 기능을 통해 코드 정리를 하게 됩니다. 기본 세팅 상태도 훌륭하기는 하지만, 협업 상황을 고려한다면 좀 더 strict하고 일관성 있게 제한하는 게 좋습니다. 이를 위해서 ktlint를 적용해 봅시다. ktlint 파일을 다운로드 받아서 커맨드를 실행해주면, 해당 프로젝트의 .idea 밑의 설정 파일들을 수정해 줍니다. ","date":"2021-08-21","objectID":"/2021-08-21_ktlint/:0:0","series":null,"tags":["android","kotlin","lint"],"title":"Android Studio 프로젝트에 ktlint 적용","uri":"/2021-08-21_ktlint/#"},{"categories":["android"],"content":" 프로젝트에 ktlint 설정 방법 ktlint 다운로드 https://github.com/pinterest/ktlint/releases 에서 ktlint 파일 다운로드 프로젝트 루트 폴더에서 ktlint 커맨드 실행 # 윈도우 $ java -jar [다운받은 ktlint 파일 경로] --android applyToIDEAProject # 필자의 경우 (Windows Terminal) $ pwd # 프로젝트 루트 폴더로 이동 C:\\workspace_android\\ellas-notes $ ls ../ktlint # ktlint 는 상위 폴더에 저장해 두었음 -a---- 2021-08-19 오후 5:25 55496103 ktlint # java path가 따로 안 잡혀 있는 관계로 java도 경로까지 써서 $ \"C:\\Program Files\\android-studio\\jre\\bin\\java\" -jar ..\\ktlint --android applyToIDEAProject ","date":"2021-08-21","objectID":"/2021-08-21_ktlint/:1:0","series":null,"tags":["android","kotlin","lint"],"title":"Android Studio 프로젝트에 ktlint 적용","uri":"/2021-08-21_ktlint/#프로젝트에-ktlint-설정-방법"},{"categories":["android"],"content":" Reference https://github.com/pinterest/ktlint#-with-intellij-idea ","date":"2021-08-21","objectID":"/2021-08-21_ktlint/:2:0","series":null,"tags":["android","kotlin","lint"],"title":"Android Studio 프로젝트에 ktlint 적용","uri":"/2021-08-21_ktlint/#reference"},{"categories":["android"],"content":"안드로이드 개발자 문서의 App startup time (https://developer.android.com/topic/performance/vitals/launch-time) 페이지 내용 요약입니다. ","date":"2021-04-05","objectID":"/2021-04-05_app-startup-time/:0:0","series":null,"tags":["android","performance"],"title":"'App startup time' 요약","uri":"/2021-04-05_app-startup-time/#"},{"categories":["android"],"content":" 0. 요약 정리","date":"2021-04-05","objectID":"/2021-04-05_app-startup-time/:1:0","series":null,"tags":["android","performance"],"title":"'App startup time' 요약","uri":"/2021-04-05_app-startup-time/#0-요약-정리"},{"categories":["android"],"content":" 0.1 프로파일링 “Displayed|Fully drawn” 으로 logcat 확인 Android Studio의 Profiler의 “Start this recording on startup” 기능 활용해서 method sampling 직접 Trace 할 부분 지정해 놓고, Perfferto 로 확인 ","date":"2021-04-05","objectID":"/2021-04-05_app-startup-time/:1:1","series":null,"tags":["android","performance"],"title":"'App startup time' 요약","uri":"/2021-04-05_app-startup-time/#01-프로파일링"},{"categories":["android"],"content":" 0.2 주요 해결책 별도의 쓰레드 사용 (Running Android tasks in background threads) 뷰 계층 간소화 Hilt 사용 App Startup library 사용 스플래시 스크린 사용 ","date":"2021-04-05","objectID":"/2021-04-05_app-startup-time/:1:2","series":null,"tags":["android","performance"],"title":"'App startup time' 요약","uri":"/2021-04-05_app-startup-time/#02-주요-해결책"},{"categories":["android"],"content":" 1. Understand app-start internals앱 런치는 세 가지 종류가 있습니다. Cold는 맨 땅에서 시작하는 것이고, 나머지 둘은 백그라운드에서 돌고 있는 앱을 foreground로 가져옵니다. 최적화 작업은 cold start 상황을 염두하고 진행하세요. cold start를 최적화하면, warm/hot start도 빨라집니다. ","date":"2021-04-05","objectID":"/2021-04-05_app-startup-time/:2:0","series":null,"tags":["android","performance"],"title":"'App startup time' 요약","uri":"/2021-04-05_app-startup-time/#1-understand-app-start-internals"},{"categories":["android"],"content":" 1.1 Cold start부팅 후 첫 실행이거나, kill 된 후 처음으로 실행하는 경우입니다. cold start가 시작되면, 시스템은 아래 3가시 task를 수행합니다. Loading and launching the app. Displaying a blank starting window for the app immediately after launch Creating app process 앱 프로세스는 다음 단계를 실행합니다. Creating the app object Launching the main thread Creating the main activity Inflating views Laying out the screen. Performing the initial draw. 앱이 첫 draw를 완료하면, 시스템은 현재 표시되고 있는 background window를 main activity로 swap 합니다. 이 때부터 유저가 앱을 사용할 수 있습니다. 성능 이슈는 app 생성과 activity 생성때 발생할 수 있습니다. 🔷 Application creation Application.onCreate()를 override 했을 경우, 시스템이 해당 onCreate()를 호출합니다. 그 후에, 앱이 main thread(UI thread)를 생성하고, 이 스레드를 통해 main activity를 만듭니다. 이 때부터, app lifecycle stages에 따라 진행됩니다. 🔷 Activity creation 앱 프로세스가 activity를 만들어지면, activity는 다음 동작을 수행합니다. Initializes values. Calls constructors. Calls the callback method, such as Activity.onCreate() 보통, 요 onCreate() 에서 오버헤드가 높은 작업(loading and inflating views, and initializing objects 등)을 수행하므로, load time에 가장 큰 영향을 미치는 부분입니다. ","date":"2021-04-05","objectID":"/2021-04-05_app-startup-time/:2:1","series":null,"tags":["android","performance"],"title":"'App startup time' 요약","uri":"/2021-04-05_app-startup-time/#11-cold-start"},{"categories":["android"],"content":" 1.2 Hot startactivity가 아직 메모리에 있는 상태라서, foreground로 가져오기만 하면 되는 경우입니다. ","date":"2021-04-05","objectID":"/2021-04-05_app-startup-time/:2:2","series":null,"tags":["android","performance"],"title":"'App startup time' 요약","uri":"/2021-04-05_app-startup-time/#12-hot-start"},{"categories":["android"],"content":" 1.3 Warm starthot start는 아닌데, cold start의 일부만 하면 되는 경우 앱에서 나왔다가 re-launch 시스템이 앱을 메모리에서 제거했는데, 유저가 re-launch한 경우. process와 activity는 재시작해야 하지만 saved instance state bundle 이 onCreate()에서 활용됨 ","date":"2021-04-05","objectID":"/2021-04-05_app-startup-time/:2:3","series":null,"tags":["android","performance"],"title":"'App startup time' 요약","uri":"/2021-04-05_app-startup-time/#13-warm-start"},{"categories":["android"],"content":" 2. Detect and diagnose problems","date":"2021-04-05","objectID":"/2021-04-05_app-startup-time/:3:0","series":null,"tags":["android","performance"],"title":"'App startup time' 요약","uri":"/2021-04-05_app-startup-time/#2-detect-and-diagnose-problems"},{"categories":["android"],"content":" 2.1 Android vitals다음과 같은 경우에 시작 시간이 너무 긴것으로 간주하고, 리포트 해줌 cold start 5초 이상 warm start 2초 이상 hot start 1.5초 이상 ","date":"2021-04-05","objectID":"/2021-04-05_app-startup-time/:3:1","series":null,"tags":["android","performance"],"title":"'App startup time' 요약","uri":"/2021-04-05_app-startup-time/#21-android-vitals"},{"categories":["android"],"content":" 2.2 Diagnosing slow startup times🔷 Time to initial display “Displayed” 로 logcat을 필터링하면, 맨 처음 그릴 때까지의 시간 출력됨 아래 내용들이 포함됨 Launch the process. Initialize the objects. Create and initialize the activity. Inflate the layout. Draw your application for the first time. logcat 예시 ActivityManager: Displayed com.android.myexample/.StartupTiming: +3s534ms adb로 실행해서 시간 측정 adb [-d|-e|-s \u003cserialNumber\u003e] shell am start -S -W com.example.app/.MainActivity -c android.intent.category.LAUNCHER -a android.intent.action.MAIN Starting: Intent Activity: com.example.app/.MainActivity ThisTime: 2044 TotalTime: 2044 WaitTime: 2054 Complete 🔷 Time to full display lazy loading을 하는 상황에서도 의미 있는 시간을 측정하기 위해서, reportFullyDrawn() 을 호출해 주면 됩니다. 아래와 같이 Fully drawn 로그를 출력해 줍니다. system_process I/ActivityManager: Fully drawn {package}/.MainActivity: +1s54ms 🔷 Identifying bottlenecks 아래 도구를 활용하세요. Android Studio의 CPU Profiler Record CPU activity during app startup Perffeto Capture a system trace on a device ","date":"2021-04-05","objectID":"/2021-04-05_app-startup-time/:3:2","series":null,"tags":["android","performance"],"title":"'App startup time' 요약","uri":"/2021-04-05_app-startup-time/#22-diagnosing-slow-startup-times"},{"categories":["android"],"content":" 3. Be aware of common issues","date":"2021-04-05","objectID":"/2021-04-05_app-startup-time/:4:0","series":null,"tags":["android","performance"],"title":"'App startup time' 요약","uri":"/2021-04-05_app-startup-time/#3-be-aware-of-common-issues"},{"categories":["android"],"content":" 3.1 Heavy app initialization🔷 해결책 lazy initialization Hilt 같은 dependency injection framework 사용 (처음 inject될 때, 객체들과 디펜던시들 생성) App Startup library 사용 ","date":"2021-04-05","objectID":"/2021-04-05_app-startup-time/:4:1","series":null,"tags":["android","performance"],"title":"'App startup time' 요약","uri":"/2021-04-05_app-startup-time/#31-heavy-app-initialization"},{"categories":["android"],"content":" 3.2 Heavy activity initialization🔷 주요 이슈들 Inflating large or complex layouts. Blocking screen drawing on disk, or network I/O. Loading and decoding bitmaps. Rasterizing [VectorDrawable](https://developer.android.com/reference/android/graphics/drawable/VectorDrawable) objects. Initialization of other subsystems of the activity. 🔷 해결책 뷰 계층 구조 간소화 ViewStub 객체 활용 (UI중 시작할 때 표시할 필요가 없는 부분은 나중에) 다른 쓰레드 활용 ","date":"2021-04-05","objectID":"/2021-04-05_app-startup-time/:4:2","series":null,"tags":["android","performance"],"title":"'App startup time' 요약","uri":"/2021-04-05_app-startup-time/#32-heavy-activity-initialization"},{"categories":["android"],"content":" 3.3 Themed launch screensThemed launch screen 을 사용해서, 좀 더 부드럽게 보여질 수 있음 Material Design patterns 를 따르는 것을 추천함. Activity에 windowBackground theme attribute를 지정하면, 스플래시 이미지를 지정할 수 있음. 참고: https://velog.io/@pish11010/Android-Splash-Screen-구현 splash.xml (drawable) \u003clayer-list xmlns:android=\"http://schemas.android.com/apk/res/android\" android:opacity=\"opaque\"\u003e \u003c!-- The background color, preferably the same as your normal theme --\u003e \u003citem android:drawable=\"@android:color/white\"/\u003e \u003c!-- Your product logo - 144dp color version of your app icon --\u003e \u003citem\u003e \u003cbitmap android:src=\"@drawable/product_logo_144dp\" android:gravity=\"center\"/\u003e \u003c/item\u003e \u003c/layer-list\u003e theme.xml \u003cstyle name=\"SplashTheme\" parent=\"Theme.AppCompat.NoActionBar\"\u003e \u003citem name=\"android:windowBackground\"\u003e@drawable/splash\u003c/item\u003e \u003c/style\u003e manifest \u003cactivity ... android:theme=\"@style/SplashTheme\" /\u003e Activity class MyMainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { // Make sure this is before calling super.onCreate setTheme(R.style.Theme_MyApp) super.onCreate(savedInstanceState) // ... } } ","date":"2021-04-05","objectID":"/2021-04-05_app-startup-time/:4:3","series":null,"tags":["android","performance"],"title":"'App startup time' 요약","uri":"/2021-04-05_app-startup-time/#33-themed-launch-screens"},{"categories":["android"],"content":"스터디 하면서 샘플 프로젝트 따라 해보다가, 조금 된 예제를 따라하다보니 뭔가 theme 관련해서 마음대로 안되는 상황이 왔습니다. 찾다보니 요 시리즈를 알아두면 되겠다 싶네요. 아래 포스트를 번역한 내용입니다.(안드로이드 공식 블로그인듯 합니다.) Android Stylling: prefer theme attributes ","date":"2021-02-27","objectID":"/2021-02-27_prefer-theme-attributes/:0:0","series":null,"tags":["android","theme"],"title":"'Android Styling: prefer theme attributes' 번역","uri":"/2021-02-27_prefer-theme-attributes/#"},{"categories":["android"],"content":" Android Styling: prefer theme attributesAndroid styling에 관한 이 시리즈의 지난 포스트들에서, theme과 style의 차이점을 알아봤고, theme과 theme attribute들을 통해 변화를 줘야할 부분들을 별도로 분리하는 게 왜 좋은지 알아 봤습니다. Android Styling: Themes vs Styles Android Styling: Common Theme Attributes 이것은 변경을 theme으로 한정하고, 더 적은 layout과 style만 유지해도 되게 합니다. 실전에서, theme별로 색을 다르게 해야 하는 경우가 대부분이고, 이 때 항상* theme attribute를 참조해야 합니다. Always* refer to colors via theme attributes 즉, 아래 코드는 문제가 될 수 있습니다. \u003c!-- Copyright 2019 Google LLC. SPDX-License-Identifier: Apache-2.0 --\u003e \u003cView … android:background=\"@color/white\"/\u003e 대신에 theme attribute를 참조해야 합니다. 그래야 theme별로 색상에 변화를 줄 수 있습니다. 예를 들면 dark theme에서 다른 값을 제공할 수 있죠. \u003c!-- Copyright 2019 Google LLC. SPDX-License-Identifier: Apache-2.0 --\u003e \u003cView … android:background=\"?attr/colorSurface\"/\u003e 만드시는 앱이 아직 다른 theme을 지원하지 않더라도(아직 dark theme이 없어요?), 테마 작업을 훨씬 쉽게 해줄 이 접근법을 추천 합니다. ","date":"2021-02-27","objectID":"/2021-02-27_prefer-theme-attributes/:1:0","series":null,"tags":["android","theme"],"title":"'Android Styling: prefer theme attributes' 번역","uri":"/2021-02-27_prefer-theme-attributes/#android-styling-prefer-theme-attributes"},{"categories":["android"],"content":" Qualified Colors?다른 설정에 다른 값을 제공하는 것으로도 색상에 변화를 줄 수 있습니다. (e.g. @color/foo를 res/values/colors.xml과 res/values-night/colors.xml에 각각 정의) 하지만, theme attribute를 쓰는걸 추천합니다. color 계층의 변화를 주려면 의미있는 이름(semantic name) 을 부여해야 합니다. 즉, @color/white라고 이름지은 색을 -night 설정의 어두운 색으로 제공하지는 않을 겁니다 — 요렇게 하면 좀 헷갈릴 겁니다. 대신에 @color/background같은 semantic name을 쓰고 싶을 겁니다. 그런데, 이렇게 하면 색깔 선언과 값 제공이 같이 있다는 문제가 있습니다. 따라서 요건 theme별로 변화를 줄 수 없죠. 또한, @colors에 변화를 주려면 보다 많은 색을 만들어야 합니다. 다른 상황이라서 실제 색이 같더라도 새로운 이름을 부여한다면(i.e. background는 아니지만 같은 색), 그래도 colors 파일에 entry를 추가해야 합니다. theme attribute를 사용함으로써 semantic color의 선언을 실제 값 제공 부분과 분리할 수 있습니다. 호출부도 깔끔해지고 실제 색은 theme에 의해서 달라지죠 (?attr/ 구문 사용). 색 선언을 문자 그대로의 값(literally named values)으로 유지함으로써, 사용할 색상들을 미리 정의하고 theme 레벨에서 변화를 주는게 편리해 집니다. Define a palette of colors used by your app and vary them at the theme level 이 접근의 부가적인 이점은 이 색상들을 참조하는 layout과 style들의 재사용성이 좋아진다는 것입니다. theme은 overlaid 혹은 varied 될 수 있기에, 색상 변화를 위한 별도의 layout이나 style을 추가로 만들 필요가 없게 되지요 — 다른 theme에서 같은 layout을 사용할 수 있습니다. ","date":"2021-02-27","objectID":"/2021-02-27_prefer-theme-attributes/:2:0","series":null,"tags":["android","theme"],"title":"'Android Styling: prefer theme attributes' 번역","uri":"/2021-02-27_prefer-theme-attributes/#qualified-colors"},{"categories":["android"],"content":" Always?theme에 의해 색상 변화를 주고 싶지 않은 상황도 있기에, “always* refer to colors via theme attributes” 에 별표를 붙였습니다. 예를 들어, Material Design guidelines 에서 light theme과 dark theme에서 같은 brand color를 사용하는 경우를 보여줍니다. 이런 드문 경우에 대해서는, color resource를 바로 참조하는 것도 괜찮습니다. \u003c!-- Copyright 2019 Google LLC. SPDX-License-Identifier: Apache-2.0 --\u003e \u003cFloatingActionButton … app:backgroundTint=\"@color/owl_pink_500\"/\u003e ","date":"2021-02-27","objectID":"/2021-02-27_prefer-theme-attributes/:3:0","series":null,"tags":["android","theme"],"title":"'Android Styling: prefer theme attributes' 번역","uri":"/2021-02-27_prefer-theme-attributes/#always"},{"categories":["android"],"content":" State of the artlayout/style에서 theme attribute를 사용하지 않을 수 있는 또 다른 상황은 ColorStateList들을 사용할 때 입니다. \u003c!-- Copyright 2019 Google LLC. SPDX-License-Identifier: Apache-2.0 --\u003e \u003cView … android:background=\"@color/primary_20\"/\u003e 요것도 primary_20이 ColorStateList(내부적으로 theme attribute를 참조)라면 괜찮습니다 (아래 코드 참조). ColorStateList가 보통은 상태(pressed, disabled etc)에 따라 다른 색상을 나타내기 위해 사용되지만, 테마 작업에도 유용합니다. 알파 값을 지정할 수 있지요. \u003c!-- Copyright 2019 Google LLC. SPDX-License-Identifier: Apache-2.0 --\u003e \u003cselector … \u003citem android:alpha=\"0.20\" android:color=\"?attr/colorPrimary\" /\u003e \u003c/selector\u003e 이런 종류의 single-item-ColorStateList (i.e. 한 가지 색만 존재함)는 유지해야할 color 리소스를 줄이는데 도움이 됩니다. primary color와 알파 값이 다른 별도의 색을 따로 정의하지 않고도 (per configuration!), 현재 theme의 colorPrimary이 뭐든지 간에 이를 대체할 수 있습니다. 만약 primary color가 바뀌면, 그냥 한 군데만 바꾸면 됩니다. 변경되어야할 모든 부분들을 추적할 필요가 없는거죠. 요게 유용하지만, 알아둬야할 몇 가지 경고사항이 있습니다. 정의된 색도 알파 값을 가지면, 두 알파 값들은 조합됩니다. e.g. 50% 알파를 50% 불투명한 흰색에 적용하면 25% 흰색이 됩니다. \u003c!-- Copyright 2019 Google LLC. SPDX-License-Identifier: Apache-2.0 --\u003e \u003cselector … \u003citem android:alpha=\"0.50\" android:color=\"#80ffffff\" /\u003e \u003c/selector\u003e 그래서, theme color는 완전 불투명한(fully opaque) 색으로 지정하고, 알파 값 조정은 ColorStateList로 하는 게 좋습니다. alpha component는 API 23에서 추가되었습니다. min SDK가 더 낮다면, 이 동작의 백포트를 위해서 AppCompatResources.getColorStateList를 사용하셔야 합니다. (추가로 항상 android:alpha namespace를 사용해야 함. app:alpha namespace 말고) 가끔 아래 코드처럼 color를 drawable 자리에 사용하기도 합니다. \u003c!-- Copyright 2019 Google LLC. SPDX-License-Identifier: Apache-2.0 --\u003e \u003cView … android:background=\"@color/foo\"/\u003e View의 backgroud는 drawable이고, 이 편법은 해당 color를 ColorDrawable로 변환합니다. 하지만 ColorStateList는 Drawable로 변환할 방법이 없었습니다. (API 29에서 요 이슈 해결을 위해 ColorStateListDrawable이 도입됨) 요 제약사항은 아래처럼 우회할 수 있습니다. \u003c!-- Copyright 2019 Google LLC. SPDX-License-Identifier: Apache-2.0 --\u003e \u003cView … android:background=\"@drawable/a_solid_white_rectangle_shape_drawable\" app:backgroundTint=\"@color/some_color_state_list\"/\u003e background tint가 해당 view 에서 요구하는 state들을 지원하는지 잘 확인해야 합니다. (예: disabled 되었을 때 바뀌어야 하는지) ","date":"2021-02-27","objectID":"/2021-02-27_prefer-theme-attributes/:4:0","series":null,"tags":["android","theme"],"title":"'Android Styling: prefer theme attributes' 번역","uri":"/2021-02-27_prefer-theme-attributes/#state-of-the-art"},{"categories":["android"],"content":" Enforcementtheme attribute와 ColorStateList를 사용해야 한다고 납득했다고 하더라도, 코드 전체 혹은 팀 전체에 강제하려면 어떻게 해야 할까요? 코드 리뷰를 꼼꼼히 하려고 노력할 수 있겠지만, 잘 되지 않죠. 더 좋은 접근법은 요걸 확인할 수 있는 툴을 사용하는 것입니다. 아래 글은 literal color 사용을 어떻게 lint check에 추가하는지 설명하고 있고, 이번 글에서 다룬 내용들에도 적용될 수 있습니다. https://proandroiddev.com/making-android-lint-theme-aware-6285737b13bc ","date":"2021-02-27","objectID":"/2021-02-27_prefer-theme-attributes/:5:0","series":null,"tags":["android","theme"],"title":"'Android Styling: prefer theme attributes' 번역","uri":"/2021-02-27_prefer-theme-attributes/#enforcement"},{"categories":["android"],"content":" Be Indirecttheme attribute와 ColorStateList를 사용해서 color를 theme으로 뽑아 내는 것은, layout과 style을 더욱 더 유연하게 합니다. 재사용성을 높이고, 코드 베이스를 간결하고 유지보수가 용이하게 유지시켜 주죠. 다음 포스트에서는 theme 사용과 상호작용을 더 알아봅시다. Android Styling: themes overlay ","date":"2021-02-27","objectID":"/2021-02-27_prefer-theme-attributes/:6:0","series":null,"tags":["android","theme"],"title":"'Android Styling: prefer theme attributes' 번역","uri":"/2021-02-27_prefer-theme-attributes/#be-indirect"},{"categories":["투자 일반"],"content":"요즘 강환국 형님의 ‘할수있다 알고투자’ 채널을 열심히 시청하고 있습니다. 주요 영상들을 제대로 이해하고자 정리해 봅니다. 485. (투자입문) 안전자산이란 존재하는가? www.youtube.com/watch?v=Y1x16sIFMDQ ","date":"2021-02-27","objectID":"/2021-02-27_halto-485/:0:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '485. (투자입문) 안전자산이란 존재하는가?' 정리","uri":"/2021-02-27_halto-485/#"},{"categories":["투자 일반"],"content":" 오늘의 말씀 Note 분산투자(자산배분) + 편견버리기가 정답! ","date":"2021-02-27","objectID":"/2021-02-27_halto-485/:1:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '485. (투자입문) 안전자산이란 존재하는가?' 정리","uri":"/2021-02-27_halto-485/#오늘의-말씀"},{"categories":["투자 일반"],"content":" 핵심 요약 및 첨언 Note 안전 자산은 없습니다. 고로 자산배분을 해야 합니다. (영구포트폴리오로 시작하세요.) 여러 나라로의 분산도 필요합니다. ","date":"2021-02-27","objectID":"/2021-02-27_halto-485/:2:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '485. (투자입문) 안전자산이란 존재하는가?' 정리","uri":"/2021-02-27_halto-485/#핵심-요약-및-첨언"},{"categories":["투자 일반"],"content":" 1. 들어가며 - 자산군에 대한 편견0:20 ","date":"2021-02-27","objectID":"/2021-02-27_halto-485/:3:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '485. (투자입문) 안전자산이란 존재하는가?' 정리","uri":"/2021-02-27_halto-485/#1-들어가며---자산군에-대한-편견"},{"categories":["투자 일반"],"content":" 2. 주식도 장기적으로 안전하지 않음0:42 주식은 엄청나게 리스크가 높은 자산군 (111. [초보] 주식 vs 예금, 수익이 더 높은 투자는?) (인수 합병도 있겠지만) 1/3이 없어짐 미국에서 10년 보유했을 때, 수익나는 종목은 겨우 56.3% 수익의 상당 부분의 소수 기업에 집중됨 (승자독식) ","date":"2021-02-27","objectID":"/2021-02-27_halto-485/:4:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '485. (투자입문) 안전자산이란 존재하는가?' 정리","uri":"/2021-02-27_halto-485/#2-주식도-장기적으로-안전하지-않음"},{"categories":["투자 일반"],"content":" 3. 암호화폐 - 더 위험3:08 변동성 엄청남 장기적 우상향이 검증되지 않았고, 너무 성공하면 정부에서 때릴 가능성 ","date":"2021-02-27","objectID":"/2021-02-27_halto-485/:5:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '485. (투자입문) 안전자산이란 존재하는가?' 정리","uri":"/2021-02-27_halto-485/#3-암호화폐---더-위험"},{"categories":["투자 일반"],"content":" 4. 현금(예금, 적금)도 안전하지 않음3:49 현금의 가치는 언젠가 0이 됨 (예외 없음) ","date":"2021-02-27","objectID":"/2021-02-27_halto-485/:6:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '485. (투자입문) 안전자산이란 존재하는가?' 정리","uri":"/2021-02-27_halto-485/#4-현금예금-적금도-안전하지-않음"},{"categories":["투자 일반"],"content":" 5. 채권도 위험6:07 파산하는 국가들이 은근히 많음 ","date":"2021-02-27","objectID":"/2021-02-27_halto-485/:7:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '485. (투자입문) 안전자산이란 존재하는가?' 정리","uri":"/2021-02-27_halto-485/#5-채권도-위험"},{"categories":["투자 일반"],"content":" 6. 금도 위험7:58 변동성이 작지 않음 ","date":"2021-02-27","objectID":"/2021-02-27_halto-485/:8:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '485. (투자입문) 안전자산이란 존재하는가?' 정리","uri":"/2021-02-27_halto-485/#6-금도-위험"},{"categories":["투자 일반"],"content":" 7. 부동산도 안전하지 않음8:51 재산권 행사 어려움 ","date":"2021-02-27","objectID":"/2021-02-27_halto-485/:9:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '485. (투자입문) 안전자산이란 존재하는가?' 정리","uri":"/2021-02-27_halto-485/#7-부동산도-안전하지-않음"},{"categories":["투자 일반"],"content":" 8. 모든 자산에 올 수 있는 재앙10:19 전쟁 케이스도 생각은 해둬야 함 ","date":"2021-02-27","objectID":"/2021-02-27_halto-485/:10:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '485. (투자입문) 안전자산이란 존재하는가?' 정리","uri":"/2021-02-27_halto-485/#8-모든-자산에-올-수-있는-재앙"},{"categories":["투자 일반"],"content":" 9. 요약11:38 Note 분산투자(자산배분) + 편견 버리기가 정답! 각 자산은 위험하지만, 섞으면 위험 급감 (영구포트폴리오, 477. (투자 입문) 투자는 쉽다! 무난하게 복리 8% 버는 방법!) 자산군 내에서도 가능하면 종목 + 지리적 분산투자! 중요! 절대 한 정부가 전 재산을 통제하는 상황이 오면 안됨 (해외 부동산, 해외 금, 암호화폐) 우리에겐 부동산과 원화가 정부 리스크에 제일 취약 ","date":"2021-02-27","objectID":"/2021-02-27_halto-485/:11:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '485. (투자입문) 안전자산이란 존재하는가?' 정리","uri":"/2021-02-27_halto-485/#9-요약"},{"categories":["android"],"content":"스터디 하면서 샘플 프로젝트 따라 해보다가, 조금 된 예제를 따라하다보니 뭔가 theme 관련해서 마음대로 안되는 상황이 왔습니다. 찾다보니 요 시리즈를 알아두면 되겠다 싶네요. 아래 포스트를 번역한 내용입니다.(안드로이드 공식 블로그인듯 합니다.) Android styling: common theme attributes ","date":"2021-02-22","objectID":"/2021-02-22_common-theme-attributes/:0:0","series":null,"tags":["android","theme"],"title":"'Android styling: common theme attributes' 번역","uri":"/2021-02-22_common-theme-attributes/#"},{"categories":["android"],"content":" Android styling: common theme attributes이전 포스트에서 themes와 styles의 차이점과 themes를 이용해서 유연한 style와 layout을 작성하는 방법을 알아보았습니다. 구체적으로 theme attributes를 사용해서 리소스에 접근하는 걸 추천했습니다. 이렇게 함으로써 실제 값을 다르게 할 수 있습니다. (e.g. in dark theme). 즉, 아직 layout이나 style에서 리소스를 직접 접근해서 쓰고 있다면(혹은, 하드 코딩된 값을 쓰고 있다면ㅠㅜ), theme attribute를 쓰는 걸 고려하시기 바랍니다. \u003c!-- Copyright 2019 Google LLC. SPDX-License-Identifier: Apache-2.0 --\u003e \u003cConstraintLayout ... - android:foreground=\"@drawable/some_ripple\" - android:background=\"@color/blue\" /\u003e + android:foreground=\"?attr/selectableItemBackground\" + android:background=\"?attr/colorPrimarySurface\" /\u003e gist link 그럼 어떤 theme attribute들이 있을까요? 이번 포스트에서 알아둬야할 자주 쓰이는 theme attribute들을 알아봅시다. Material, AppCompat, platform에서 선언된 애들입니다. 전체 리스트는 아니지만(전체 리스트를 확인하려면 attrs 파일을 확인해보시길 바랍니다.), 제가 항상 쓰는 attribute들입니다. ","date":"2021-02-22","objectID":"/2021-02-22_common-theme-attributes/:1:0","series":null,"tags":["android","theme"],"title":"'Android styling: common theme attributes' 번역","uri":"/2021-02-22_common-theme-attributes/#android-styling-common-theme-attributes"},{"categories":["android"],"content":" Colors이 색깔들은 Material color system에서 왔습니다. 앱 전반에서 쓸 수 있는 의미있는 이름을 부여하고 있죠. (theme attrs 로 구현되어 있음) ?attr/colorPrimary 앱의 브랜드 색상 ?attr/colorSecondary 앱의 두 번째 브랜드 색상. 보통 브랜드 색상의 보색임 ?attr/colorOn[Primary, Secondary, Surface etc] 각 색상에 대비되는 색 ?attr/color[Primary, Secondary]Variant 각 색상에서 약간의 변화 ?attr/colorSurface 컴포넌트들(e.g. cards, sheets, menus)의 바탕을 위한 색 ?android:attr/colorBackground 화면의 바탕색 ?attr/colorPrimarySurface Light themes에서는 colorPrimary, Dark theme 에서는 colorSurface. ?attr/colorError 에러 표시를 위한 색 추가로 도움이 되는 색 ?attr/colorControlNormal icons/controls이 보통 상태일때 적용되는 색 ?attr/colorControlActivated icons/controls이 활성 상태일때 적용되는 색 (e.g. checked). ?attr/colorControlHighlight control 강조를 위해 적용되는 색 (e.g. ripples, list selectors). ?android:attr/textColorPrimary 가장 눈에 띄는 글자 색 ?android:attr/textColorSecondary 두번 째 글자 색 ","date":"2021-02-22","objectID":"/2021-02-22_common-theme-attributes/:2:0","series":null,"tags":["android","theme"],"title":"'Android styling: common theme attributes' 번역","uri":"/2021-02-22_common-theme-attributes/#colors"},{"categories":["android"],"content":" Dimens ?attr/listPreferredItemHeight 리스트 아이템의 (최소) 높이 ?attr/actionBarSize 툴바의 높이 ","date":"2021-02-22","objectID":"/2021-02-22_common-theme-attributes/:3:0","series":null,"tags":["android","theme"],"title":"'Android styling: common theme attributes' 번역","uri":"/2021-02-22_common-theme-attributes/#dimens"},{"categories":["android"],"content":" Drawables ?attr/selectableItemBackground ripple/highlight 효과가 필요한 아이템 (전경에도 유용함!!) ?attr/selectableItemBackgroundBorderless ripple 효과 필요한 경계선 없는 아이템. ?attr/dividerVertical 요소들을 수직으로 나눌 때 사용 ?attr/dividerHorizontal 요소들을 수평으로 나눌 때 사용 ","date":"2021-02-22","objectID":"/2021-02-22_common-theme-attributes/:4:0","series":null,"tags":["android","theme"],"title":"'Android styling: common theme attributes' 번역","uri":"/2021-02-22_common-theme-attributes/#drawables"},{"categories":["android"],"content":" TextAppearancesMaterial Design에는 Type scale이 정의되어 있습니다. 앱 전반에서 사용할 텍스트 스타일들의 집합이고, 각 항목들은 theme attribute로 제공됩니다. 다른 폰트로 scale 을 만들려면 Material type scale generator를 확인해 보십시오. ?attr/textAppearanceHeadline1 defaults to light 96sp text. ?attr/textAppearanceHeadline2 defaults to light 60sp text. ?attr/textAppearanceHeadline3 defaults to regular 48sp text. ?attr/textAppearanceHeadline4 defaults to regular 34sp text. ?attr/textAppearanceHeadline5 defaults to regular 24sp text. ?attr/textAppearanceHeadline6 defaults to medium 20sp text. ?attr/textAppearanceSubtitle1 defaults to regular 16sp text. ?attr/textAppearanceSubtitle2 defaults to medium 14sp text. ?attr/textAppearanceBody1 defaults to regular 16sp text. ?attr/textAppearanceBody2 defaults to regular 14sp text. ?attr/textAppearanceCaption defaults to regular 12sp text. ?attr/textAppearanceButton defaults to medium all caps 14sp text. ?attr/textAppearanceOverline defaults to regular all caps 10sp text. ","date":"2021-02-22","objectID":"/2021-02-22_common-theme-attributes/:5:0","series":null,"tags":["android","theme"],"title":"'Android styling: common theme attributes' 번역","uri":"/2021-02-22_common-theme-attributes/#textappearances"},{"categories":["android"],"content":" ShapeMaterial Design은 shape system을 사용합니다. theme attrs로 구현되어 있고, small, medium, large 컴포넌트들을 위해 각각 정의되어 있습니다. 직접 만든 컴포넌트에 shape appearance를 적용해야 하면, MaterialShapeDrawable을 활용하면 좋을 겁니다. ?attr/shapeAppearanceSmallComponent used for Buttons, Chips, Text Fields etc. Defaults to rounded 4dp corners. ?attr/shapeAppearanceMediumComponent used for Cards, Dialogs, Date Pickers etc. Defaults to rounded 4dp corners. ?attr/shapeAppearanceLargeComponent used for Bottom Sheets etc. Defaults to rounded 0dp corners (i.e. square!) ","date":"2021-02-22","objectID":"/2021-02-22_common-theme-attributes/:6:0","series":null,"tags":["android","theme"],"title":"'Android styling: common theme attributes' 번역","uri":"/2021-02-22_common-theme-attributes/#shape"},{"categories":["android"],"content":" Button StylesMaterial 에는 세 가지(Contained, Text, Outlined) 타입의 버튼이 있습니다. MDC(Material Componets)는 style을 지정할 수 있는 theme attrs를 제공합니다. ?attr/materialButtonStyle defaults to contained (or just omit the style). ?attr/borderlessButtonStyle for a text style button. ?attr/materialButtonOutlinedStyle for outlined style. ","date":"2021-02-22","objectID":"/2021-02-22_common-theme-attributes/:7:0","series":null,"tags":["android","theme"],"title":"'Android styling: common theme attributes' 번역","uri":"/2021-02-22_common-theme-attributes/#button-styles"},{"categories":["android"],"content":" Floats ?android:attr/disabledAlpha Default disabled alpha for widgets. ?android:attr/primaryContentAlpha The alpha applied to the foreground elements. ?android:attr/secondaryContentAlpha The alpha applied to secondary elements. ","date":"2021-02-22","objectID":"/2021-02-22_common-theme-attributes/:8:0","series":null,"tags":["android","theme"],"title":"'Android styling: common theme attributes' 번역","uri":"/2021-02-22_common-theme-attributes/#floats"},{"categories":["android"],"content":" App vs Android namespace어떤 attribute는 ?android:attr/foo를 참조하고 어떤 건 ?attr/bar 요렇게 되어 있습니다. 앞의 것은 Android 플랫폼에 정의되어 있어서 android를 붙여야 합니다. (layout에서 view attribute를 android:id로 접근하는 것과 비슷). 안 붙은 녀석들은 앱에 포함되는 static library(i.e. AppCompat or MDC)에 정의되어 있어서, namespace가 필요 없습니다. (layout에서 app:baz를 사용하는 것과 비슷) 어떤 element들은 플랫폼과 라이브러리 양쪽에 정의되어 있습니다(e.g. colorPrimary). 이런 경우에는 모든 API level에서 사용할 수 있는 non-platform 버전을 사용하십시오. 백포팅을 위해서 그렇게 라이브러리에 중복 선언되어 있는 것입니다. 위쪽에서도 non-platform 버전들을 언급했습니다. prefer non-platform attributes which can be used on all API levels ","date":"2021-02-22","objectID":"/2021-02-22_common-theme-attributes/:9:0","series":null,"tags":["android","theme"],"title":"'Android styling: common theme attributes' 번역","uri":"/2021-02-22_common-theme-attributes/#app-vs-android-namespace"},{"categories":["android"],"content":" More Resourcesthee attributes 전체 리스트는 아래에서 확인하세요. Android platform AppCompat Material Design Components: Color Shape Type ","date":"2021-02-22","objectID":"/2021-02-22_common-theme-attributes/:10:0","series":null,"tags":["android","theme"],"title":"'Android styling: common theme attributes' 번역","uri":"/2021-02-22_common-theme-attributes/#more-resources"},{"categories":["android"],"content":" Do It Yourselftheme으로 변화를 주고 싶은 항목이 theme attribute에 없는 경우도 있습니다. 걱정 마세요… 직접 만드시면 됩니다! Google I/O app에서 컨퍼런스 세션 리스트를 두 화면에서 보여주는 예제입니다. 거의 비슷한데 왼쪽에는 시간이 들어갈 공간이 필요하고 오른쪽에는 그렇지 않습니다. 구현을 위해서 theme attribute을 이용했습니다. layout 하나로 두 화면을 나타낼 수 있었죠. attrs.xml에 theme attribute 정의 \u003c!-- Copyright 2019 Google LLC. SPDX-License-Identifier: Apache-2.0 --\u003e \u003cattr name=\"sessionListKeyline\" format=\"dimension\" /\u003e gist 다른 테마에 다른 값 제공 \u003c!-- Copyright 2019 Google LLC. SPDX-License-Identifier: Apache-2.0 --\u003e \u003cstyle name=\"Theme.IOSched.Schedule\"\u003e … \u003citem name=\"sessionListKeyline\"\u003e72dp\u003c/item\u003e \u003c/style\u003e \u003cstyle name=\"Theme.IOSched.Speaker\"\u003e … \u003citem name=\"sessionListKeyline\"\u003e16dp\u003c/item\u003e \u003c/style\u003e gist 3. 두 화면에서 같이 사용하는 (각각 위 테마 중 하나를 사용) 하나의 layout에서 해당 theme attr를 사용 \u003c!-- Copyright 2019 Google LLC. SPDX-License-Identifier: Apache-2.0 --\u003e \u003cGuideline … app:layout_constraintGuide_begin=\"?attr/sessionListKeyline\" /\u003e gist ","date":"2021-02-22","objectID":"/2021-02-22_common-theme-attributes/:11:0","series":null,"tags":["android","theme"],"title":"'Android styling: common theme attributes' 번역","uri":"/2021-02-22_common-theme-attributes/#do-it-yourself"},{"categories":["android"],"content":" Question (mark) everything어떤 theme attribute들이 사용 가능한지 알아둬야, layout, style, drawable을 작성할 때 사용할 수 있습니다. theme attribute를 사용하면 테마 적용(like dark theme)이 쉬워지고, 더 유연하고 유지보수가 용이한 코드를 작성할 수 있습니다. 더 깊이 알아보기 위해서, 다음 포스트로 가시지요! Android Styling: prefer theme attributes ","date":"2021-02-22","objectID":"/2021-02-22_common-theme-attributes/:12:0","series":null,"tags":["android","theme"],"title":"'Android styling: common theme attributes' 번역","uri":"/2021-02-22_common-theme-attributes/#question-mark-everything"},{"categories":["투자 일반"],"content":"요즘 강환국 형님의 ‘할수있다 알고투자’ 채널을 열심히 시청하고 있습니다. 주요 영상들을 제대로 이해하고자 정리해 봅니다. 478. (투자 입문) 주식투자자를 위한 회계지식! ","date":"2021-02-20","objectID":"/2021-02-20_halto-478/:0:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '478. (투자 입문) 주식투자자를 위한 회계지식!' 정리","uri":"/2021-02-20_halto-478/#"},{"categories":["투자 일반"],"content":" 오늘의 한 마디 Note 그냥 오늘 배운 지표만 가지고도 영원히 배불리 먹고 잘 살 수 있습니다. - 강환국(CFA) 회계사가 될 필요는 없지만 조금은 알아야 합니다! ","date":"2021-02-20","objectID":"/2021-02-20_halto-478/:1:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '478. (투자 입문) 주식투자자를 위한 회계지식!' 정리","uri":"/2021-02-20_halto-478/#오늘의-한-마디"},{"categories":["투자 일반"],"content":" 핵심 요약 및 첨언 Note 간단한 회계 지표를 읽을 줄 알면 주식 투자에 매우 도움이 됩니다. 손익계산서와 재무상태표 중에 이번엔 손익계산서의 내용을 다뤄주셨습니다. 돈 되는 지표들 분기매출증가율(전분기 대비, 전년 동기 대비) 시가총액/매출 (PSR) 매출총이익/총자산 (GP/A) 영업이익증가율(전분기 대비, 전년 동기 대비) 시가총액/영엽이익 (POR) 기업가치/영업이익 (EV/EBIT) 순이익증가율(전분기 대비, 전년 동기 대비) 시가총액/순이익 (PER) ","date":"2021-02-20","objectID":"/2021-02-20_halto-478/:2:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '478. (투자 입문) 주식투자자를 위한 회계지식!' 정리","uri":"/2021-02-20_halto-478/#핵심-요약-및-첨언"},{"categories":["투자 일반"],"content":" 0. 들어가며0:19 일단 회계를 어느 정도 읽을 줄 알면 저 기업이 어떤 꼬라지인지 알 수 있습니다. uppity.co.kr/ 라는 뉴스레터 서비스가 있는데, 여기에 연재도 하신답니다. 홈페이지는 업데이트가 한동안 없는 느낌이지만, 그래도 일단 구독 신청 해봅니다. 1:26 기업을 결혼 상대에 비유하자면 손익계산서: “쟤 얼마 벌어?”, “쟤 씀씀이는 어때?” 재무상태표: “쟤 가진 거 많아?”, “쟤 빚이 있나?” ","date":"2021-02-20","objectID":"/2021-02-20_halto-478/:3:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '478. (투자 입문) 주식투자자를 위한 회계지식!' 정리","uri":"/2021-02-20_halto-478/#0-들어가며"},{"categories":["투자 일반"],"content":" 1. 매출액 (Sales)2:28 돈 되는 지표: 분기매출증가율(전분기 대비, 전년 동기 대비), 시가총액/매출 (PSR) ","date":"2021-02-20","objectID":"/2021-02-20_halto-478/:4:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '478. (투자 입문) 주식투자자를 위한 회계지식!' 정리","uri":"/2021-02-20_halto-478/#1-매출액-sales"},{"categories":["투자 일반"],"content":" 2. 매출총이익 (Gross Profits)4:09 돈 되는 지표: 매출총이익/총자산 (GP/A) ","date":"2021-02-20","objectID":"/2021-02-20_halto-478/:5:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '478. (투자 입문) 주식투자자를 위한 회계지식!' 정리","uri":"/2021-02-20_halto-478/#2-매출총이익-gross-profits"},{"categories":["투자 일반"],"content":" 3. 영업이익 (Operating Profits, EBIT)5:41 돈 되는 지표: 영업이익증가율(전분기 대비, 전년 동기 대비), 시가총액/영엽이익(POR), 기업가치/영업이익(EV/EBIT) ","date":"2021-02-20","objectID":"/2021-02-20_halto-478/:6:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '478. (투자 입문) 주식투자자를 위한 회계지식!' 정리","uri":"/2021-02-20_halto-478/#3-영업이익-operating-profits-ebit"},{"categories":["투자 일반"],"content":" 4. 순이익8:05 돈 되는 지표: 순이익증가율(전분기 대비, 전년 동기 대비), 시가총액/순이익(PER) ","date":"2021-02-20","objectID":"/2021-02-20_halto-478/:7:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '478. (투자 입문) 주식투자자를 위한 회계지식!' 정리","uri":"/2021-02-20_halto-478/#4-순이익"},{"categories":["투자 일반"],"content":" 5. 요약9:48 Note 금융/주식시장은 가짜 뉴스가 정말 많습니다. 회계는 어렵다 - 거짓 재무제표 지표는 투자에 중요하지 않다 - 거짓 그냥 오늘 배운 지표만 갖고도 영원히 배불리 먹고 살 수 있습니다. 콤보도 가능: 전년동기/전분기 대비 매출 + 영업 + 순이익 크게 증가 중 PER 낮은 기업… 등 ","date":"2021-02-20","objectID":"/2021-02-20_halto-478/:8:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '478. (투자 입문) 주식투자자를 위한 회계지식!' 정리","uri":"/2021-02-20_halto-478/#5-요약"},{"categories":["android"],"content":"스터디 하면서 샘플 프로젝트 따라 해보다가, 조금 된 예제를 따라하다보니 뭔가 theme 관련해서 마음대로 안되는 상황이 왔습니다. 찾다보니 요 시리즈를 알아두면 되겠다 싶네요. 아래 포스트를 번역한 내용입니다. (안드로이드 공식 블로그인듯 합니다.) Android styling: themes vs styles Android styling system 은 앱 디자인 작업을 위한 강력한 방법을 제공하지만, 잘못 사용하기 쉽습니다. 이를 적절히 사용하면 themes 와 styles 을 쉽게 유지할 수 있고, branding updates 가 덜 부담스러우며, 다크 모드를 지원하는 것이 간단해 질 수 있습니다. 이 글은 Chris Banes와 저자(Nick Butcher)가 앞으로 연재할 시리즈의 첫 포스트입니다. 머리 쥐어 뜯지 않아도 스타일리쉬한 앱을 만들 수 있도록, 안드로이드 스타일링의 미스터리를 이 시리즈에서 풀어 보겠습니다. 이 포스트에서는, 스타일링 시스템의 구성 요소인 themes 와 styles 를 살펴보겠습니다. ","date":"2021-02-18","objectID":"/2021-02-18_themes-vs-styles/:0:0","series":null,"tags":["android","theme"],"title":"'Android styling: themes vs styles' 번역","uri":"/2021-02-18_themes-vs-styles/#"},{"categories":["android"],"content":" Theme != Stylethemes 와 styles 둘 다 \u003cstyle\u003e구문을 사용하지만 매우 다른 용도로 사용됩니다. 둘 다 key 가 attributes 이고 value 가 resource 인 key-value 저장소로 생각할 수 있습니다. 각각을 살펴봅시다. ","date":"2021-02-18","objectID":"/2021-02-18_themes-vs-styles/:1:0","series":null,"tags":["android","theme"],"title":"'Android styling: themes vs styles' 번역","uri":"/2021-02-18_themes-vs-styles/#theme--style"},{"categories":["android"],"content":" What’s in a style?style 은 view attribute values의 collection 입니다. Map\u003cview attribute, resource\u003e로 생각하실 수 있습니다. 다시 말하면 key 는 모두 view attributes 입니다. widget 이 선언하고 당신이 layout 파일에 세팅할 수도 있는 그 attribute 입니다. Styles 은 단일 타입의 widget 에 적용됩니다. 다른 widget은 다른 attributes 셋을 지원하기 때문입니다. Styles are a collection of view attributes; specific to a single type of widget 원본 gist \u003c!-- Copyright 2019 Google LLC. SPDX-License-Identifier: Apache-2.0 --\u003e \u003cstyle name=\"Widget.Plaid.Button.InlineAction\" parent=\"…\"\u003e \u003citem name=\"android:gravity\"\u003ecenter_horizontal\u003c/item\u003e \u003citem name=\"android:textAppearance\"\u003e@style/TextAppearance.CommentAuthor\u003c/item\u003e \u003citem name=\"android:drawablePadding\"\u003e@dimen/spacing_micro\u003c/item\u003e \u003c/style\u003e 아래에서 보듯이 style의 각 key는 layout 에서 설정할 수 있는 attribute들입니다. 원본 gist \u003c!-- Copyright 2019 Google LLC. SPDX-License-Identifier: Apache-2.0 --\u003e \u003cButton … android:gravity=\"center_horizontal\" android:textAppearance=\"@style/TextAppearance.CommentAuthor\" android:drawablePadding=\"@dimen/spacing_micro\"/\u003e 이것들을 style 로 추출하면 여러 view 에서 쉽게 재사용할 수 있고, 유지보수도 용이합니다. ","date":"2021-02-18","objectID":"/2021-02-18_themes-vs-styles/:2:0","series":null,"tags":["android","theme"],"title":"'Android styling: themes vs styles' 번역","uri":"/2021-02-18_themes-vs-styles/#whats-in-a-style"},{"categories":["android"],"content":" UsageStyles 은 layout의 각 view 에서 사용될 수 있습니다. 원본 gist \u003c!-- Copyright 2019 Google LLC. SPDX-License-Identifier: Apache-2.0 --\u003e \u003cButton … style=\"@style/Widget.Plaid.Button.InlineAction\"/\u003e View 는 하나의 style만 적용합니다. - 웹에서 css 가 여러 class들을 적용할 수 있는 것과 대조됩니다. ","date":"2021-02-18","objectID":"/2021-02-18_themes-vs-styles/:3:0","series":null,"tags":["android","theme"],"title":"'Android styling: themes vs styles' 번역","uri":"/2021-02-18_themes-vs-styles/#usage"},{"categories":["android"],"content":" Scopeview 에 적용된 style 은 바로 그 view 에만 적용되고, 자식들에게는 적용되지 않습니다. 예를 들어 3개의 버튼을 가진 ViewGroup이 있을 때, InlineAction style을 ViewGroup에 적용하더라도 자식 버튼들에는 해당 style이 적용되지 않습니다. style로부터 제공된 값들은 layout에서 직접 설정한 값들과 결합됩니다. (스타일링 우선순위에 따라) ","date":"2021-02-18","objectID":"/2021-02-18_themes-vs-styles/:4:0","series":null,"tags":["android","theme"],"title":"'Android styling: themes vs styles' 번역","uri":"/2021-02-18_themes-vs-styles/#scope"},{"categories":["android"],"content":" What’s a theme?theme은 styles이나 layouts등에서 참조할 수 있는 이름을 붙인 resources의 모음입니다. 의미있는 이름을 Android resources에 제공함으로써, 나중에 참조할 수 있습니다. 예를 들어 colorPrimary는 해당 색을 위한 의미있는 이름입니다. 원본 gist \u003c!-- Copyright 2019 Google LLC. SPDX-License-Identifier: Apache-2.0 --\u003e \u003cstyle name=\"Theme.Plaid\" parent=\"…\"\u003e \u003citem name=\"colorPrimary\"\u003e@color/teal_500\u003c/item\u003e \u003citem name=\"colorSecondary\"\u003e@color/pink_200\u003c/item\u003e \u003citem name=\"android:windowBackground\"\u003e@color/white\u003c/item\u003e \u003c/style\u003e 이 이름 붙인 resources를 theme attributes라고 하고, 고로 theme 은 Map\u003ctheme attribute, resource\u003e라고 볼 수 있습니다. theme attributes는 view attributes와 다릅니다. 특정 view 타입에 한정된 속성이 아니고, 앱 전반에서 사용할 수 있는 의미있는 이름의 포인터이기 때문입니다. theme은 이름 붙인 resources의 실제 값을 제공합니다. 위의 예제에서 colorPrimary attribute는 이 theme의 기본 색상이 teal(청록색)임을 명시합니다. resource를 theme으로 추상화함으로써, 다른 theme 에서 다른 값(예를 들면, colorPrimary=orange)을 제공할 수 있습니다. Themes are a collection of named resources, useful broadly across an app theme 은 interface와 비슷합니다. interface로 프로그래밍하면 실제 구현 클래스로의 의존성이 없어지고 다른 동작을 하는 구현 클래스도 쉽게 제공할 수 있습니다. themes도 비슷한 역할을 합니다. layout과 style을 작성할때 theme attributes 를 이용함로써, 다른 실제 값을 제공하면 다른 테마가 적용되도록 할 수 습니다. 아래는 러프한 pseudo-code 입니다. 원본 gist /* Copyright 2019 Google LLC. SPDX-License-Identifier: Apache-2.0 */ interface ColorPalette { @ColorInt val colorPrimary @ColorInt val colorSecondary } class MyView(colors: ColorPalette) { fab.backgroundTint = colors.colorPrimary } 아래처럼 따로 확장하지 않고 MyView가 그려지는 방식을 다르게 할 수 있습니다. 원본 gist /* Copyright 2019 Google LLC. SPDX-License-Identifier: Apache-2.0 */ val lightPalette = object : ColorPalette { … } val darkPalette = object : ColorPalette { … } val view = MyView(if (isDarkTheme) darkPalette else lightPalette) ","date":"2021-02-18","objectID":"/2021-02-18_themes-vs-styles/:5:0","series":null,"tags":["android","theme"],"title":"'Android styling: themes vs styles' 번역","uri":"/2021-02-18_themes-vs-styles/#whats-a-theme"},{"categories":["android"],"content":" UsageActivity, View, ViewGroup 처럼 Context를 가지거나 나타내는 곳에 theme을 적용할 수 있습니다. 원본 gist \u003c!-- Copyright 2019 Google LLC. SPDX-License-Identifier: Apache-2.0 --\u003e \u003c!-- AndroidManifest.xml --\u003e \u003capplication … android:theme=\"@style/Theme.Plaid\"\u003e \u003cactivity … android:theme=\"@style/Theme.Plaid.About\"/\u003e \u003c!-- layout/foo.xml --\u003e \u003cConstraintLayout … android:theme=\"@style/Theme.Plaid.Foo\"\u003e Context를 ContextThemeWrapper로 감싸고 이후에 inflate 하는 등의 방식으로 코드에서 theme 을 지정할 수도 있습니다. themes 의 강력함은 어떻게 사용하느냐에 달려 있습니다. theme attributes를 참조함으로써 더 유연한 widgets을 만들 수 있습니다. 다른 themes은 다른 실제 값을 제공합니다. 예를 들어, ViewGroup에 배경색을 지정하고 싶은 상황이라고 해봅시다. 원본 gist \u003c!-- Copyright 2019 Google LLC. SPDX-License-Identifier: Apache-2.0 --\u003e \u003cViewGroup … android:background=\"?attr/colorSurface\"\u003e 실제 색(#ffffff나 @color리소스)을 지정하는 대신 ?attr/themeAttributeName구문을 사용함으로써 theme에게 위임할 수 있습니다. 이 구문은 해당 semantic attribute를 위한 값을 theme에게 질의한다는 의미입니다. 이렇게 간접적으로 접근함으로써 (거의 같은데 색깔 몇개만 다른) 별도의 layout이나 style을 만들지 않고도, 다른 동작(e.g. light, dark themes 에서 다른 배경색 제공)을 제공할 수 있습니다. Use the ?attr/themeAttributeName syntax to query the theme for the value of this semantic attribute ","date":"2021-02-18","objectID":"/2021-02-18_themes-vs-styles/:6:0","series":null,"tags":["android","theme"],"title":"'Android styling: themes vs styles' 번역","uri":"/2021-02-18_themes-vs-styles/#usage-1"},{"categories":["android"],"content":" ScopeTheme은 Context의 속성으로 접근되며, Context이거나 가진 Activity, View, ViewGroup에서 획득이 가능 합니다. 이 객체들은 tree 구조로 존재합니다(Activity가 ViewGroup들을 포함하고, ViewGroup은 View들을 포함 등). tree 의 특정 노드에 theme을 적용하면 자손 노드에도 해당 theme이 적용됩니다. 예를 들어, ViewGroup에 theme을 적용하면 해당 ViewGroup에 속한 View들 모두에 해당 theme이 적용됩니다. (styles은 하나의 view에만 적용되는 것과 대조됨) 원본 gist \u003c!-- Copyright 2019 Google LLC. SPDX-License-Identifier: Apache-2.0 --\u003e \u003cViewGroup … android:theme=\"@style/Theme.App.SomeTheme\"\u003e \u003c!-- SomeTheme also applies to all child views. --\u003e \u003c/ViewGroup\u003e 이건 정말 정말 유용합니다. light 스크린에 특정 부분만 dark theme을 적용하고 싶다고 생각해 봅시다. 이 동작은 여기서 다룹니다. 이 동작은 layout inflation time에만 적용됩니다. Context가 setTheme 메소드를 제공하고, Theme이 applyStyle 메소드를 제공하지만, 이 메소드들은 inflation 전에 불려야 합니다. inflation 이후에 새로운 theme을 적용하고 style을 적용하는 것은 이미 존재하는 view를 업데이트 하지 않습니다. ","date":"2021-02-18","objectID":"/2021-02-18_themes-vs-styles/:7:0","series":null,"tags":["android","theme"],"title":"'Android styling: themes vs styles' 번역","uri":"/2021-02-18_themes-vs-styles/#scope-1"},{"categories":["android"],"content":" Separate Concernsstyles와 themes의 다른 역할과 상호작용을 이해함는 것은 스타일링 리소스들 관리에 도움이 됩니다. 예를 들어 파란색 테마를 가진 상황에서, Pro 버전 몇 화면은 보라색 테마를 가져야 하고, dark themes 도 제공하고 싶다고 합시다. styles 만으로 접근한다면 Pro/non-Pro 와 light/dark 조합을 위한 4개의 styles 이 필요합니다. style 은 특정 타입의 view(Button, Switch 등)에 한정적이므로, 각각의 view 타입에 대해서 각각의 조합이 필요한 상황이 되어 버립니다. styles와 themes를 같이 사용하면, theme에 의해서 대체되는 부분을 고립시킬 수 있어서 각 view 타입에 대해서 하나의 style만 있으면 됩니다. 위의 예제에서 다른 colorPrimary 값을 제공하는 4개의 themes를 만들고, styles에서 각 theme으로부터 값을 가져오게 할 수 있습니다. 이 접근이 styles과 themes의 상호작용을 고려해야해서 더 복잡해 보일지도 모릅니다. 하지만 themes별로 변경되는 부분을 고립시키는 효과가 있습니다. 만약 파란색에서 오렌지색으로 테마를 변경한다고 하면, 여러 파일에서 styling 전반에 걸친 수정을 하는 게 아니라, 한 곳만 수정하면 됩니다. 또한 styles 이 많아지는 것을 막을 수 있습니다. 이상적으로는 각 view 타입별로 약간의 styles만 있으면 됩니다. theming을 활용하지 않는다면 styles.xml이 무지막지하게 많아져서 관리하는게 고통이 될 겁니다. 다음에는 많이 사용되는 theme attributes를 알아보고, 직접 만드는 방법도 알아보겠습니다. Android styling: common theme attributes ","date":"2021-02-18","objectID":"/2021-02-18_themes-vs-styles/:8:0","series":null,"tags":["android","theme"],"title":"'Android styling: themes vs styles' 번역","uri":"/2021-02-18_themes-vs-styles/#separate-concerns"},{"categories":["투자 일반"],"content":"요즘 강환국 형님의 ‘할수있다 알고투자’ 채널을 열심히 시청하고 있습니다. 주요 영상들을 제대로 이해하고자 정리해 봅니다. 218.(초보) 투자의 기초, 한시간 만에 완료!! ","date":"2021-01-17","objectID":"/2021-01-17_halto-218/:0:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '218. (초보) 투자의 기초, 한시간 만에 완료!!' 정리","uri":"/2021-01-17_halto-218/#"},{"categories":["투자 일반"],"content":" 0.핵심 요약 및 첨언 Note 내일 당장 투자를 시작하십시오! 투자보다 중요한건 건강말고는 없습니다. 투자는 직접 해야하며, 자산배분을 통해 버틸 수 있는 큰 틀을 만들어 두고, 그 안에서 추가 수익을 노리셔야 합니다. 사기 전에 언제 팔지 미리 고민해두고, 직접 백테스트를 하셔야 합니다. ","date":"2021-01-17","objectID":"/2021-01-17_halto-218/:1:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '218. (초보) 투자의 기초, 한시간 만에 완료!!' 정리","uri":"/2021-01-17_halto-218/#0핵심-요약-및-첨언"},{"categories":["투자 일반"],"content":" 1.강환국 소개","date":"2021-01-17","objectID":"/2021-01-17_halto-218/:2:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '218. (초보) 투자의 기초, 한시간 만에 완료!!' 정리","uri":"/2021-01-17_halto-218/#1강환국-소개"},{"categories":["투자 일반"],"content":" 1.1 강환국은 어떻게 계량투자에 빠지게 되었는가92s 2004년, 주식에 입문하다 접한 책들 부자 아빠 가난한 아빠 전설로 떠나는 월가의 영웅 위 두권의 책을 접한 이후, 주로 가치투자 위주의 책을 연구 2006년, 졸업 논문 테마는 가치 투자 (PER, PBR..) “어떤 주식을 사면 돈을 벌 수 있는가” 류의 논문들이 있었음. 방법도 친절하게 공개 2006.10~ 실전 타임 논문 따라해보기. 진짜 벌림 ","date":"2021-01-17","objectID":"/2021-01-17_halto-218/:2:1","series":["할투 정리"],"tags":["할투"],"title":"할투 '218. (초보) 투자의 기초, 한시간 만에 완료!!' 정리","uri":"/2021-01-17_halto-218/#11-강환국은-어떻게-계량투자에-빠지게-되었는가"},{"categories":["투자 일반"],"content":" 1.2 저서 및 유튜브 채널 할 수 있다! 퀀트 투자 Gazua!!! 가상화폐 투자 마법 공식 ","date":"2021-01-17","objectID":"/2021-01-17_halto-218/:2:2","series":["할투 정리"],"tags":["할투"],"title":"할투 '218. (초보) 투자의 기초, 한시간 만에 완료!!' 정리","uri":"/2021-01-17_halto-218/#12-저서-및-유튜브-채널"},{"categories":["투자 일반"],"content":" 1.3 유튜브 채널2018.12.31 부터 할 수 있다! 알고 투자 ","date":"2021-01-17","objectID":"/2021-01-17_halto-218/:2:3","series":["할투 정리"],"tags":["할투"],"title":"할투 '218. (초보) 투자의 기초, 한시간 만에 완료!!' 정리","uri":"/2021-01-17_halto-218/#13-유튜브-채널"},{"categories":["투자 일반"],"content":" 2.투자를 무조건 해야 하는 이유참고 영상 468.(투자 입문) 젊을 때 투자를 배워야 하는 3가지 이유! 35. [초보] 투자는 선택이 아니라 생존이다!! (1) 36. [초보] 투자는 선택이 아니라 생존이다!! (2) ","date":"2021-01-17","objectID":"/2021-01-17_halto-218/:3:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '218. (초보) 투자의 기초, 한시간 만에 완료!!' 정리","uri":"/2021-01-17_halto-218/#2투자를-무조건-해야-하는-이유"},{"categories":["투자 일반"],"content":" 2.1 40+40 사회253s 100 세 시대. 아무리 발버둥 쳐도 40년 이상 일하기 힘들다. 그 후에도 40년 동안 ‘전업투자’ 로 먹고 살아야 함. 투자는 선택이 아니라 생존! ","date":"2021-01-17","objectID":"/2021-01-17_halto-218/:3:1","series":["할투 정리"],"tags":["할투"],"title":"할투 '218. (초보) 투자의 기초, 한시간 만에 완료!!' 정리","uri":"/2021-01-17_halto-218/#21-4040-사회"},{"categories":["투자 일반"],"content":" 2.2 연금 따위는 꿈도 꾸지 마세요399s 노후에 믿을 것은 당신 자산 \u0026 당신 투자 실력 밖에! ","date":"2021-01-17","objectID":"/2021-01-17_halto-218/:3:2","series":["할투 정리"],"tags":["할투"],"title":"할투 '218. (초보) 투자의 기초, 한시간 만에 완료!!' 정리","uri":"/2021-01-17_halto-218/#22-연금-따위는-꿈도-꾸지-마세요"},{"categories":["투자 일반"],"content":" 2.3 차리리 즐기자455s 차라리 즐기자 50대 되서 배우면 너무 늦음 젊었을 때 기초 투자 지식 + 실전경험 필수 ","date":"2021-01-17","objectID":"/2021-01-17_halto-218/:3:3","series":["할투 정리"],"tags":["할투"],"title":"할투 '218. (초보) 투자의 기초, 한시간 만에 완료!!' 정리","uri":"/2021-01-17_halto-218/#23-차리리-즐기자"},{"categories":["투자 일반"],"content":" 3.투자 수익 1%가 매우 중요함참고 영상 138. [왕초보] 얼마를 모아야 은퇴가 가능한가? ","date":"2021-01-17","objectID":"/2021-01-17_halto-218/:4:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '218. (초보) 투자의 기초, 한시간 만에 완료!!' 정리","uri":"/2021-01-17_halto-218/#3투자-수익-1가-매우-중요함"},{"categories":["투자 일반"],"content":" 3.1 나의 목표는? 낙원 계산기 (메뉴얼: 138) 낙원 계산기 520s 자산, 저축, 은퇴 시점, 수익율을 조절하면서 재정 목표치 확인 (원금이 줄지 않으면서 쓸 수 있는 금액) 867s 투자 수익률 1% 가 매우 매우 중요함 ","date":"2021-01-17","objectID":"/2021-01-17_halto-218/:4:1","series":["할투 정리"],"tags":["할투"],"title":"할투 '218. (초보) 투자의 기초, 한시간 만에 완료!!' 정리","uri":"/2021-01-17_halto-218/#31-나의-목표는-낙원-계산기-메뉴얼-138"},{"categories":["투자 일반"],"content":" 4.남한테 맡기면 안됨참고영상 16. [초보] 존 보글과 인덱스펀드 (2) 전문가들이라고 하는 사람들이 운용하는 펀드 355전 24승 48무 283패 (6.7%) 894s ","date":"2021-01-17","objectID":"/2021-01-17_halto-218/:5:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '218. (초보) 투자의 기초, 한시간 만에 완료!!' 정리","uri":"/2021-01-17_halto-218/#4남한테-맡기면-안됨"},{"categories":["투자 일반"],"content":" 5.자산배분","date":"2021-01-17","objectID":"/2021-01-17_halto-218/:6:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '218. (초보) 투자의 기초, 한시간 만에 완료!!' 정리","uri":"/2021-01-17_halto-218/#5자산배분"},{"categories":["투자 일반"],"content":" 5.1 버틸 수 있는 전략이 중요1035s 대부분 사람은 20% 이상의 손실을 심리적으로 견디지 못함 투자 전략을 무시하고 뻘짓 하다가 자멸 or 투자 자체를 중단 고수익 전략보다 “버틸수 있는 전략이 중요!!” 낮은 최대 손실(MDD, Max. Drawdown) 주가 지수에 투자하는 것도 좋은 방법이지만, 높은 MDD를 버티기 힘듬 미국 주가 지수에 투자 예시 아래 사이트를 통한 백테스트 시연 www.portfoliovisualizer.com/backtest-asset-class-allocation 연 복리 10% 의 수익이지만, 50% 이상의 높은 MDD 를 대부분 견디지 못한다. ","date":"2021-01-17","objectID":"/2021-01-17_halto-218/:6:1","series":["할투 정리"],"tags":["할투"],"title":"할투 '218. (초보) 투자의 기초, 한시간 만에 완료!!' 정리","uri":"/2021-01-17_halto-218/#51-버틸-수-있는-전략이-중요"},{"categories":["투자 일반"],"content":" 5.2 영구 포트폴리오참고영상 348.(왕초보 1억) - 초보자 투자는 이렇게 - 영구 포트폴리오의 모든 것! 119. [초보] 초보가 알아야 하는 자산배분의 모든 것 1317s 복리 8.28%, MDD 13.48% Harry Browne Permanent Portfolio 네 개 자산의 상관관계 (Monthly Correlations) 가 낮음 정답은: 상관성이 낮은 자산에 분산투자!! ","date":"2021-01-17","objectID":"/2021-01-17_halto-218/:6:2","series":["할투 정리"],"tags":["할투"],"title":"할투 '218. (초보) 투자의 기초, 한시간 만에 완료!!' 정리","uri":"/2021-01-17_halto-218/#52-영구-포트폴리오"},{"categories":["투자 일반"],"content":" 5.3 레이 달리오의 업그레이드: 4계절 포트폴리오 (37, 38)참고영상 353.(왕초보 1억) 4계절 포트폴리오(올웨더) 초간단 설명! 37.[초보] 투자자 99%에 맞는 필승 투자법 - 4계절 포트폴리오 38.[초보] 투자자 99%에 맞는 필승 투자법 - 4계절 포트폴리오의 한국화 1579s 경제 4계절 이론 - 미래는 예측 불가하나, 4개 중 하나는 온다 주식류, 채권류, 실물류 사 놓으면 어떤 계절이 오든 망하지는 않는다 ","date":"2021-01-17","objectID":"/2021-01-17_halto-218/:6:3","series":["할투 정리"],"tags":["할투"],"title":"할투 '218. (초보) 투자의 기초, 한시간 만에 완료!!' 정리","uri":"/2021-01-17_halto-218/#53-레이-달리오의-업그레이드-4계절-포트폴리오-37-38"},{"categories":["투자 일반"],"content":" 6.마켓 타이밍","date":"2021-01-17","objectID":"/2021-01-17_halto-218/:7:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '218. (초보) 투자의 기초, 한시간 만에 완료!!' 정리","uri":"/2021-01-17_halto-218/#6마켓-타이밍"},{"categories":["투자 일반"],"content":" 6.1 주식 시장 수익은 11~4월에 발생한다참고영상 40.전세계에서 통하는 만능 전략 - 11월 초 매수, 4월 말 매도 110.[초보] 주식 투자는 역시 11월~4월이 적정기! 117.11월~4월에 투자해서 복리 20% 이상! 122.[초보] 5월~10월, 주식을 안하면 어디에 투자해? 163.자산배분에 11월~4월 전략을 섞으면? 179.진정한 강철멘탈만 버틸 수 있는 복리 15% 전략! 193.[초보] 주가 폭락, 11월에 다시 들어가 말아? 1701s 주식은 11월~4월에 ","date":"2021-01-17","objectID":"/2021-01-17_halto-218/:7:1","series":["할투 정리"],"tags":["할투"],"title":"할투 '218. (초보) 투자의 기초, 한시간 만에 완료!!' 정리","uri":"/2021-01-17_halto-218/#61-주식-시장-수익은-114월에-발생한다"},{"categories":["투자 일반"],"content":" 6.2 모멘템 - 최근 3~12개월 오른 놈은 계속 오를 가능성이 높음 21.모멘텀의 오묘한 세계 (6) - GTAA (자산배분 + 절대모멘텀) 22.모멘텀의 오묘한 세계 (7) - 듀얼모멘텀 23.모멘텀의 오묘한 세계 (8) - 듀얼모멘텀 백테스트 39.217년 데이터 분석, 시장에서 이기는 방법은 영원하리! 96.회사채 수익을 높이는 방법은? 절대모멘텀: 최근 12개월 수익이 +인 경우에만 투자 상대모멘텀: 그런 놈들이 여럿이면 최근 12개월 가장 많이 오른 놈들에 투자 듀얼모멘텀: 이 두개를 합친다! 미국, 중국 지수 예시 2024s 듀얼 모멘텀에 대한 자세한 내용은 아래 책에서 듀얼 모멘텀 투자 전략 자산배분 먼저 하고, 주식 비중을 듀얼 모멘텀으로 돌린다던지 해야 함. 지금까지 모든 전략은 ETF로 함 ","date":"2021-01-17","objectID":"/2021-01-17_halto-218/:7:2","series":["할투 정리"],"tags":["할투"],"title":"할투 '218. (초보) 투자의 기초, 한시간 만에 완료!!' 정리","uri":"/2021-01-17_halto-218/#62-모멘템---최근-312개월-오른-놈은-계속-오를-가능성이-높음"},{"categories":["투자 일반"],"content":" 7.개별 종목","date":"2021-01-17","objectID":"/2021-01-17_halto-218/:8:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '218. (초보) 투자의 기초, 한시간 만에 완료!!' 정리","uri":"/2021-01-17_halto-218/#7개별-종목"},{"categories":["투자 일반"],"content":" 7.1 개별 종목 - 계량 방법2285s 딱 1개만 보라면 - 이놈이 최근 1년 많이 올랐나? (한국 중소형주 예외) 딱 2개만 보라면 - 이놈 PER, PBR가 낮은가? . PER: 시가총액 / 기업 순이익 (낮으면 저평가) . PBR: 시가총액 / 기업 순자산 (낮으면 저평가) 전세계 PER, PBR 확인 Stock Market Valuation 에서 확인 2020년 10월 30일 기준 PE 26.3 , PB 21 정도를 기준으로 삼으면 됨. (PER, PBR 에서 R을 안쓰기도 함) Yahoo Stock Screeners 에서 종목 필터링 Stock Screeners - Yahoo Finance 저평가 되어 있고, 1년 동안 많이 오른 애들 필터링 할 수 있음. ","date":"2021-01-17","objectID":"/2021-01-17_halto-218/:8:1","series":["할투 정리"],"tags":["할투"],"title":"할투 '218. (초보) 투자의 기초, 한시간 만에 완료!!' 정리","uri":"/2021-01-17_halto-218/#71-개별-종목---계량-방법"},{"categories":["투자 일반"],"content":" 7.2 모멘텀 전략, 이거 왜 먹히는 걸까?참고영상 204.[초보] 그것이 알고싶다 - 최근 오른 자산이 왜 계속 오르는가? 2693s 효율적인 시장 vs 현실 세계 새 정보가 도착하면 원래는 가격이 곧바로 점프해야 하는데 가격은 서서히 오른다 (추세) 새로운 내재가치에 들어가면 그만 올라야 하는데 계속 오르고 어느 정도 후에야 추세가 꺽인다 ","date":"2021-01-17","objectID":"/2021-01-17_halto-218/:8:2","series":["할투 정리"],"tags":["할투"],"title":"할투 '218. (초보) 투자의 기초, 한시간 만에 완료!!' 정리","uri":"/2021-01-17_halto-218/#72-모멘텀-전략-이거-왜-먹히는-걸까"},{"categories":["투자 일반"],"content":" 7.3 저 PBR, PER 주식이 오르는 이유2961s 벤자민 그레이엄 가라사대 - 시장은 조울증 환자다 ","date":"2021-01-17","objectID":"/2021-01-17_halto-218/:8:3","series":["할투 정리"],"tags":["할투"],"title":"할투 '218. (초보) 투자의 기초, 한시간 만에 완료!!' 정리","uri":"/2021-01-17_halto-218/#73-저-pbr-per-주식이-오르는-이유"},{"categories":["투자 일반"],"content":" 7.4 개별종목 - 비계량 방법참고영상 195.[초보] 워렌 버핏 투자비법 초보 매뉴얼! 3069s 나는 저놈이 오른다는 걸 알아!! (일하면서 찾을 수 있음, 195) 1년 수익, PER, PBR이 평균 이상인지만 확인하고 삽시다 개별주 베팅은 자산의 10%만 . 최고점 대비 20% 까이면 팝시다 (그럼 최대 손실 2%로 제한) . 잘 나가면 (50%+)? 피라미딩도 가능 ","date":"2021-01-17","objectID":"/2021-01-17_halto-218/:8:4","series":["할투 정리"],"tags":["할투"],"title":"할투 '218. (초보) 투자의 기초, 한시간 만에 완료!!' 정리","uri":"/2021-01-17_halto-218/#74-개별종목---비계량-방법"},{"categories":["투자 일반"],"content":" 8.다른 자산군","date":"2021-01-17","objectID":"/2021-01-17_halto-218/:9:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '218. (초보) 투자의 기초, 한시간 만에 완료!!' 정리","uri":"/2021-01-17_halto-218/#8다른-자산군"},{"categories":["투자 일반"],"content":" 8.1 부동산 - 모멘텀, 저평가 규칙 그대로 적용 (장기수익: 주식과 비슷)참고영상 88.벌 수 있다! 아파트로 복리 30%!! 336.(충격) 한국 아파트의 진실 - 서울 vs. 지방아파트 배틀의 승자는! 3278s 최근 3개월간 가장 많이 오른 아파트들이 향후 1년에도 계속 오른다 전세비율이 높은 아파트 향후 1년 수익이 좋다 ","date":"2021-01-17","objectID":"/2021-01-17_halto-218/:9:1","series":["할투 정리"],"tags":["할투"],"title":"할투 '218. (초보) 투자의 기초, 한시간 만에 완료!!' 정리","uri":"/2021-01-17_halto-218/#81-부동산---모멘텀-저평가-규칙-그대로-적용-장기수익-주식과-비슷"},{"categories":["투자 일반"],"content":" 8.2 암호 화폐참고영상 60.암호화폐 - 사기인가 미래의 금인가 61.암호화폐에 부동산보다 더 안전하게 투자한다고!? 131.[중요] 직접 백테스트를 해야 합니다!! 342.강환국 가상화폐 전략, 18~19년 하락장에 먹혔나! 465.비트코인 3천만 원 기념 영상 완성본! 3352s 개별 코인 - 자산의 5%만 투입. 최고점 대비 40% 까이면 팝시다 시스템 트레이딩 (60, 61, 131) . 변동성 돌파전략 + 헤이비트 차익거래 + 송금 (지금은 안됨) . 싼 거래소에서 리플 사서 비싼 거래소로 송금 (수수료: 0.5%) . 원화 입금 + 출금이 가능한 한국 거래소 필요 ","date":"2021-01-17","objectID":"/2021-01-17_halto-218/:9:2","series":["할투 정리"],"tags":["할투"],"title":"할투 '218. (초보) 투자의 기초, 한시간 만에 완료!!' 정리","uri":"/2021-01-17_halto-218/#82-암호-화폐"},{"categories":["투자 일반"],"content":" 9.가장 중요 - 매수 전 언제 매도할지 알기참고영상 63.[초보] 주식시장에서 무조건 이기는 방법 190.구독자 10,000명 기념! 투자 10계명 대공개! 192.내가 100만불 잃으면서 배운 것! (下) 193.[초보] 주가 폭락, 11월에 다시 들어가 말아? 3477s 매수 전 언제 매도할 지 알기 매수한 후에는 우리는 매수자산을 객관적으로 평가하기 절대 불가능하다! 인간의 원숭이화, 절대 피할 수 없는 현상! 나도 안되고 여러분도 안된다! 따라서 오르고, 내리고, 횡보할 때 언제 파는지 미리 결정하고 사야함. 강환국님 예시 11월에 사서, 4월말까지 보유 산 가격에서 20% 떨어지면 팔아버림 고점대비 20% 떨어지면 팔아버림 원숭이가 되기전에 시나리오를 미리 생각해 놓는 게 중요함. 룰을 어딘가에 써두고, 그 순간이 오면 꼭 실행을 해야 함!! ","date":"2021-01-17","objectID":"/2021-01-17_halto-218/:10:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '218. (초보) 투자의 기초, 한시간 만에 완료!!' 정리","uri":"/2021-01-17_halto-218/#9가장-중요---매수-전-언제-매도할지-알기"},{"categories":["투자 일반"],"content":" 10.중요 - 백테스트 백테스트 백테스트참고영상 75.개별주식 전략 백테스트 정복 92.[초보] 투자전략 백테스트, 환상과 현실 128.[초보] 백테스트와 리밸런싱, 이렇게 하는 겁니다! 131.[중요] 직접 백테스트를 해야 합니다!! 3641s ","date":"2021-01-17","objectID":"/2021-01-17_halto-218/:11:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '218. (초보) 투자의 기초, 한시간 만에 완료!!' 정리","uri":"/2021-01-17_halto-218/#10중요---백테스트-백테스트-백테스트"},{"categories":["투자 일반"],"content":" 11.요약3682s Tip 내일 당장 시작! 장기적으로 투자보다 중요한건 건강 말고는 없다 Note 우리는 40+40 사회에 산다! 투자는 선택이 아니라 생존! 투자 수익 1%가 우리 노후에 엄청난 차이를 미친다 내 돈 남에게 맡기면 큰일난다 자산배분: 상관성이 적은 자산에 분산투자 마켓타이밍 1: 주식 + 리스크자산은 11~4월에만! 마켓타이밍 2: 최근 1년동안 오른/많이 오른 놈이 짱 개별주 1: 최근 1년 많이 오른 놈 + PER/PBR 낮은 저평가주 개별주 2: 비계량 선택 후에도 7번 지표들은 한번은 보자 사기 전 어느 조건에 팔지 알아라! 전략 선택전: 백테스트가 가장 중요하다!! 방법은 ‘할투’ 에 ","date":"2021-01-17","objectID":"/2021-01-17_halto-218/:12:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '218. (초보) 투자의 기초, 한시간 만에 완료!!' 정리","uri":"/2021-01-17_halto-218/#11요약"},{"categories":["python"],"content":" 0. 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c6. Metaclasses and Attributes\u003e Item 51: Prefer Class Decorators Over Metaclasses for Compoable Class Extensions Better Way 51. 합성 가능한 클래스 확장이 필요하면 메타클래스보다는 클래스 데코레이터를 사용하라 ","date":"2021-01-05","objectID":"/2021-01-05_class-decorator/:1:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 51. 합성 가능한 클래스 확장이 필요하면 메타클래스보다는 클래스 데코레이터를 사용하라' 정리","uri":"/2021-01-05_class-decorator/#0-들어가며"},{"categories":["python"],"content":" 1. 한 줄 요약 및 첨언클래스 데코레이터를 사용하면 클래스를 쉽게 확장할 수 있습니다. ","date":"2021-01-05","objectID":"/2021-01-05_class-decorator/:2:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 51. 합성 가능한 클래스 확장이 필요하면 메타클래스보다는 클래스 데코레이터를 사용하라' 정리","uri":"/2021-01-05_class-decorator/#1-한-줄-요약-및-첨언"},{"categories":["python"],"content":" 2. 사용 예시어떤 클래스의 모든 메서드에 대해서 호출 결과를 출력하고 싶은 상황입니다. ​ ‘Better way 26. functools.wrap을 사용해 함수 데코레이터를 정의하라’ 정리와 비슷하게 trace_func()을 적용하고 싶습니다. ​ import types from functools import wraps ​ ​ # Example 1 def trace_func(func): if hasattr(func, 'tracing'): # Only decorate once return func ​ @wraps(func) def wrapper(*args, **kwargs): result = None try: result = func(*args, **kwargs) return result except Exception as e: result = e raise finally: print(f'{func.__name__}({args!r}, {kwargs!r}) -\u003e {result!r}') # 요걸 출력하고 싶음 ​ wrapper.tracing = True return wrapper ​ 클래스 데코레이터를 적용한 예제입니다. ​ # Example 4 trace_types = ( types.MethodType, types.FunctionType, types.BuiltinFunctionType, types.BuiltinMethodType, types.MethodDescriptorType, types.ClassMethodDescriptorType) ​ ​ # Example 9 (데코레이터 함수: 인자로 받은 클래스를 적절히 변경해서 재생성함) def trace(klass): for key in dir(klass): value = getattr(klass, key) if isinstance(value, trace_types): wrapped = trace_func(value) setattr(klass, key, wrapped) return klass ​ ​ # Example 10 @trace # TraceDict 클래스에 @trace 클래스 데코레이터 적용 class TraceDict(dict): pass ​ TraceDict 클래스 사용 부분 입니다. ​ trace_dict = TraceDict([('hi', 1)]) trace_dict['there'] = 2 temp = trace_dict['hi'] try: temp = trace_dict['does not exist'] except KeyError: pass # Expected else: assert False ​ 실행 결과 입니다. ​ __new__((\u003cclass '__main__.TraceDict'\u003e, [('hi', 1)]), {}) -\u003e {} __getitem__(({'hi': 1, 'there': 2}, 'hi'), {}) -\u003e 1 __getitem__(({'hi': 1, 'there': 2}, 'does not exist'), {}) -\u003e KeyError('does not exist') ","date":"2021-01-05","objectID":"/2021-01-05_class-decorator/:3:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 51. 합성 가능한 클래스 확장이 필요하면 메타클래스보다는 클래스 데코레이터를 사용하라' 정리","uri":"/2021-01-05_class-decorator/#2-사용-예시"},{"categories":["python"],"content":" 3. 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip A class decorator is a simple function that receives a class instance as a parameter and returns either a new class or a modified version of the original class. 클래스 데코레이터는 class 인스턴스를 파라미터로 받아서 이 클래스를 변경한 클래스나 새로운 클래스를 반환해주는 간단한 함수다. Tip Class decorators are useful when you want to modify every method or attribute of a class with minimal boilerplate. 준비 코드를 최소화하면서 클래스 내부의 모든 메서드나 애트리뷰트를 변경하고 싶을 때 클래스 데코레이터가 유용하다. Tip Metaclasses can’t be composed together easily, while many class decorators can be used to extend the same class without conflicts. 메타클래스는 서로 쉽게 합성할 수 없지만, 여러 클래스 데코레이터를 충돌 없이 사용해 똑같은 클래스를 확장할 수 있다. ","date":"2021-01-05","objectID":"/2021-01-05_class-decorator/:4:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 51. 합성 가능한 클래스 확장이 필요하면 메타클래스보다는 클래스 데코레이터를 사용하라' 정리","uri":"/2021-01-05_class-decorator/#3-기억해야-할-내용"},{"categories":["python"],"content":" 10. 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 원저자 깃허브 ","date":"2021-01-05","objectID":"/2021-01-05_class-decorator/:5:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 51. 합성 가능한 클래스 확장이 필요하면 메타클래스보다는 클래스 데코레이터를 사용하라' 정리","uri":"/2021-01-05_class-decorator/#10-참고-자료"},{"categories":["python"],"content":" 0. 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c6. Metaclasses and Attributes\u003e Item 50: Annotate Class Attributes with __set_name__ Better Way 50. set_name으로 클래스 애트리뷰트를 표시하라 ","date":"2021-01-04","objectID":"/2021-01-04_set-name/:1:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 50. __set_name__으로 클래스 애트리뷰트를 표시하라' 정리","uri":"/2021-01-04_set-name/#0-들어가며"},{"categories":["python"],"content":" 1. 한 줄 요약 및 첨언디스크립터에 __set_name__을 구현하면 디스크립터가 만들어 질 때, 해당 디스크립터를 할당 할 변수명을 미리 받을 수 있습니다. 파이썬 3.6에 도입 되었습니다. ※ 디스크립터 : 다른 클래스의 어트리뷰트로 쓰이는 클래스인데, __set__, __get__, __del__ 중 하나라도 구현한 클래스 ","date":"2021-01-04","objectID":"/2021-01-04_set-name/:2:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 50. __set_name__으로 클래스 애트리뷰트를 표시하라' 정리","uri":"/2021-01-04_set-name/#1-한-줄-요약-및-첨언"},{"categories":["python"],"content":" 2. 사용 예시할당할 변수명을 미리 받아서, 해당 이름을 내부 애트리뷰트로 사용하는 예제입니다. # Example 11 class Field: def __init__(self): self.name = None self.internal_name = None def __set_name__(self, owner, name): print('__set_name__', owner, name) # Called on class creation for each descriptor self.name = name self.internal_name = '_' + name def __get__(self, instance, instance_type): if instance is None: return self return getattr(instance, self.internal_name, '') def __set__(self, instance, value): setattr(instance, self.internal_name, value) # Example 12 print('\\n==Before FixedCustomer==') class FixedCustomer: first_name = Field() # 요 때, __set_name__ 이 불림. name 이 first_name last_name = Field() prefix = Field() suffix = Field() print('\\n==Before cust==') cust = FixedCustomer() print(f'Before: {cust.first_name!r} {cust.__dict__}') # Before: '' {} cust.first_name = 'Mersenne' print(f'After: {cust.first_name!r} {cust.__dict__}') # After: 'Mersenne' {'_first_name': 'Mersenne'} ==Before FixedCustomer== __set_name__ \u003cclass '__main__.FixedCustomer'\u003e first_name __set_name__ \u003cclass '__main__.FixedCustomer'\u003e last_name __set_name__ \u003cclass '__main__.FixedCustomer'\u003e prefix __set_name__ \u003cclass '__main__.FixedCustomer'\u003e suffix ==Before cust== Before: '' {} After: 'Mersenne' {'_first_name': 'Mersenne'} ","date":"2021-01-04","objectID":"/2021-01-04_set-name/:3:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 50. __set_name__으로 클래스 애트리뷰트를 표시하라' 정리","uri":"/2021-01-04_set-name/#2-사용-예시"},{"categories":["python"],"content":" 3. 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Metaclasses enable you to modify a class’s attributes before the class is fully defined. 메타클래스를 사용하면 어떤 클래스가 완전히 정의되기 전에 클래스의 애트리뷰트를 변경할 수 있다. Tip Descriptors and metaclasses make a powerful combination for declarative behavior and runtime introspection. 디스크립터와 메타클래스를 조합하면 강력한 실행 시점 코드 검사와 선언적인 동작을 만들 수 있다. Tip Define __set_name__ on your descriptor classes to allow them to take into account their surrounding class and its property names. __set_name__ 특별 메서드를 디스크립터 클래스에 정의하면 디스크립터가 포함된 클래스의 프로퍼티 이름을 처리할 수 있다. Tip Avoid memory leaks and the weakref built-in module by having descriptors store data they manipulate directly within a class’s instance dictionary. 디스크립터가 변경한 클래스의 인스턴스 딕셔너리에 데이터를 저장하게 만들면 메모리 누수를 피할 수 있고, weakref 내장 메서드를 사용하지 않아도 된다. ","date":"2021-01-04","objectID":"/2021-01-04_set-name/:4:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 50. __set_name__으로 클래스 애트리뷰트를 표시하라' 정리","uri":"/2021-01-04_set-name/#3-기억해야-할-내용"},{"categories":["python"],"content":" 4. 더 알아보기","date":"2021-01-04","objectID":"/2021-01-04_set-name/:5:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 50. __set_name__으로 클래스 애트리뷰트를 표시하라' 정리","uri":"/2021-01-04_set-name/#4-더-알아보기"},{"categories":["python"],"content":" 4.1 메타클래스를 사용했다면옛날 방식인 듯 합니다. # Example 7 class Field: def __init__(self): # These will be assigned by the metaclass. self.name = None self.internal_name = None def __get__(self, instance, instance_type): if instance is None: return self return getattr(instance, self.internal_name, '') def __set__(self, instance, value): setattr(instance, self.internal_name, value) # Example 5 class Meta(type): def __new__(meta, name, bases, class_dict): for key, value in class_dict.items(): if isinstance(value, Field): value.name = key value.internal_name = '_' + key cls = type.__new__(meta, name, bases, class_dict) return cls # Example 6 class DatabaseRow(metaclass=Meta): pass # Example 8 class BetterCustomer(DatabaseRow): first_name = Field() last_name = Field() prefix = Field() suffix = Field() # Example 9 cust = BetterCustomer() print(f'Before: {cust.first_name!r} {cust.__dict__}') # Before: '' {} cust.first_name = 'Euler' print(f'After: {cust.first_name!r} {cust.__dict__}') # After: 'Euler' {'_first_name': 'Euler'} ","date":"2021-01-04","objectID":"/2021-01-04_set-name/:5:1","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 50. __set_name__으로 클래스 애트리뷰트를 표시하라' 정리","uri":"/2021-01-04_set-name/#41-메타클래스를-사용했다면"},{"categories":["python"],"content":" 10. 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 원저자 깃허브 ‘Better way 46. 재사용 가능한 @property 메서드를 만들려면 디스크립터를 사용하라’ 정리 Descriptor HowTo Guide / 파이썬 공식 문서 ","date":"2021-01-04","objectID":"/2021-01-04_set-name/:6:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 50. __set_name__으로 클래스 애트리뷰트를 표시하라' 정리","uri":"/2021-01-04_set-name/#10-참고-자료"},{"categories":["투자 일반"],"content":" 0. 들어가며연말에 장거리 운전하는 길에 Page 2 앱으로 지난 컨텐츠들을 쭉 들었습니다. 별 생각 없이 듣다가, 이건 메모 해둬야 한다는 생각이 들었습니다. 박병창 부장이 말하는 돈을 부르는 매매의 타이밍! [신과함께 연말특집 2탄] 최근에 책도 내신 것 같은데(주식 투자 기본도 모르고 할 뻔했다), 이북으로 나오면 바로 구매하도록 하겠습니다. ","date":"2021-01-03","objectID":"/2021-01-03_trading-skill/:1:0","series":null,"tags":null,"title":"삼프로TV '박병창 부장이 말하는 돈을 부르는 매매의 타이밍!' 정리","uri":"/2021-01-03_trading-skill/#0-들어가며"},{"categories":["투자 일반"],"content":" 1. 핵심 정리 및 첨언 변동성이 클 때가 매매 타이밍 (하루 중에는 장 시작후 1시간, 장 마감전 40분) 패닉리스트(패닉장에서도 자신있게 살 수 있는)를 미리 만들어 둬야 함 거래량이 없다가 급증하는 신호를 활용하라 아침에 평소보다 큰 체결 단위가 잦다면 신호일 가능성이 많다. ‘거래량이 중요하다’라는 말은 많이 들었는데, 어떻게 봐야 하는 지 어렴풋하게나마 그림이 보이는 느낌입니다. 거래량의 급증으로 매매 타이밍을 잘 잡아야 겠습니다. ","date":"2021-01-03","objectID":"/2021-01-03_trading-skill/:2:0","series":null,"tags":null,"title":"삼프로TV '박병창 부장이 말하는 돈을 부르는 매매의 타이밍!' 정리","uri":"/2021-01-03_trading-skill/#1-핵심-정리-및-첨언"},{"categories":["투자 일반"],"content":" 2. 세부 내용","date":"2021-01-03","objectID":"/2021-01-03_trading-skill/:3:0","series":null,"tags":null,"title":"삼프로TV '박병창 부장이 말하는 돈을 부르는 매매의 타이밍!' 정리","uri":"/2021-01-03_trading-skill/#2-세부-내용"},{"categories":["투자 일반"],"content":" 2.0 전제 조건가장 중요한 것은 좋은 주식을 선정하는 것 이미 종목 선정을 했다는 가정하에 해당 종목을 거래자들의 심리를 토대로 조금 더 잘 사고, 잘 팔기 위한 방법에 대한 이야기 ","date":"2021-01-03","objectID":"/2021-01-03_trading-skill/:3:1","series":null,"tags":null,"title":"삼프로TV '박병창 부장이 말하는 돈을 부르는 매매의 타이밍!' 정리","uri":"/2021-01-03_trading-skill/#20-전제-조건"},{"categories":["투자 일반"],"content":" 2.1 변동성이 클 때가 매매 타이밍지난 시간을 돌이켜 보면, 가장 좋은 매매 타이밍은 변동성일 클 때. 겁나는 상황에서도 들어 갈수 있으려면, 패닉리스트를 미리 만들어 두어야 함. 시간을 줄여도 변동성이 클 때가 매매 타이밍. 지정학적 리스크 이벤트가 생기거나, 실적 발표 시즌에도 변동성이 큼. 데일리로 적용하면, 아침 시작 후 1시간, 끝나기 전 30~40분에 변동성이 큼. 아침의 거래량, 양봉의 크기, 기관이나 외국인의 프로그램 거래가 얼마나 들어오느냐로 알고리즘 매매하는 경우도 있음. 강세장, 강세 종목https://youtu.be/pRQjRH9AVrI?t=1166 아침에 잠깐 밀리는 타이밍에 사려는 노력 요 타이밍 놓치고 올라가 버리면 못사게 됨. 약세장, 약세 종목아침에 사면 안 됨. 뜨는 척하지만 아닐 가능성이 큼 끝까지 기다려 봐야 함. 오후에 판단해야 함. 거래량이 늘어나야하고, 양봉이 나타나야 함 또 하락하면, 그 시그널이 다시 나올때까지 기다림 강세장, 약한 종목2~2일 올라갔다가, 2~3일 빠지는 추세적인 움직임 눌림목을 기다려야 함. 자기 혼자 올라가지 못하므로, 순환매 거래를 해야 함 약세장, 강한 종목아침에 변동성에 매수 단기 거래. 시장이 약세라 조금 올라가면 매도가 나옴. 저점 판단https://youtu.be/pRQjRH9AVrI?t=1453 매일 매일 오후까지 지켜봄 거래량이 크게 증가, 장대 양봉이 나오면 1차 매수 혹시 하락하면, 다시 시그널이 나올 하락이 이전 저점을 깨지 않는다면 역헤드앤숄더의 오른쪽 발목 약세장에서는 이런 판단을 오후에 해야 함. 고점 판단https://youtu.be/pRQjRH9AVrI?t=1597 제시 리버모어의 공매도 기법 저점 판단의 반대로 거래량 없이 시장은 계속 상승함. 거래량 급증, 장대 음봉이 나타나면 시그널 거래량이 크면 클수록 확실한 시그널 1차로 공매도. 혹시 더 올라가면 내 생각이 맞을 때까지 기다림. ","date":"2021-01-03","objectID":"/2021-01-03_trading-skill/:3:2","series":null,"tags":null,"title":"삼프로TV '박병창 부장이 말하는 돈을 부르는 매매의 타이밍!' 정리","uri":"/2021-01-03_trading-skill/#21-변동성이-클-때가-매매-타이밍"},{"categories":["투자 일반"],"content":" 2.1 변동성이 클 때가 매매 타이밍지난 시간을 돌이켜 보면, 가장 좋은 매매 타이밍은 변동성일 클 때. 겁나는 상황에서도 들어 갈수 있으려면, 패닉리스트를 미리 만들어 두어야 함. 시간을 줄여도 변동성이 클 때가 매매 타이밍. 지정학적 리스크 이벤트가 생기거나, 실적 발표 시즌에도 변동성이 큼. 데일리로 적용하면, 아침 시작 후 1시간, 끝나기 전 30~40분에 변동성이 큼. 아침의 거래량, 양봉의 크기, 기관이나 외국인의 프로그램 거래가 얼마나 들어오느냐로 알고리즘 매매하는 경우도 있음. 강세장, 강세 종목https://youtu.be/pRQjRH9AVrI?t=1166 아침에 잠깐 밀리는 타이밍에 사려는 노력 요 타이밍 놓치고 올라가 버리면 못사게 됨. 약세장, 약세 종목아침에 사면 안 됨. 뜨는 척하지만 아닐 가능성이 큼 끝까지 기다려 봐야 함. 오후에 판단해야 함. 거래량이 늘어나야하고, 양봉이 나타나야 함 또 하락하면, 그 시그널이 다시 나올때까지 기다림 강세장, 약한 종목2~2일 올라갔다가, 2~3일 빠지는 추세적인 움직임 눌림목을 기다려야 함. 자기 혼자 올라가지 못하므로, 순환매 거래를 해야 함 약세장, 강한 종목아침에 변동성에 매수 단기 거래. 시장이 약세라 조금 올라가면 매도가 나옴. 저점 판단https://youtu.be/pRQjRH9AVrI?t=1453 매일 매일 오후까지 지켜봄 거래량이 크게 증가, 장대 양봉이 나오면 1차 매수 혹시 하락하면, 다시 시그널이 나올 하락이 이전 저점을 깨지 않는다면 역헤드앤숄더의 오른쪽 발목 약세장에서는 이런 판단을 오후에 해야 함. 고점 판단https://youtu.be/pRQjRH9AVrI?t=1597 제시 리버모어의 공매도 기법 저점 판단의 반대로 거래량 없이 시장은 계속 상승함. 거래량 급증, 장대 음봉이 나타나면 시그널 거래량이 크면 클수록 확실한 시그널 1차로 공매도. 혹시 더 올라가면 내 생각이 맞을 때까지 기다림. ","date":"2021-01-03","objectID":"/2021-01-03_trading-skill/:3:2","series":null,"tags":null,"title":"삼프로TV '박병창 부장이 말하는 돈을 부르는 매매의 타이밍!' 정리","uri":"/2021-01-03_trading-skill/#강세장-강세-종목"},{"categories":["투자 일반"],"content":" 2.1 변동성이 클 때가 매매 타이밍지난 시간을 돌이켜 보면, 가장 좋은 매매 타이밍은 변동성일 클 때. 겁나는 상황에서도 들어 갈수 있으려면, 패닉리스트를 미리 만들어 두어야 함. 시간을 줄여도 변동성이 클 때가 매매 타이밍. 지정학적 리스크 이벤트가 생기거나, 실적 발표 시즌에도 변동성이 큼. 데일리로 적용하면, 아침 시작 후 1시간, 끝나기 전 30~40분에 변동성이 큼. 아침의 거래량, 양봉의 크기, 기관이나 외국인의 프로그램 거래가 얼마나 들어오느냐로 알고리즘 매매하는 경우도 있음. 강세장, 강세 종목https://youtu.be/pRQjRH9AVrI?t=1166 아침에 잠깐 밀리는 타이밍에 사려는 노력 요 타이밍 놓치고 올라가 버리면 못사게 됨. 약세장, 약세 종목아침에 사면 안 됨. 뜨는 척하지만 아닐 가능성이 큼 끝까지 기다려 봐야 함. 오후에 판단해야 함. 거래량이 늘어나야하고, 양봉이 나타나야 함 또 하락하면, 그 시그널이 다시 나올때까지 기다림 강세장, 약한 종목2~2일 올라갔다가, 2~3일 빠지는 추세적인 움직임 눌림목을 기다려야 함. 자기 혼자 올라가지 못하므로, 순환매 거래를 해야 함 약세장, 강한 종목아침에 변동성에 매수 단기 거래. 시장이 약세라 조금 올라가면 매도가 나옴. 저점 판단https://youtu.be/pRQjRH9AVrI?t=1453 매일 매일 오후까지 지켜봄 거래량이 크게 증가, 장대 양봉이 나오면 1차 매수 혹시 하락하면, 다시 시그널이 나올 하락이 이전 저점을 깨지 않는다면 역헤드앤숄더의 오른쪽 발목 약세장에서는 이런 판단을 오후에 해야 함. 고점 판단https://youtu.be/pRQjRH9AVrI?t=1597 제시 리버모어의 공매도 기법 저점 판단의 반대로 거래량 없이 시장은 계속 상승함. 거래량 급증, 장대 음봉이 나타나면 시그널 거래량이 크면 클수록 확실한 시그널 1차로 공매도. 혹시 더 올라가면 내 생각이 맞을 때까지 기다림. ","date":"2021-01-03","objectID":"/2021-01-03_trading-skill/:3:2","series":null,"tags":null,"title":"삼프로TV '박병창 부장이 말하는 돈을 부르는 매매의 타이밍!' 정리","uri":"/2021-01-03_trading-skill/#약세장-약세-종목"},{"categories":["투자 일반"],"content":" 2.1 변동성이 클 때가 매매 타이밍지난 시간을 돌이켜 보면, 가장 좋은 매매 타이밍은 변동성일 클 때. 겁나는 상황에서도 들어 갈수 있으려면, 패닉리스트를 미리 만들어 두어야 함. 시간을 줄여도 변동성이 클 때가 매매 타이밍. 지정학적 리스크 이벤트가 생기거나, 실적 발표 시즌에도 변동성이 큼. 데일리로 적용하면, 아침 시작 후 1시간, 끝나기 전 30~40분에 변동성이 큼. 아침의 거래량, 양봉의 크기, 기관이나 외국인의 프로그램 거래가 얼마나 들어오느냐로 알고리즘 매매하는 경우도 있음. 강세장, 강세 종목https://youtu.be/pRQjRH9AVrI?t=1166 아침에 잠깐 밀리는 타이밍에 사려는 노력 요 타이밍 놓치고 올라가 버리면 못사게 됨. 약세장, 약세 종목아침에 사면 안 됨. 뜨는 척하지만 아닐 가능성이 큼 끝까지 기다려 봐야 함. 오후에 판단해야 함. 거래량이 늘어나야하고, 양봉이 나타나야 함 또 하락하면, 그 시그널이 다시 나올때까지 기다림 강세장, 약한 종목2~2일 올라갔다가, 2~3일 빠지는 추세적인 움직임 눌림목을 기다려야 함. 자기 혼자 올라가지 못하므로, 순환매 거래를 해야 함 약세장, 강한 종목아침에 변동성에 매수 단기 거래. 시장이 약세라 조금 올라가면 매도가 나옴. 저점 판단https://youtu.be/pRQjRH9AVrI?t=1453 매일 매일 오후까지 지켜봄 거래량이 크게 증가, 장대 양봉이 나오면 1차 매수 혹시 하락하면, 다시 시그널이 나올 하락이 이전 저점을 깨지 않는다면 역헤드앤숄더의 오른쪽 발목 약세장에서는 이런 판단을 오후에 해야 함. 고점 판단https://youtu.be/pRQjRH9AVrI?t=1597 제시 리버모어의 공매도 기법 저점 판단의 반대로 거래량 없이 시장은 계속 상승함. 거래량 급증, 장대 음봉이 나타나면 시그널 거래량이 크면 클수록 확실한 시그널 1차로 공매도. 혹시 더 올라가면 내 생각이 맞을 때까지 기다림. ","date":"2021-01-03","objectID":"/2021-01-03_trading-skill/:3:2","series":null,"tags":null,"title":"삼프로TV '박병창 부장이 말하는 돈을 부르는 매매의 타이밍!' 정리","uri":"/2021-01-03_trading-skill/#강세장-약한-종목"},{"categories":["투자 일반"],"content":" 2.1 변동성이 클 때가 매매 타이밍지난 시간을 돌이켜 보면, 가장 좋은 매매 타이밍은 변동성일 클 때. 겁나는 상황에서도 들어 갈수 있으려면, 패닉리스트를 미리 만들어 두어야 함. 시간을 줄여도 변동성이 클 때가 매매 타이밍. 지정학적 리스크 이벤트가 생기거나, 실적 발표 시즌에도 변동성이 큼. 데일리로 적용하면, 아침 시작 후 1시간, 끝나기 전 30~40분에 변동성이 큼. 아침의 거래량, 양봉의 크기, 기관이나 외국인의 프로그램 거래가 얼마나 들어오느냐로 알고리즘 매매하는 경우도 있음. 강세장, 강세 종목https://youtu.be/pRQjRH9AVrI?t=1166 아침에 잠깐 밀리는 타이밍에 사려는 노력 요 타이밍 놓치고 올라가 버리면 못사게 됨. 약세장, 약세 종목아침에 사면 안 됨. 뜨는 척하지만 아닐 가능성이 큼 끝까지 기다려 봐야 함. 오후에 판단해야 함. 거래량이 늘어나야하고, 양봉이 나타나야 함 또 하락하면, 그 시그널이 다시 나올때까지 기다림 강세장, 약한 종목2~2일 올라갔다가, 2~3일 빠지는 추세적인 움직임 눌림목을 기다려야 함. 자기 혼자 올라가지 못하므로, 순환매 거래를 해야 함 약세장, 강한 종목아침에 변동성에 매수 단기 거래. 시장이 약세라 조금 올라가면 매도가 나옴. 저점 판단https://youtu.be/pRQjRH9AVrI?t=1453 매일 매일 오후까지 지켜봄 거래량이 크게 증가, 장대 양봉이 나오면 1차 매수 혹시 하락하면, 다시 시그널이 나올 하락이 이전 저점을 깨지 않는다면 역헤드앤숄더의 오른쪽 발목 약세장에서는 이런 판단을 오후에 해야 함. 고점 판단https://youtu.be/pRQjRH9AVrI?t=1597 제시 리버모어의 공매도 기법 저점 판단의 반대로 거래량 없이 시장은 계속 상승함. 거래량 급증, 장대 음봉이 나타나면 시그널 거래량이 크면 클수록 확실한 시그널 1차로 공매도. 혹시 더 올라가면 내 생각이 맞을 때까지 기다림. ","date":"2021-01-03","objectID":"/2021-01-03_trading-skill/:3:2","series":null,"tags":null,"title":"삼프로TV '박병창 부장이 말하는 돈을 부르는 매매의 타이밍!' 정리","uri":"/2021-01-03_trading-skill/#약세장-강한-종목"},{"categories":["투자 일반"],"content":" 2.1 변동성이 클 때가 매매 타이밍지난 시간을 돌이켜 보면, 가장 좋은 매매 타이밍은 변동성일 클 때. 겁나는 상황에서도 들어 갈수 있으려면, 패닉리스트를 미리 만들어 두어야 함. 시간을 줄여도 변동성이 클 때가 매매 타이밍. 지정학적 리스크 이벤트가 생기거나, 실적 발표 시즌에도 변동성이 큼. 데일리로 적용하면, 아침 시작 후 1시간, 끝나기 전 30~40분에 변동성이 큼. 아침의 거래량, 양봉의 크기, 기관이나 외국인의 프로그램 거래가 얼마나 들어오느냐로 알고리즘 매매하는 경우도 있음. 강세장, 강세 종목https://youtu.be/pRQjRH9AVrI?t=1166 아침에 잠깐 밀리는 타이밍에 사려는 노력 요 타이밍 놓치고 올라가 버리면 못사게 됨. 약세장, 약세 종목아침에 사면 안 됨. 뜨는 척하지만 아닐 가능성이 큼 끝까지 기다려 봐야 함. 오후에 판단해야 함. 거래량이 늘어나야하고, 양봉이 나타나야 함 또 하락하면, 그 시그널이 다시 나올때까지 기다림 강세장, 약한 종목2~2일 올라갔다가, 2~3일 빠지는 추세적인 움직임 눌림목을 기다려야 함. 자기 혼자 올라가지 못하므로, 순환매 거래를 해야 함 약세장, 강한 종목아침에 변동성에 매수 단기 거래. 시장이 약세라 조금 올라가면 매도가 나옴. 저점 판단https://youtu.be/pRQjRH9AVrI?t=1453 매일 매일 오후까지 지켜봄 거래량이 크게 증가, 장대 양봉이 나오면 1차 매수 혹시 하락하면, 다시 시그널이 나올 하락이 이전 저점을 깨지 않는다면 역헤드앤숄더의 오른쪽 발목 약세장에서는 이런 판단을 오후에 해야 함. 고점 판단https://youtu.be/pRQjRH9AVrI?t=1597 제시 리버모어의 공매도 기법 저점 판단의 반대로 거래량 없이 시장은 계속 상승함. 거래량 급증, 장대 음봉이 나타나면 시그널 거래량이 크면 클수록 확실한 시그널 1차로 공매도. 혹시 더 올라가면 내 생각이 맞을 때까지 기다림. ","date":"2021-01-03","objectID":"/2021-01-03_trading-skill/:3:2","series":null,"tags":null,"title":"삼프로TV '박병창 부장이 말하는 돈을 부르는 매매의 타이밍!' 정리","uri":"/2021-01-03_trading-skill/#저점-판단"},{"categories":["투자 일반"],"content":" 2.1 변동성이 클 때가 매매 타이밍지난 시간을 돌이켜 보면, 가장 좋은 매매 타이밍은 변동성일 클 때. 겁나는 상황에서도 들어 갈수 있으려면, 패닉리스트를 미리 만들어 두어야 함. 시간을 줄여도 변동성이 클 때가 매매 타이밍. 지정학적 리스크 이벤트가 생기거나, 실적 발표 시즌에도 변동성이 큼. 데일리로 적용하면, 아침 시작 후 1시간, 끝나기 전 30~40분에 변동성이 큼. 아침의 거래량, 양봉의 크기, 기관이나 외국인의 프로그램 거래가 얼마나 들어오느냐로 알고리즘 매매하는 경우도 있음. 강세장, 강세 종목https://youtu.be/pRQjRH9AVrI?t=1166 아침에 잠깐 밀리는 타이밍에 사려는 노력 요 타이밍 놓치고 올라가 버리면 못사게 됨. 약세장, 약세 종목아침에 사면 안 됨. 뜨는 척하지만 아닐 가능성이 큼 끝까지 기다려 봐야 함. 오후에 판단해야 함. 거래량이 늘어나야하고, 양봉이 나타나야 함 또 하락하면, 그 시그널이 다시 나올때까지 기다림 강세장, 약한 종목2~2일 올라갔다가, 2~3일 빠지는 추세적인 움직임 눌림목을 기다려야 함. 자기 혼자 올라가지 못하므로, 순환매 거래를 해야 함 약세장, 강한 종목아침에 변동성에 매수 단기 거래. 시장이 약세라 조금 올라가면 매도가 나옴. 저점 판단https://youtu.be/pRQjRH9AVrI?t=1453 매일 매일 오후까지 지켜봄 거래량이 크게 증가, 장대 양봉이 나오면 1차 매수 혹시 하락하면, 다시 시그널이 나올 하락이 이전 저점을 깨지 않는다면 역헤드앤숄더의 오른쪽 발목 약세장에서는 이런 판단을 오후에 해야 함. 고점 판단https://youtu.be/pRQjRH9AVrI?t=1597 제시 리버모어의 공매도 기법 저점 판단의 반대로 거래량 없이 시장은 계속 상승함. 거래량 급증, 장대 음봉이 나타나면 시그널 거래량이 크면 클수록 확실한 시그널 1차로 공매도. 혹시 더 올라가면 내 생각이 맞을 때까지 기다림. ","date":"2021-01-03","objectID":"/2021-01-03_trading-skill/:3:2","series":null,"tags":null,"title":"삼프로TV '박병창 부장이 말하는 돈을 부르는 매매의 타이밍!' 정리","uri":"/2021-01-03_trading-skill/#고점-판단"},{"categories":["투자 일반"],"content":" 2.2 거래량https://youtu.be/pRQjRH9AVrI?t=1909 가격이 많이 올라왔을 때는 거래량 없는 게 좋은 것 → 팔고 싶은 사람이 없음 거래량 없이 가격이 많이 올라왔는 데 거래량이 터짐 → 곰이 나타났음, 추세 전환 가능성 있음 주가가 많이 올라간 상태에서 거래량이 터지면 → 안 좋은 것 주가가 많이 내려간 상태에서 거래량이 터지면 → 좋은 것 올라가는 중에는 거래량이 없어야 많이 감 내려가는 중에는 거래량이 없어야 나중에 올라올 때 쉽게 올라 감 ","date":"2021-01-03","objectID":"/2021-01-03_trading-skill/:3:3","series":null,"tags":null,"title":"삼프로TV '박병창 부장이 말하는 돈을 부르는 매매의 타이밍!' 정리","uri":"/2021-01-03_trading-skill/#22-거래량"},{"categories":["투자 일반"],"content":" 2.3 시간과 주식 보유의 기간https://youtu.be/pRQjRH9AVrI?t=2132 시간은 리스크 단기 거래자가 아니라면 시간 리스크를 안고 가야함 사이클에 맞춰서 거래하는 습관이 중요함 딱 고부분만 하고 나와야 ","date":"2021-01-03","objectID":"/2021-01-03_trading-skill/:3:4","series":null,"tags":null,"title":"삼프로TV '박병창 부장이 말하는 돈을 부르는 매매의 타이밍!' 정리","uri":"/2021-01-03_trading-skill/#23-시간과-주식-보유의-기간"},{"categories":["투자 일반"],"content":" 2.4 주가의 기울기https://youtu.be/pRQjRH9AVrI?t=2336 이론적으로 주가의 기울기는 영업이익의 기울기 가파르게 오른 주식은 하락도 가파르게 (타이밍도 빠르게) 완만하게 오른 주식은 하락도 완만하게 (매수 매도 타이밍도 완만하게) 가파르게 오른 종목이, 가파르게 찔끔 빠지다가 다시 올라 가는게 진짜 쎈 종목 ","date":"2021-01-03","objectID":"/2021-01-03_trading-skill/:3:5","series":null,"tags":null,"title":"삼프로TV '박병창 부장이 말하는 돈을 부르는 매매의 타이밍!' 정리","uri":"/2021-01-03_trading-skill/#24-주가의-기울기"},{"categories":["투자 일반"],"content":" 2.5 호가 잔량의 해석https://youtu.be/pRQjRH9AVrI?t=2498 하루 종일 빠지는 종목 → 매수 호가가 더 많음 위로 사거나, 아래로 파는 사람이 주가를 움직임 사고 싶은 사람은 있는 호가에 대고 삼 하루 중, 올라가고 있는데 (매도 호가 잔량이 더 많음), 위에서 매수 잔량은 많은데 매도 잔량이 없는 상황이 되면, 더 못 올라감. 올라가다가 장중에 체결이 잦아들면 조정의 신호. 곰이 나타나면 우르르 팔기 시작 함 ","date":"2021-01-03","objectID":"/2021-01-03_trading-skill/:3:6","series":null,"tags":null,"title":"삼프로TV '박병창 부장이 말하는 돈을 부르는 매매의 타이밍!' 정리","uri":"/2021-01-03_trading-skill/#25-호가-잔량의-해석"},{"categories":["투자 일반"],"content":" 2.6 체결량을 보면 주가를 예측할 수 있다https://youtu.be/pRQjRH9AVrI?t=2872 아침에도 체결 단위로 거래량을 알 수 있음 → 매수 혹은 매도 신호가 나옴 평소보다 큰 체결 단위가 다른 체결이 들어오면 체결 단위를 확인하라. 특이한 체결 단위가 없다면, 나도 가만히 있어야 함. ","date":"2021-01-03","objectID":"/2021-01-03_trading-skill/:3:7","series":null,"tags":null,"title":"삼프로TV '박병창 부장이 말하는 돈을 부르는 매매의 타이밍!' 정리","uri":"/2021-01-03_trading-skill/#26-체결량을-보면-주가를-예측할-수-있다"},{"categories":["투자 일반"],"content":" 2.7 주문 가격 내는 방법https://youtu.be/pRQjRH9AVrI?t=3088 마디 주가는 피하라 ","date":"2021-01-03","objectID":"/2021-01-03_trading-skill/:3:8","series":null,"tags":null,"title":"삼프로TV '박병창 부장이 말하는 돈을 부르는 매매의 타이밍!' 정리","uri":"/2021-01-03_trading-skill/#27-주문-가격-내는-방법"},{"categories":["투자 일반"],"content":" 2.8 정형화https://youtu.be/pRQjRH9AVrI?t=3403 약세 종목은 아침에 사지 않음 거래량 급증하고 양봉 나오는 것 보고 1차 분할 매수 혹시 더 떨어지면 기다림. 다시 거래량 급증하고 양봉 나오는 것 보고 추가 매수 강세 종목에 따라가고 싶으면 아침에 매수 ","date":"2021-01-03","objectID":"/2021-01-03_trading-skill/:3:9","series":null,"tags":null,"title":"삼프로TV '박병창 부장이 말하는 돈을 부르는 매매의 타이밍!' 정리","uri":"/2021-01-03_trading-skill/#28-정형화"},{"categories":["투자 일반"],"content":" 10. 참고 자료 박병창 부장이 말하는 돈을 부르는 매매의 타이밍! / 삼프로TV_경제의신과함께 신과 함께 특집 매매 타이밍 pdf / Page2 신의자료실 ","date":"2021-01-03","objectID":"/2021-01-03_trading-skill/:4:0","series":null,"tags":null,"title":"삼프로TV '박병창 부장이 말하는 돈을 부르는 매매의 타이밍!' 정리","uri":"/2021-01-03_trading-skill/#10-참고-자료"},{"categories":["python"],"content":" 0. 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c6. Metaclasses and Attributes\u003e Item 48: Validate Subclasses with __init_subclass__ Better way 48. __init_subclass__를 사용해 하위 클래스를 검증하라 ","date":"2020-12-29","objectID":"/2020-12-29_init-subclass/:1:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 48. __init_subclass__를 사용해 하위 클래스를 검증하라' 정리","uri":"/2020-12-29_init-subclass/#0-들어가며"},{"categories":["python"],"content":" 1. 한 줄 요약 및 첨언하위 클래스가 제대로 구현됐는지 확인하기 위해서는 __init_subclass__를 사용합니다. (파이썬 3.6에서 추가됨) 메타클래스를 정의하는 방법이 있었지만, 요게 훨씬 낫습니다. ","date":"2020-12-29","objectID":"/2020-12-29_init-subclass/:2:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 48. __init_subclass__를 사용해 하위 클래스를 검증하라' 정리","uri":"/2020-12-29_init-subclass/#1-한-줄-요약-및-첨언"},{"categories":["python"],"content":" 2. 사용 예시하위 클래스의 sides 가 3 이상인지 검증하는 예제입니다. # Example 4 class BetterPolygon: sides = None # Must be specified by subclasses def __init_subclass__(cls): print(f'* Running __init_subclass__ for {cls}') super().__init_subclass__() if cls.sides \u003c 3: raise ValueError('Polygons need 3+ sides') @classmethod def interior_angles(cls): return (cls.sides - 2) * 180 print('\\n== Before BetterPolygon') class Hexagon(BetterPolygon): sides = 6 print('Hexagon', Hexagon.interior_angles()) # Hexagon 720 print('\\n== Before Point') try: class Point(BetterPolygon): sides = 1 except ValueError as e: print('ValueError!!!', e) # ValueError!!! Polygons need 3+ sides == Before BetterPolygon * Running __init_subclass__ for \u003cclass '__main__.Hexagon'\u003e Hexagon 720 == Before Point * Running __init_subclass__ for \u003cclass '__main__.Point'\u003e ValueError!!! Polygons need 3+ sides BetterPolygon을 상속한 클래스를 정의하면, __init_subclass__ 가 불려서 클래스가 잘 정의되었는지 확인할 수 있습니다. ","date":"2020-12-29","objectID":"/2020-12-29_init-subclass/:3:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 48. __init_subclass__를 사용해 하위 클래스를 검증하라' 정리","uri":"/2020-12-29_init-subclass/#2-사용-예시"},{"categories":["python"],"content":" 3. 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip The __new__ method of metaclasses is run after the class statement’s entire body has been processed. 메타클래스의 __new__ 메서드는 class 문의 모든 본문이 처리된 직후에 호출된다. Tip Metaclasses can be used to inspect or modify a class after it’s defined but before it’s created, but they’re often more heavyweight than what you need. 메타클래스를 사용해 클래스가 정의된 직후이면서 클래스가 생성되기 직전인 시점에 클래스 정의를 변경할 수 있다. 하지만 메타클래스는 원하는 목적을 달성하기에 너무 복잡해지는 경우가 많다. Tip Use __init_subclass__ to ensure that subclasses are well formed at the time they are defined, before objects of their type are constructed. __init_subclass__를 사용해 하위 클래스가 정의된 직후, 하위 클래스 타입이 만들어지기 직전에 해당 클래스가 원하는 요건을 잘 갖췄는지 확인하라. Tip Be sure to call super().__init_subclass__ from within your class’s __init_subclass__ definition to enable validation in multiple layers of classes and multiple inheritance. __init_subclass__ 정의 안에서 super().__init_subclass__를 호출해 여러 계층에 걸쳐 클래시를 검증하고 다중 상속을 제대로 처리하도록 하라. ","date":"2020-12-29","objectID":"/2020-12-29_init-subclass/:4:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 48. __init_subclass__를 사용해 하위 클래스를 검증하라' 정리","uri":"/2020-12-29_init-subclass/#3-기억해야-할-내용"},{"categories":["python"],"content":" 4. 더 알아보기","date":"2020-12-29","objectID":"/2020-12-29_init-subclass/:5:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 48. __init_subclass__를 사용해 하위 클래스를 검증하라' 정리","uri":"/2020-12-29_init-subclass/#4-더-알아보기"},{"categories":["python"],"content":" 4.1 메타클래스를 사용했다면__init_subclass__를 사용할 거지만, 예전의 메타클래스 방식도 알아두도록 합시다. from pprint import pprint # Example 2 class ValidatePolygon(type): # 메타클래스 정의 def __new__(meta, name, bases, class_dict): # Only validate subclasses of the Polygon class print(f'* Running {meta}.__new__ for {name}') print('Bases:', bases) pprint(class_dict) if bases: if class_dict['sides'] \u003c 3: raise ValueError('Polygons need 3+ sides') return type.__new__(meta, name, bases, class_dict) print('\\n== Before Polygon') class Polygon(metaclass=ValidatePolygon): sides = None # Must be specified by subclasses @classmethod def interior_angles(cls): return (cls.sides - 2) * 180 print('\\n== Before Triangle') class Triangle(Polygon): sides = 3 print('Triangle', Triangle.interior_angles()) print('\\n== Before Line') try: class Line(Polygon): print('Before sides') sides = 2 print('After sides') # 여기도 불림 except ValueError as e: print('ValueError!!', e) 메타클래스를 상속받은 클래스의 정의 코드가 실행되면, 메타 클래스의 __new__가 실행되고, 여기에서 클래스가 잘 구현되었는지 검증할 수 있습니다. == Before Polygon * Running \u003cclass '__main__.ValidatePolygon'\u003e.__new__ for Polygon Bases: () {'__module__': '__main__', '__qualname__': 'Polygon', 'interior_angles': \u003cclassmethod object at 0x00000263CF7A91F0\u003e, 'sides': None} == Before Triangle * Running \u003cclass '__main__.ValidatePolygon'\u003e.__new__ for Triangle Bases: (\u003cclass '__main__.Polygon'\u003e,) {'__module__': '__main__', '__qualname__': 'Triangle', 'sides': 3} Triangle 180 == Before Line Before sides After sides * Running \u003cclass '__main__.ValidatePolygon'\u003e.__new__ for Line Bases: (\u003cclass '__main__.Polygon'\u003e,) {'__module__': '__main__', '__qualname__': 'Line', 'sides': 2} ValueError!! Polygons need 3+ sides sides 값이 2가 들어와서 ValueError 를 발생시켰습니다. ","date":"2020-12-29","objectID":"/2020-12-29_init-subclass/:5:1","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 48. __init_subclass__를 사용해 하위 클래스를 검증하라' 정리","uri":"/2020-12-29_init-subclass/#41-메타클래스를-사용했다면"},{"categories":["python"],"content":" 10. 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 원저자 깃허브 ","date":"2020-12-29","objectID":"/2020-12-29_init-subclass/:6:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 48. __init_subclass__를 사용해 하위 클래스를 검증하라' 정리","uri":"/2020-12-29_init-subclass/#10-참고-자료"},{"categories":["python"],"content":" 0. 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c6. Metaclasses and Attributes\u003e Item 49: Register Class Existence with __init_subclass__ Better way 49. __init_subclass__를 사용해 클래스 확장을 등록하라 ","date":"2020-12-29","objectID":"/2020-12-31_class-registration/:1:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 49. __init_subclass__를 사용해 클래스 확장을 등록하라' 정리","uri":"/2020-12-31_class-registration/#0-들어가며"},{"categories":["python"],"content":" 1. 한 줄 요약 및 첨언__init_subclass__ 통해서 하위 클래스 정의하면 각 클래스마다 꼭 불려야 하는 로직을 자동으로 수행할 수 있습니다. ","date":"2020-12-29","objectID":"/2020-12-31_class-registration/:2:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 49. __init_subclass__를 사용해 클래스 확장을 등록하라' 정리","uri":"/2020-12-31_class-registration/#1-한-줄-요약-및-첨언"},{"categories":["python"],"content":" 2. 사용 예시객체를 json string 으로 바꾸기도 하고, 해당 string으로부터 다시 객체로 만드는 기능이 필요한 상황입니다. ​ 클래스 등록 부분입니다. registry 변수에 하위 클래스들의 이름을 등록하고, deserialize때 사용하려는 목적입니다. ​ import json ​ # Example 6 registry = {} # 클래스 이름 저장용 딕셔너리 ​ ​ # 클래스 이름 등록하는 함수. 클래스 정의때 요게 불려야 함 def register_class(target_class): registry[target_class.__name__] = target_class ​ ​ # json str 으로부터 다시 객체 만들어주는 함수 def deserialize(data: str): params = json.loads(data) name = params['class'] target_class = registry[name] return target_class(*params['args']) # *params['args']: 리스트의 원소들을 arguments 로 넘김 ​ 베이스가 되는 클래스입니다. __init_subclass__ 를 구현해서, register_class()가 자동으로 호출이 됩니다. (수동으로 호출할 필요가 없어 졌습니다.) ​ # Example 5 + Example 13 class BetterSerializable: # __init_class__ 구현한 베이스 클래스 def __init__(self, *args): self.args = args ​ def serialize(self): return json.dumps({ 'class': self.__class__.__name__, 'args': self.args, }) ​ def __repr__(self): name = self.__class__.__name__ args_str = ', '.join(str(x) for x in self.args) return f'{name}({args_str})' ​ def __init_subclass__(cls): # 요 메서드 구현 super().__init_subclass__() register_class(cls) # 하위 클래스가 정의 될 때, 요게 자동으로 불리도록 하기 위함. ​ 위 클래스를 상속받은 하위클래스와 사용 예제입니다. # Example 7 class EvenBetterPoint2D(BetterSerializable): def __init__(self, x, y): super().__init__(x, y) self.x = x self.y = y ​ # Example 8 before = EvenBetterPoint2D(5, 3) print('Before: ', before, type(before)) # Before: EvenBetterPoint2D(5, 3) \u003cclass '__main__.EvenBetterPoint2D'\u003e data = before.serialize() print('Serialized:', data, type(data)) # Serialized: {\"class\": \"EvenBetterPoint2D\", \"args\": [5, 3]} \u003cclass 'str'\u003e after = deserialize(data) print('After: ', after, type(after)) # After: EvenBetterPoint2D(5, 3) \u003cclass '__main__.EvenBetterPoint2D'\u003e ","date":"2020-12-29","objectID":"/2020-12-31_class-registration/:3:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 49. __init_subclass__를 사용해 클래스 확장을 등록하라' 정리","uri":"/2020-12-31_class-registration/#2-사용-예시"},{"categories":["python"],"content":" 3. 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Class registration is a helpful pattern for building modular Python programs. 클래스 등록은 파이썬 프로그램을 모듈화할 때 유용한 패턴이다. Tip Metaclasses let you run registration code automatically each time a base class is subclassed in a program. 메타클래스를 사용하면, 프로그램 안에서 기반 클래스를 상속한 하위 클래스가 정의될 때마다 등록 코드를 자동으로 실행할 수 있다. Tip Using metaclasses for class registration helps you avoid errors by ensuring that you never miss a registration call. 메타클래스를 클래스 등록에 사용하면 클래스 등록 함수를 호출하지 않아서 생기는 오류를 피할 수 있다. Tip Prefer __init_subclass__ over standard metaclass machinery because it’s clearer and easier for beginners to understand. 표준적인 메타클래스 방식보다는 __init_sublcass__가 더 낫다. __init_subclass__ 쪽이 더 깔끔하고 초보자가 이해하기도 더 쉽다. ","date":"2020-12-29","objectID":"/2020-12-31_class-registration/:4:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 49. __init_subclass__를 사용해 클래스 확장을 등록하라' 정리","uri":"/2020-12-31_class-registration/#3-기억해야-할-내용"},{"categories":["python"],"content":" 4. 더 알아보기","date":"2020-12-29","objectID":"/2020-12-31_class-registration/:5:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 49. __init_subclass__를 사용해 클래스 확장을 등록하라' 정리","uri":"/2020-12-31_class-registration/#4-더-알아보기"},{"categories":["python"],"content":" 4.1 메타클래스를 사용했다면메타클래스를 사용한 방식도 알아두기는 합시다. # 클래스 등록 부분은 같은 코드 사용 # Example 11 class Meta(type): def __new__(meta, name, bases, class_dict): cls = type.__new__(meta, name, bases, class_dict) register_class(cls) # 하위 클래스가 정의 될 때, 요게 자동으로 불리도록 하기 위함. return cls class TempSerializable(metaclass=Meta): # metaclass 지정 def __init__(self, *args): self.args = args def serialize(self): return json.dumps({ 'class': self.__class__.__name__, 'args': self.args, }) def __repr__(self): name = self.__class__.__name__ args_str = ', '.join(str(x) for x in self.args) return f'{name}({args_str})' # Example 12 class Vector3D(TempSerializable): def __init__(self, x, y, z): super().__init__(x, y, z) self.x, self.y, self.z = x, y, z before = Vector3D(10, -7, 3) print('Before: ', before) # Before: Vector3D(10, -7, 3) data = before.serialize() print('Serialized:', data) # Serialized: {\"class\": \"Vector3D\", \"args\": [10, -7, 3]} print('After: ', deserialize(data)) # After: Vector3D(10, -7, 3) ","date":"2020-12-29","objectID":"/2020-12-31_class-registration/:5:1","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 49. __init_subclass__를 사용해 클래스 확장을 등록하라' 정리","uri":"/2020-12-31_class-registration/#41-메타클래스를-사용했다면"},{"categories":["python"],"content":" 10. 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 원저자 깃허브 ","date":"2020-12-29","objectID":"/2020-12-31_class-registration/:6:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 49. __init_subclass__를 사용해 클래스 확장을 등록하라' 정리","uri":"/2020-12-31_class-registration/#10-참고-자료"},{"categories":["python"],"content":" 0. 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c6. Metaclasses and Attributes\u003e Item 47: Use __getattr__, __getattribute__, and __setattr__ for Lazy Attrubutes Better way 47. 지연 계산 애트리뷰트가 필요하면, __getattr__, __getattribute__, __setattr__을 사용하라 ","date":"2020-12-28","objectID":"/2020-12-28_object-hook/:1:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 47. 지연 계산 애트리뷰트가 필요하면, __getattr__, __getattribute__, __setattr__을 사용하라' 정리","uri":"/2020-12-28_object-hook/#0-들어가며"},{"categories":["python"],"content":" 1. 한 줄 요약 및 첨언__getattr__, __getattribute__, __setattr__ 를 사용하면, 애트리뷰트 접근 및 세팅때 특별한 일을 수행할 수 있습니다. 요런 애들을 object hook 이라고 한다는군요. ","date":"2020-12-28","objectID":"/2020-12-28_object-hook/:2:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 47. 지연 계산 애트리뷰트가 필요하면, __getattr__, __getattribute__, __setattr__을 사용하라' 정리","uri":"/2020-12-28_object-hook/#1-한-줄-요약-및-첨언"},{"categories":["python"],"content":" 2. 사용 예시","date":"2020-12-28","objectID":"/2020-12-28_object-hook/:3:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 47. 지연 계산 애트리뷰트가 필요하면, __getattr__, __getattribute__, __setattr__을 사용하라' 정리","uri":"/2020-12-28_object-hook/#2-사용-예시"},{"categories":["python"],"content":" 2.1 getattr객체의 인스턴스 딕셔너리에 없는 애트리뷰트에 접근할 때 뭔가 처리해야 한다면 __getattr__를 구현합니다. # Example 1 class LazyRecord: def __init__(self): self.exists = 5 def __getattr__(self, name): print(f'* Called __getattr__({name!r}), populating instance dictionary') value = f'Value for {name}' setattr(self, name, value) print(f'* Returning {value!r}') return value # Example 2 data = LazyRecord() print('Before:', data.__dict__) # Before: {'exists': 5} print('First foo: ', data.foo) print('After: ', data.__dict__) # After: {'exists': 5, 'foo': 'Value for foo'} print('Second foo: ', data.foo) print('Has peach: ', hasattr(data, 'peach')) # Has peach: True Before: {'exists': 5} * Called __getattr__('foo'), populating instance dictionary * Returning 'Value for foo' First foo: Value for foo After: {'exists': 5, 'foo': 'Value for foo'} Second foo: Value for foo * Called __getattr__('peach'), populating instance dictionary * Returning 'Value for peach' Has peach: True First foo 때만 __getattr__가 호출되었고, 인스턴스 딕셔너리에 ‘foo’가 추가 되었습니다. hasattr를 호출해도 __getattr__가 호출되었습니다. ","date":"2020-12-28","objectID":"/2020-12-28_object-hook/:3:1","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 47. 지연 계산 애트리뷰트가 필요하면, __getattr__, __getattribute__, __setattr__을 사용하라' 정리","uri":"/2020-12-28_object-hook/#21-getattr"},{"categories":["python"],"content":" 2.2 getattribute애트리뷰트에 접근할 때마다 뭔가 처리해야 한다면 __getattribute__를 구현합니다. # Example 4 class ValidatingRecord: def __init__(self): self.exists = 5 def __getattribute__(self, name): print(f'* Called __getattribute__({name!r})') try: value = super().__getattribute__(name) # 실제 값을 가져올 때는 super() 로 # value = self.name # 요런식이면 또 __getattribute__를 불러스 무한 재귀에 빠짐 print(f'* Found {name!r}, returning {value!r}') return value except AttributeError: value = f'Value for {name}' print(f'* Setting {name!r} to {value!r}') setattr(self, name, value) return value data = ValidatingRecord() print('exists: ', data.exists) # exists: 5 print('First foo: ', data.foo) # First foo: Value for foo print('Second foo: ', data.foo) # Second foo: Value for foo print('Has foo: ', hasattr(data, 'foo')) # Has foo: True 실제 값을 가져올 때는 value = super().__getattribute__(name) 요렇게 super 를 사용해야 합니다. * Called __getattribute__('exists') * Found 'exists', returning 5 exists: 5 * Called __getattribute__('foo') * Setting 'foo' to 'Value for foo' First foo: Value for foo * Called __getattribute__('foo') * Found 'foo', returning 'Value for foo' Second foo: Value for foo * Called __getattribute__('foo') * Found 'foo', returning 'Value for foo' Has foo: True 애트리뷰트에 접근할 때마다 __getattribute__가 호출됩니다. hasattr()도 마찬가지 입니다. ","date":"2020-12-28","objectID":"/2020-12-28_object-hook/:3:2","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 47. 지연 계산 애트리뷰트가 필요하면, __getattr__, __getattribute__, __setattr__을 사용하라' 정리","uri":"/2020-12-28_object-hook/#22-getattribute"},{"categories":["python"],"content":" 2.3 setattr인스턴스의 애트리뷰트 값을 설정할 때마다 뭔가 처리해야 한다면 __setattr__를 구현합니다. # Example 9 class LoggingSavingRecord: def __setattr__(self, name, value): print(f'* Called __setattr__({name!r}, {value!r})') super().__setattr__(name, value) data = LoggingSavingRecord() print('Before: ', data.__dict__) # Before: {} data.foo = 5 print('After: ', data.__dict__) # After: {'foo': 5} data.foo = 7 print('Finally:', data.__dict__) # Finally: {'foo': 7} 실제 값을 세팅할 때는 super().__setattr__(name, value) 요렇게 super 를 사용해야 합니다. Before: {} * Called __setattr__('foo', 5) After: {'foo': 5} * Called __setattr__('foo', 7) Finally: {'foo': 7} ","date":"2020-12-28","objectID":"/2020-12-28_object-hook/:3:3","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 47. 지연 계산 애트리뷰트가 필요하면, __getattr__, __getattribute__, __setattr__을 사용하라' 정리","uri":"/2020-12-28_object-hook/#23-setattr"},{"categories":["python"],"content":" 3. 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Use __getattr__ and __setattr__ to lazily load and save attributes for an object. __getattr__과 __setattr__을 사용해 객체의 애트리뷰트를 지연해 가져오거나 저장할 수 있다. Tip Understand that __getattr__ only gets called when accessing a missing attribute, whereas __getattribute__ gets called every time any attribute is accessed. __getattr__은 애트리뷰트가 존재하지 않을 때만 호출되지만, __getattribute__는 애트리뷰트를 읽을 때마다 항상 호출된다는 점을 이해하라. Tip Avoid infinite recursion in __getattribute__ and __setattr__ by using methods from super() (i.e., the object class) to access instance attributes. __getattribute__와 __setattr__에서 무한 재귀를 피하려면 super()에 있는(즉, object 클래스에 있는) 메서드를 사용해 인스턴스 애트리뷰트에 접근하라. ","date":"2020-12-28","objectID":"/2020-12-28_object-hook/:4:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 47. 지연 계산 애트리뷰트가 필요하면, __getattr__, __getattribute__, __setattr__을 사용하라' 정리","uri":"/2020-12-28_object-hook/#3-기억해야-할-내용"},{"categories":["python"],"content":" 10. 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 원저자 깃허브 ","date":"2020-12-28","objectID":"/2020-12-28_object-hook/:5:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 47. 지연 계산 애트리뷰트가 필요하면, __getattr__, __getattribute__, __setattr__을 사용하라' 정리","uri":"/2020-12-28_object-hook/#10-참고-자료"},{"categories":["python"],"content":" 0. 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c6. Metaclasses and Attributes\u003e Item 46: Use Descriptors for Reusable @property Methods Better way 46. 재사용 가능한 @property 메서드를 만들려면 디스크립터를 사용하라 ","date":"2020-12-27","objectID":"/2020-12-27_descriptor/:1:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 46. 재사용 가능한 @property 메서드를 만들려면 디스크립터를 사용하라' 정리","uri":"/2020-12-27_descriptor/#0-들어가며"},{"categories":["python"],"content":" 1. 한 줄 요약 및 첨언다른 클래스의 클래스 어트리뷰트로 쓰이는 클래스인데 __set__, __get__, __del__ 중 하나라도 구현한 클래스를 디스크립터라고 합니다. 경계값 체크 등에 사용할 수 있을 듯 합니다. ","date":"2020-12-27","objectID":"/2020-12-27_descriptor/:2:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 46. 재사용 가능한 @property 메서드를 만들려면 디스크립터를 사용하라' 정리","uri":"/2020-12-27_descriptor/#1-한-줄-요약-및-첨언"},{"categories":["python"],"content":" 2. 사용 예시Grade 는 __get__, __set__을 구현한 디스크립터입니다. # Example 14 from weakref import WeakKeyDictionary class Grade: def __init__(self): # 다른 인스턴스(first_exam, second_exam)에 다른 값을 저장하기 위해 # 더하기, 메모리릭을 피하기 위해 (그냥 {} 으로 하면, __set__ 에서 인자로 받은 instance 가 안 없어짐) self._values = WeakKeyDictionary() def __get__(self, instance, instance_type): # 호출한 인스턴스도 받음 if instance is None: return self return self._values.get(instance, 0) def __set__(self, instance, value): # 호출한 인스턴스도 받음 if not (0 \u003c= value \u003c= 100): raise ValueError('Grade must be between 0 and 100') self._values[instance] = value 사용하는 예제 입니다. class Exam: math_grade = Grade() # 클래스 애트리뷰트라 한 번만 초기화 writing_grade = Grade() science_grade = Grade() # def __init__(self): # 요렇게는 디스크립터가 동작하지 않음 # self.math_grade = Grade() # self.writing_grade = Grade() # self.science_grade = Grade() first_exam = Exam() print(first_exam.__dict__) # {} print(Exam.__dict__) # {'math_grade': \u003c__main__.Grade object at 0x000002A0D1999730\u003e, ... } first_exam.writing_grade = 82 try: first_exam.math_grade = 120 except ValueError as e: print(\"ValueError!\", e) # ValueError! Grade must be between 0 and 100 second_exam = Exam() second_exam.writing_grade = 75 print(f'First {first_exam.writing_grade} is right') # First 82 is right print(f'Second {second_exam.writing_grade} is right') # Second 75 is right ","date":"2020-12-27","objectID":"/2020-12-27_descriptor/:3:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 46. 재사용 가능한 @property 메서드를 만들려면 디스크립터를 사용하라' 정리","uri":"/2020-12-27_descriptor/#2-사용-예시"},{"categories":["python"],"content":" 3. 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Reuse the behavior and validation of @property methods by defining your own descriptor classes. @property 메서드의 동작과 검증 기능을 재사용하고 싶다면 디스크립터 클래스를 만들라. Tip Use WeakKeyDictionary to ensure that your descriptor classes don’t cause memory leaks. 디스크립터 클래스를 만들 때는 메모리 누수를 방지하기 위해 WeakDictionary를 사용하라. Tip Don’t get bogged down trying to understand exactly how __getattribute__ uses the descriptor protocol for getting and setting attributes. __getattribute__가 디스크립터 프로토콜을 사용해 애트리뷰트 값을 읽거나 설정하는 방식을 정확히 이해하라. ","date":"2020-12-27","objectID":"/2020-12-27_descriptor/:4:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 46. 재사용 가능한 @property 메서드를 만들려면 디스크립터를 사용하라' 정리","uri":"/2020-12-27_descriptor/#3-기억해야-할-내용"},{"categories":["python"],"content":" 4. 더 알아보기","date":"2020-12-27","objectID":"/2020-12-27_descriptor/:5:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 46. 재사용 가능한 @property 메서드를 만들려면 디스크립터를 사용하라' 정리","uri":"/2020-12-27_descriptor/#4-더-알아보기"},{"categories":["python"],"content":" 4.1 디스크립터 애트리뷰트에 대한 접근 해석디스크립터 애트리뷰트에 대한 접근을 파이썬이 어떻게 처리하는지 보여주는 예제입니다. third_exam = Exam() # 요 코드는 third_exam.writing_grade = 40 # 요렇게 해석됨 Exam.__dict__['writing_grade'].__set__(third_exam, 40) # 요 코드는 temp = third_exam.writing_grade print(temp) # 40 # 요렇게 해석됨 temp = Exam.__dict__['writing_grade'].__get__(third_exam, Exam) print(temp) # 40 __getattribute__ 메서드가 요 동작을 이끌어 낸다고 합니다. 47장에 나오나 부네요. Exam 클래스의 인스턴스(third_exam)에 writing_grade라는 이름의 애트리뷰트가 없으면, 파이썬은 Exam 클래스의 애트리뷰트를 대신 사용합니다. 이 클래스의 애트리뷰트가 __get__과 __set__ 메서드가 정의된 객체라면 파이썬은 디스크립터 프로토콜을 따라야 한다고 결정한다고 합니다. ","date":"2020-12-27","objectID":"/2020-12-27_descriptor/:5:1","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 46. 재사용 가능한 @property 메서드를 만들려면 디스크립터를 사용하라' 정리","uri":"/2020-12-27_descriptor/#41-디스크립터-애트리뷰트에-대한-접근-해석"},{"categories":["python"],"content":" 10. 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 원저자 깃허브 [코드잇] 쉽게 배우는 파이썬 문법 - 프로퍼티(Property) 3편 ","date":"2020-12-27","objectID":"/2020-12-27_descriptor/:6:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 46. 재사용 가능한 @property 메서드를 만들려면 디스크립터를 사용하라' 정리","uri":"/2020-12-27_descriptor/#10-참고-자료"},{"categories":["python"],"content":" 0. 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c6. Metaclasses and Attributes\u003e Item 45: Consider @property Instead of Refactoring Attributes Better way 45. 애트리뷰트를 리팩터링하는 대신 @property 를 사용하라 ","date":"2020-12-26","objectID":"/2020-12-26_property/:1:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 45. 애트리뷰트를 리팩터링하는 대신 @property 를 사용하라' 정리","uri":"/2020-12-26_property/#0-들어가며"},{"categories":["python"],"content":" 1. 한 줄 요약 및 첨언@property를 사용해서 기존 애트리뷰트를 사용하는 코드는 그대로 사용하면서 새로운 기능을 부여할 수 있습니다. 인터페이스를 점차 개선해 나가는 과정에서 중간중간 필요한 기능을 제공하는 수단으로도 유용합니다. ","date":"2020-12-26","objectID":"/2020-12-26_property/:2:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 45. 애트리뷰트를 리팩터링하는 대신 @property 를 사용하라' 정리","uri":"/2020-12-26_property/#1-한-줄-요약-및-첨언"},{"categories":["python"],"content":" 2. 사용 예시아래와 같은 클래스가 있습니다. 여기서 quota 사용 부분에 새로운 기능을 얹고 싶었던 상황이었습니다. class Bucket: def __init__(self, period): self.period_delta = timedelta(seconds=period) self.reset_time = datetime.now() self.quota = 0 def __repr__(self): return f'Bucket(quota={self.quota})' 기존 quata 애트리뷰트를 대신하여 @property 를 사용합니다. from datetime import datetime, timedelta # Example 7 class Bucket: # NewBucket def __init__(self, period): self.period_delta = timedelta(seconds=period) self.reset_time = datetime.now() # self.quota = 0 # 기존 요거 대신에 @property 로 quota 제공 self.max_quota = 0 self.quota_consumed = 0 def __repr__(self): return (f'NewBucket(max_quota={self.max_quota}, ' f'quota_consumed={self.quota_consumed})') @property def quota(self): return self.max_quota - self.quota_consumed @quota.setter def quota(self, amount): delta = self.max_quota - amount if amount == 0: # Quota being reset for a new period self.quota_consumed = 0 self.max_quota = 0 elif delta \u003c 0: # Quota being filled for the new period assert self.quota_consumed == 0 self.max_quota = amount else: # Quota being consumed during the period assert self.max_quota \u003e= self.quota_consumed self.quota_consumed += delta 기존 클래스를 호출하던 코드는 그대로 사용 합니다. # Example 2 def fill(bucket, amount): now = datetime.now() if (now - bucket.reset_time) \u003e bucket.period_delta: bucket.quota = 0 bucket.reset_time = now bucket.quota += amount # Example 3 def deduct(bucket, amount): now = datetime.now() if (now - bucket.reset_time) \u003e bucket.period_delta: return False # Bucket hasn't been filled this period if bucket.quota - amount \u003c 0: return False # Bucket was filled, but not enough bucket.quota -= amount return True # Bucket had enough, quota consumed 사용 예시 # Example 10 bucket = NewBucket(60) print('Initial', bucket) # Initial NewBucket(max_quota=0, quota_consumed=0) fill(bucket, 100) print('Filled', bucket) # Filled NewBucket(max_quota=100, quota_consumed=0) if deduct(bucket, 99): print('Had 99 quota') # Had 99 quota else: print('Not enough for 99 quota') print('Now', bucket) # Now NewBucket(max_quota=100, quota_consumed=99) if deduct(bucket, 3): print('Had 3 quota') else: print('Not enough for 3 quota') # Not enough for 3 quota print('Still', bucket) # Still NewBucket(max_quota=100, quota_consumed=99) ","date":"2020-12-26","objectID":"/2020-12-26_property/:3:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 45. 애트리뷰트를 리팩터링하는 대신 @property 를 사용하라' 정리","uri":"/2020-12-26_property/#2-사용-예시"},{"categories":["python"],"content":" 3. 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Use @property to give existing instance attributes new functionality. @property를 사용해 기존 인스턴스 애트리뷰트에 새로운 기능을 제공할 수 있다. Tip Make incremental progress toward better data models by using @property. @property를 사용해 데이터 모델을 점진적으로 개선하라. Tip Consider refactoring a class and all call sites when you find yourself using @property too heavily. @property 메서드를 너무 과하게 쓰고 있다면, 클래스와 클래스를 사용하는 모든 코드를 리팩터링하는 것을 고려하라. ","date":"2020-12-26","objectID":"/2020-12-26_property/:4:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 45. 애트리뷰트를 리팩터링하는 대신 @property 를 사용하라' 정리","uri":"/2020-12-26_property/#3-기억해야-할-내용"},{"categories":["python"],"content":" 10. 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 원저자 깃허브 ","date":"2020-12-26","objectID":"/2020-12-26_property/:5:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 45. 애트리뷰트를 리팩터링하는 대신 @property 를 사용하라' 정리","uri":"/2020-12-26_property/#10-참고-자료"},{"categories":["python"],"content":" 0. 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c6. Metaclasses and Attributes\u003e Item 44: Use Plain Attributes Instead of Setter and Getter Methods Better way 44. 세터와 게터 메서드 대신 평범한 애트리뷰트를 사용하라 ","date":"2020-12-25","objectID":"/2020-12-25_plain-attributes/:1:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 44. 세터와 게터 메서드 대신 평범한 애트리뷰트를 사용하라' 정리","uri":"/2020-12-25_plain-attributes/#0-들어가며"},{"categories":["python"],"content":" 1. 한 줄 요약 및 첨언파이썬에서는 명시적인 세터나 게터 메서드를 구현할 필요가 없습니다. 그런 기능이 필요해 진다면 @property 데코레이터를 이용합시다. ","date":"2020-12-25","objectID":"/2020-12-25_plain-attributes/:2:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 44. 세터와 게터 메서드 대신 평범한 애트리뷰트를 사용하라' 정리","uri":"/2020-12-25_plain-attributes/#1-한-줄-요약-및-첨언"},{"categories":["python"],"content":" 2. 사용 예시시작은 단순한 공개 애트리뷰트로 합니다. # Example 4 class Resistor: def __init__(self, ohms): self.voltage = 0 self.current = 0 self.ohms = ohms r1 = Resistor(10e3) # 10 * 10^3 r1.ohms += 5e3 # getter, setter 쓰지 말고, 그냥 바로 쓰면 된다. print(r1.__dict__) # {'voltage': 0, 'current': 0, 'ohms': 15000.0} property 데코레이터 사용한 BoundedResistance 클래스입니다. # Example 8 class BoundedResistance(Resistor): def __init__(self, ohms): super().__init__(ohms) @property # getter def ohms(self): return self._ohms @ohms.setter # setter def ohms(self, ohms): if ohms \u003c= 0: # 요런 식으로 경계값 확인도 가능 raise ValueError(f'ohms must be \u003e 0; got {ohms}') self._ohms = ohms self.current = self.voltage / self.ohms 사용 부분 # Example 9 r3 = BoundedResistance(1000) print(r3.ohms) # 1000. 함수 이름(ohms)을 변수처럼 접근할 수 있음 print(r3.__dict__) # {'voltage': 0, 'current': 0.0, '_ohms': 1000}. Resistor 의 ohms 는 가려짐(?) try: r3.ohms = 0 # setter 불림 (0이라서 에러 발생) except ValueError as e: print(e) # ohms must be \u003e 0; got 0 print() r2 = BoundedResistance(1000) r2.voltage = 10 print(f'Before: {r2.current:.2f} amps, {r2.voltage} volts, {r2.ohms} ohms') # \u003e Before: 0.00 amps, 0 volts, 1000 ohms r2.ohms = 500 # setter 불림 print(f'After: {r2.current:.2f} amps, {r2.voltage} volts, {r2.ohms} ohms') # \u003e After: 0.01 amps, 10 volts, 1000 ohms. current 바뀌었음 ","date":"2020-12-25","objectID":"/2020-12-25_plain-attributes/:3:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 44. 세터와 게터 메서드 대신 평범한 애트리뷰트를 사용하라' 정리","uri":"/2020-12-25_plain-attributes/#2-사용-예시"},{"categories":["python"],"content":" 3. 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Define new class interfaces using simple public attributes and avoid defining setter and getter methods. 새로운 클래스 인터페이스를 정의할 대는 간단한 공개 애트리뷰트에서 시작하고, 세터나 게터 메서드를 가급적 사용하지 말라. Tip Use @property to define special behavior when attributes are accessed on your objects, if necessary. 객체에 있는 애트리뷰트에 접근할 때 특별한 동작이 필요하면 @property로 이를 구현할 수 있다. Tip Follow the rule of least surprise and avoid odd side effects in your @property method. @property 메서드를 만들 때는 최소 놀람의 법칙을 따르고 이상한 부작용을 만들어내지 말라. Tip Ensure that @property methods are fast; for slow or complex work — especially involving I/O or causing side effects — use normal methods instead. @property 메서드가 빠르게 실행되도록 유지하라. 느리거나 복잡한 작업의 경우(특히 I/O를 수행하는 등의 부수 효과가 있는 경우)에는 프로퍼티 대신 일반적인 메서드를 사용하라. ","date":"2020-12-25","objectID":"/2020-12-25_plain-attributes/:4:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 44. 세터와 게터 메서드 대신 평범한 애트리뷰트를 사용하라' 정리","uri":"/2020-12-25_plain-attributes/#3-기억해야-할-내용"},{"categories":["python"],"content":" 10. 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 원저자 깃허브 프로퍼티 사용하기 / 파이썬 코딩 도장 ","date":"2020-12-25","objectID":"/2020-12-25_plain-attributes/:5:0","series":["effective python 6. 메타클래스와 애트리뷰트"],"tags":["python"],"title":"'Better way 44. 세터와 게터 메서드 대신 평범한 애트리뷰트를 사용하라' 정리","uri":"/2020-12-25_plain-attributes/#10-참고-자료"},{"categories":["python"],"content":" 0. 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c5. Classes and Interfaces\u003e Item 43: Inherit from collections.abc for Custom Container Types Better way 43. 커스텀 컨테이너 타입은 collections.abc를 상속하라 ","date":"2020-12-24","objectID":"/2020-12-24_custom-container/:1:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 43. 커스텀 컨테이너 타입은 collections.abc를 상속하라' 정리","uri":"/2020-12-24_custom-container/#0-들어가며"},{"categories":["python"],"content":" 1. 한 줄 요약 및 첨언파이썬 관례에 따르는 커스텀 컨테이너를 만들어야 한다면, collections.abc 를 활용하는 게 좋습니다. ","date":"2020-12-24","objectID":"/2020-12-24_custom-container/:2:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 43. 커스텀 컨테이너 타입은 collections.abc를 상속하라' 정리","uri":"/2020-12-24_custom-container/#1-한-줄-요약-및-첨언"},{"categories":["python"],"content":" 2. 사용 예시바이너리 트리를 리스트처럼 쓰고 싶은 상황 예제 입니다. 책의 예제는 설명을 위해서 여러 클래스로 나뉘어져 있는데, 여기서는 하나로 합쳤습니다. from collections.abc import Sequence class BinaryNode(Sequence): # collections.abc 모듈의 Sequence 상속 def __init__(self, value, left=None, right=None): self.value = value self.left = left self.right = right def _traverse(self): if self.left is not None: yield from self.left._traverse() yield self if self.right is not None: yield from self.right._traverse() def __getitem__(self, index): # 구현 안하면 컴파일 에러 for i, item in enumerate(self._traverse()): if i == index: return item.value raise IndexError(f'Index {index} is out of range') def __len__(self): # 구현 안하면 컴파일 에러 for count, _ in enumerate(self._traverse(), 1): pass return count tree = BinaryNode( 10, left=BinaryNode( 5, left=BinaryNode(2), right=BinaryNode( 6, right=BinaryNode(7))), right=BinaryNode( 15, left=BinaryNode(11)) ) print('LRR is', tree.left.right.right.value) # LRR is 7 print('Index 0 is', tree[0]) # Index 0 is 2 print('Index 1 is', tree[1]) # Index 1 is 5 print('11 in the tree?', 11 in tree) # 11 in the tree? True print('17 in the tree?', 17 in tree) # 17 in the tree? False print('Tree is', list(tree)) # Tree is [2, 5, 6, 7, 10, 11, 15] print('Tree length is', len(tree)) # Tree length is 7 print('Index of 7 is', tree.index(7)) # Index of 7 is 3 print('Count of 10 is', tree.count(10)) # Count of 10 is 1 collections.abc 모듈의 클래스를 상속 받으면, 구현 안된 메서드가 있을 때 컴파일 에러로 알려주고 일부 메서드는 이미 구현된 걸 사용할 수 있습니다. (Sequence 의 경우는 index, count) ","date":"2020-12-24","objectID":"/2020-12-24_custom-container/:3:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 43. 커스텀 컨테이너 타입은 collections.abc를 상속하라' 정리","uri":"/2020-12-24_custom-container/#2-사용-예시"},{"categories":["python"],"content":" 3. 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Inherit directly from Python’s container types (like list or dict) for simple use cases. 간편하게 사용할 경우에는 파이썬 컨테이너 타입(리스트나 딕셔너리 등)을 직접 상속하라. Tip Beware of the large number of methods required to implement custom container types correctly. 커스텀 컨테이너를 제대로 구현하려면 수많은 메서드를 구현해야 한다는 점에 주의하라. Tip Have your custom container types inherit from the interfaces defined in collections.abc to ensure that your classes match required interfaces and behaviors. 커스텀 컨테이터 타입이 collection.abc에 정의된 인터페이스를 상속하면 커스텀 컨테이너 타입이 정상적으로 작동하기 위해 필요한 인터페이스와 기능을 제대로 구현하도록 보장할 수 있다. ","date":"2020-12-24","objectID":"/2020-12-24_custom-container/:4:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 43. 커스텀 컨테이너 타입은 collections.abc를 상속하라' 정리","uri":"/2020-12-24_custom-container/#3-기억해야-할-내용"},{"categories":["python"],"content":" 10. 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 원저자 깃허브 ","date":"2020-12-24","objectID":"/2020-12-24_custom-container/:5:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 43. 커스텀 컨테이너 타입은 collections.abc를 상속하라' 정리","uri":"/2020-12-24_custom-container/#10-참고-자료"},{"categories":["python"],"content":" 0. 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c5. Classes and Interfaces\u003e Item 42: Prefer Public Attributes Over Private Ones Better way 42. 비공개 애트리뷰트보다는 공개 애트리뷰트를 사용하라 ","date":"2020-12-23","objectID":"/2020-12-23_public-attribute/:1:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 42. 비공개 애트리뷰트보다는 공개 애트리뷰트를 사용하라' 정리","uri":"/2020-12-23_public-attribute/#0-들어가며"},{"categories":["python"],"content":" 1. 한 줄 요약 및 첨언비공개 애트리뷰트(변수 앞에 밑줄 두 개)는 사용하지 맙시다. ","date":"2020-12-23","objectID":"/2020-12-23_public-attribute/:2:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 42. 비공개 애트리뷰트보다는 공개 애트리뷰트를 사용하라' 정리","uri":"/2020-12-23_public-attribute/#1-한-줄-요약-및-첨언"},{"categories":["python"],"content":" 2. 사용 예시조심해야할 필드라면 해당 필드에 문서를 남겨 놓읍시다. # Example 13 class MyStringClass: def __init__(self, value): # This stores the user-supplied value for the object. # It should be coercible to a string. Once assigned in # the object it should be treated as immutable. self._value = value def get_value(self): return str(self._value) class MyIntegerSubclass(MyStringClass): def get_value(self): return self._value foo = MyIntegerSubclass(5) assert foo.get_value() == 5 ","date":"2020-12-23","objectID":"/2020-12-23_public-attribute/:3:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 42. 비공개 애트리뷰트보다는 공개 애트리뷰트를 사용하라' 정리","uri":"/2020-12-23_public-attribute/#2-사용-예시"},{"categories":["python"],"content":" 3. 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Private attributes aren’t rigorously enforced by the Python compiler. 파이썬 컴파일러는 비공개 애트리뷰트를 자식 클래스나 클래스 외부에서 사용하지 못하도록 엄격히 금지하지 않는다. Tip Plan from the beginning to allow subclasses to do more with your internal APIs and attributes instead of choosing to lock them out. 여러분의 내부 API에 있는 클래스의 하위 클래스를 정의하는 사람들이 여러분이 제공하는 클래스의 애트리뷰트를 사용하지 못하도록 막기보다는 애트리뷰트를 사용해 더 많은 일을 할 수 있게 허용하라. Tip Use documentation of protected fields to guide subclasses instead of trying to force access control with private attributes. 비공개 애트리뷰트로 (외부나 하위 클래스의) 접근을 막으려고 시도하기보다는 보호된 필드를 사용하면서 문서에 적절한 가이드를 남겨라. Tip Only consider using private attribute to avoid naming conflicts with subclasses that are out or your control. 여러분이 코드 작성을 제어할 수 없는 하위 클래스에서 이름 충돌이 일어나는 경우를 막고 싶을 때만 비공개 애트리뷰트를 사용할 것을 권한다. ","date":"2020-12-23","objectID":"/2020-12-23_public-attribute/:4:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 42. 비공개 애트리뷰트보다는 공개 애트리뷰트를 사용하라' 정리","uri":"/2020-12-23_public-attribute/#3-기억해야-할-내용"},{"categories":["python"],"content":" 4. 더 알아보기","date":"2020-12-23","objectID":"/2020-12-23_public-attribute/:5:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 42. 비공개 애트리뷰트보다는 공개 애트리뷰트를 사용하라' 정리","uri":"/2020-12-23_public-attribute/#4-더-알아보기"},{"categories":["python"],"content":" 4.1 비공개 애트리뷰트 접근내부적으로 하위 클래스에서 이름이 바뀝니다. 그래도 어차피 접근할 수 있습니다. # Example 6 class MyParentObject: def __init__(self): self.__private_field = 71 class MyChildObject(MyParentObject): def get_private_field(self): return self.__private_field baz = MyChildObject() try: baz.get_private_field() # 요건 예외 발생 except AttributeError: print('Expected AttributeError') # Expected AttributeError # Example 7 (그래도 접근 가능) print(baz._MyParentObject__private_field) # 71 # Example 8 (__dict__ 로 인스턴스의 애트리뷰트 확인) print(baz.__dict__) # {'_MyParentObject__private_field': 71} ","date":"2020-12-23","objectID":"/2020-12-23_public-attribute/:5:1","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 42. 비공개 애트리뷰트보다는 공개 애트리뷰트를 사용하라' 정리","uri":"/2020-12-23_public-attribute/#41-비공개-애트리뷰트-접근"},{"categories":["python"],"content":" 10. 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 원저자 깃허브 ","date":"2020-12-23","objectID":"/2020-12-23_public-attribute/:6:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 42. 비공개 애트리뷰트보다는 공개 애트리뷰트를 사용하라' 정리","uri":"/2020-12-23_public-attribute/#10-참고-자료"},{"categories":["python"],"content":" 0. 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c5. Classes and Interfaces\u003e Item 41: Consider Composing Functionality with Mix-in Classes Better way 41. 기능을 합성할 때는 믹스인 클래스를 사용하라 ","date":"2020-12-23","objectID":"/2020-12-23_mix-in/:1:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 41. 기능을 합성할 때는 믹스인 클래스를 사용하라' 정리","uri":"/2020-12-23_mix-in/#0-들어가며"},{"categories":["python"],"content":" 1. 한 줄 요약 및 첨언믹스인 클래스도 뭔지는 알아둡시다. 따로 애트리뷰트는 없고 하위 클래스에서 공통으로 사용할 기능만 정의한 클래스를 믹스인 클래스라고 하는 듯 합니다. ","date":"2020-12-23","objectID":"/2020-12-23_mix-in/:2:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 41. 기능을 합성할 때는 믹스인 클래스를 사용하라' 정리","uri":"/2020-12-23_mix-in/#1-한-줄-요약-및-첨언"},{"categories":["python"],"content":" 2. 사용 예시바이너리 트리가 ToDictMixin 을 상속받은 예제입니다. import pprint # Example 1 class ToDictMixin: def to_dict(self): # 믹스인을 상속하는 모든 클래스에서 이 함수의 기능을 사용할 수 있음 return self._traverse_dict(self.__dict__) # __dict__ : 인스턴스가 갖는 애트리뷰트들의 dict # Example 2 def _traverse_dict(self, instance_dict): output = {} for key, value in instance_dict.items(): output[key] = self._traverse(key, value) return output def _traverse(self, key, value): if isinstance(value, ToDictMixin): return value.to_dict() elif isinstance(value, dict): return self._traverse_dict(value) elif isinstance(value, list): return [self._traverse(key, i) for i in value] elif hasattr(value, '__dict__'): return self._traverse_dict(value.__dict__) else: return value # Example 3 class BinaryTree(ToDictMixin): def __init__(self, value, left=None, right=None): self.value = value self.left = left self.right = right # 이해를 돕기 위해 temp_node1 = BinaryTree(5, None, None) print(temp_node1.__dict__) # {'value': 5, 'left': None, 'right': None} # 이해를 돕기 위해 temp_node2 = BinaryTree(3, temp_node1, None) print(temp_node2.__dict__) # {'value': 3, 'left': \u003c__main__.BinaryTree object at 0x000002A5DA1D9730\u003e, 'right': None} # Example 4 tree = BinaryTree(10, left=BinaryTree(7, right=BinaryTree(9)), right=BinaryTree(13, left=BinaryTree(11))) pprint.pprint(tree.to_dict()) {'left': {'left': None, 'right': {'left': None, 'right': None, 'value': 9}, 'value': 7}, 'right': {'left': {'left': None, 'right': None, 'value': 11}, 'right': None, 'value': 13}, 'value': 10} ","date":"2020-12-23","objectID":"/2020-12-23_mix-in/:3:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 41. 기능을 합성할 때는 믹스인 클래스를 사용하라' 정리","uri":"/2020-12-23_mix-in/#2-사용-예시"},{"categories":["python"],"content":" 3. 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Avoid using multiple inheritance with instance attributes and __init__ if mix-in classes can achieve the same outcome. 믹스인을 사용해 구현할 수 있는 기능을 인스턴스 애트리뷰트와 __init__을 사용하는 다중 상속을 통해 구현하지 말라. Tip Use pluggable behaviors at the instance level to provide per-class customization when mix-in classes may require it. 믹스인 클래스가 클래스별로 특화된 기능을 필요로 한다면 인스턴스 수준에서 끼워 넣을 수 있는 기능(정해진 메서드를 통해 해당 기능을 인스턴스가 제공하게 만듦)을 활용하라. Tip Mix-ins can include instance methods or class methods, depending on your needs. 믹스인에는 필요에 따라 인스턴스 메서드는 물론 클래스 메서드도 포함될 수 있다. Tip Compose mix-ins to create complex functionality from simple behaviors. 믹스인을 합성하면 단순한 동작으로부터 더 복잡한 기능을 만들어낼 수 있다. ","date":"2020-12-23","objectID":"/2020-12-23_mix-in/:4:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 41. 기능을 합성할 때는 믹스인 클래스를 사용하라' 정리","uri":"/2020-12-23_mix-in/#3-기억해야-할-내용"},{"categories":["python"],"content":" 4. 더 알아보기","date":"2020-12-23","objectID":"/2020-12-23_mix-in/:5:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 41. 기능을 합성할 때는 믹스인 클래스를 사용하라' 정리","uri":"/2020-12-23_mix-in/#4-더-알아보기"},{"categories":["python"],"content":" 4.1 믹스인 여러 개 합성위의 ToDictMixin 과 JsonMixin 같이 사용 import pprint import json # Example 1 class ToDictMixin: def to_dict(self): # 믹스인을 상속하는 모든 클래스에서 이 함수의 기능을 사용할 수 있음 return self._traverse_dict(self.__dict__) # __dict__ : 인스턴스가 갖는 애트리뷰트들의 dict # Example 2 def _traverse_dict(self, instance_dict): output = {} for key, value in instance_dict.items(): output[key] = self._traverse(key, value) return output def _traverse(self, key, value): if isinstance(value, ToDictMixin): return value.to_dict() elif isinstance(value, dict): return self._traverse_dict(value) elif isinstance(value, list): return [self._traverse(key, i) for i in value] elif hasattr(value, '__dict__'): return self._traverse_dict(value.__dict__) else: return value # Example 9 class JsonMixin: @classmethod def from_json(cls, data): kwargs = json.loads(data) return cls(**kwargs) # def to_json(self): return json.dumps(self.to_dict()) # Example 10 class DatacenterRack(ToDictMixin, JsonMixin): def __init__(self, switch=None, machines=None): self.switch = Switch(**switch) self.machines = [ Machine(**kwargs) for kwargs in machines] class Switch(ToDictMixin, JsonMixin): def __init__(self, ports=None, speed=None): self.ports = ports self.speed = speed class Machine(ToDictMixin, JsonMixin): def __init__(self, cores=None, ram=None, disk=None): self.cores = cores self.ram = ram self.disk = disk # Example 11 serialized = \"\"\"{ \"switch\": {\"ports\": 5, \"speed\": 1e9}, \"machines\": [ {\"cores\": 8, \"ram\": 32e9, \"disk\": 5e12}, {\"cores\": 4, \"ram\": 16e9, \"disk\": 1e12}, {\"cores\": 2, \"ram\": 4e9, \"disk\": 500e9} ] }\"\"\" deserialized = DatacenterRack.from_json(serialized) print(deserialized) # \u003c__main__.DatacenterRack object at 0x000002DDB65691F0\u003e pprint.pprint(deserialized.to_dict()) roundtrip = deserialized.to_json() assert json.loads(serialized) == json.loads(roundtrip) 실행 결과 {'machines': [{'cores': 8, 'disk': 5000000000000.0, 'ram': 32000000000.0}, {'cores': 4, 'disk': 1000000000000.0, 'ram': 16000000000.0}, {'cores': 2, 'disk': 500000000000.0, 'ram': 4000000000.0}], 'switch': {'ports': 5, 'speed': 1000000000.0}} ","date":"2020-12-23","objectID":"/2020-12-23_mix-in/:5:1","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 41. 기능을 합성할 때는 믹스인 클래스를 사용하라' 정리","uri":"/2020-12-23_mix-in/#41-믹스인-여러-개-합성"},{"categories":["python"],"content":" 10. 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 원저자 깃허브 ","date":"2020-12-23","objectID":"/2020-12-23_mix-in/:6:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 41. 기능을 합성할 때는 믹스인 클래스를 사용하라' 정리","uri":"/2020-12-23_mix-in/#10-참고-자료"},{"categories":["python"],"content":" 0. 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c5. Classes and Interfaces\u003e Item 40: Initialize Parent Classes with super Better way 40. super로 부모 클래스를 초기화하라 ","date":"2020-12-23","objectID":"/2020-12-23_init-parent/:1:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 40. super로 부모 클래스를 초기화하라' 정리","uri":"/2020-12-23_init-parent/#0-들어가며"},{"categories":["python"],"content":" 1. 한 줄 요약 및 첨언부모 클래스의 초기화는 super().__init__() 으로 합니다. ","date":"2020-12-23","objectID":"/2020-12-23_init-parent/:2:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 40. super로 부모 클래스를 초기화하라' 정리","uri":"/2020-12-23_init-parent/#1-한-줄-요약-및-첨언"},{"categories":["python"],"content":" 2. 사용 예시class MyBaseClass: def __init__(self, value): self.value = value # Example 13 class ImplicitTrisect(MyBaseClass): def __init__(self, value): super().__init__(value) # 부모 클래스 초기화 self.value /= 3 print(ImplicitTrisect(9).value) # 3.0 ","date":"2020-12-23","objectID":"/2020-12-23_init-parent/:3:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 40. super로 부모 클래스를 초기화하라' 정리","uri":"/2020-12-23_init-parent/#2-사용-예시"},{"categories":["python"],"content":" 3. 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Python’s standard method resolution order (MRO) solves the problems of superclass initialization order and diamond inheritance. 파이썬은 표준 메서드 결정 순서(MRO)를 활용해 상위 클래스 초기화 순서와 다이아몬드 상속 문제를 해결한다. Tip Use the super built-in function with zero arguments to initialize parent classes. 부모 클래스를 초기화할 때는 super 내장 함수를 아무 인자 없이 호출하라. super를 아무 인자 없이 호출하면 파이썬 컴파일러가 자동으로 올바른 파라미터를 넣어준다. ","date":"2020-12-23","objectID":"/2020-12-23_init-parent/:4:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 40. super로 부모 클래스를 초기화하라' 정리","uri":"/2020-12-23_init-parent/#3-기억해야-할-내용"},{"categories":["python"],"content":" 4. 더 알아보기","date":"2020-12-23","objectID":"/2020-12-23_init-parent/:5:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 40. super로 부모 클래스를 초기화하라' 정리","uri":"/2020-12-23_init-parent/#4-더-알아보기"},{"categories":["python"],"content":" 4.1 super 에 파라미터 전달컴파일러가 알아서 넣어주니 전달할 필요 없습니다. 첫 번째 파라미터는 접근하고 싶은 MRO 뷰를 제공할 부모 타입이고, 두 번째 파라미터는 지정한 MRO 뷰를 접근할 때 사용할 인스턴스라는데 그냥 계속 모르도록 합시다. ㅠㅜ class MyBaseClass: def __init__(self, value): self.value = value # Example 12 class ExplicitTrisect(MyBaseClass): def __init__(self, value): super(ExplicitTrisect, self).__init__(value) self.value /= 3 # Example 13 class AutomaticTrisect(MyBaseClass): def __init__(self, value): super(__class__, self).__init__(value) self.value /= 3 class ImplicitTrisect(MyBaseClass): def __init__(self, value): super().__init__(value) self.value /= 3 print(ExplicitTrisect(9).value) # 3.0 print(AutomaticTrisect(9).value) # 3.0 print(ImplicitTrisect(9).value) # 3.0 ","date":"2020-12-23","objectID":"/2020-12-23_init-parent/:5:1","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 40. super로 부모 클래스를 초기화하라' 정리","uri":"/2020-12-23_init-parent/#41-super-에-파라미터-전달"},{"categories":["python"],"content":" 4.2 다이아몬드 상속 문제어떤 클래스가 두 가지 서로 다른 클래스를 상속하는데, 두 상위 클래스의 상위 계층을 올라가면 같은 조상 클래스가 존재하는 경우를 뜻합니다. 이런 경우에 공통 조상 클랫의 __init__()메서드가 여러 번 호출될 수 있습니다. 이런 케이스도 super() 를 통해 초기화 하면 문제가 없습니다. super()를 사용하면 다이아몬드 계층의 공통 상위 클래스를 단 한번만 호출하도록 보장한다고 합니다. 내부적으로 표준 메서드 결정 순서(Method Resolution Order, MRO)가 사용된다고 합니다. class MyBaseClass: def __init__(self, value): print(f'{__class__}.__init__()') self.value = value class TimesSevenCorrect(MyBaseClass): def __init__(self, value): print(f'{__class__}.__init__()') super().__init__(value) self.value *= 7 class PlusNineCorrect(MyBaseClass): def __init__(self, value): print(f'{__class__}.__init__()') super().__init__(value) self.value += 9 # Example 10 class GoodWay(TimesSevenCorrect, PlusNineCorrect): def __init__(self, value): print(f'{__class__}.__init__()') super().__init__(value) foo = GoodWay(5) print('Should be 7 * (5 + 9) = 98 and is', foo.value) \u003cclass '__main__.GoodWay'\u003e.__init__() \u003cclass '__main__.TimesSevenCorrect'\u003e.__init__() \u003cclass '__main__.PlusNineCorrect'\u003e.__init__() \u003cclass '__main__.MyBaseClass'\u003e.__init__() Should be 7 * (5 + 9) = 98 and is 98 super() 로 초기화하면 문제 없음 문제가 되는 케이스 class MyBaseClass: def __init__(self, value): print(f'{__class__}.__init__()') self.value = value # Example 7 class TimesSeven(MyBaseClass): def __init__(self, value): print(f'{__class__}.__init__()') MyBaseClass.__init__(self, value) self.value *= 7 class PlusNine(MyBaseClass): def __init__(self, value): print(f'{__class__}.__init__()') MyBaseClass.__init__(self, value) self.value += 9 # Example 8 class ThisWay(TimesSeven, PlusNine): def __init__(self, value): print(f'{__class__}.__init__()') TimesSeven.__init__(self, value) PlusNine.__init__(self, value) foo = ThisWay(5) print('Should be (5 * 7) + 9 = 44 but is', foo.value) \u003cclass '__main__.ThisWay'\u003e.__init__() \u003cclass '__main__.TimesSeven'\u003e.__init__() \u003cclass '__main__.MyBaseClass'\u003e.__init__() \u003cclass '__main__.PlusNine'\u003e.__init__() \u003cclass '__main__.MyBaseClass'\u003e.__init__() Should be (5 * 7) + 9 = 44 but is 14 ","date":"2020-12-23","objectID":"/2020-12-23_init-parent/:5:2","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 40. super로 부모 클래스를 초기화하라' 정리","uri":"/2020-12-23_init-parent/#42-다이아몬드-상속-문제"},{"categories":["python"],"content":" 10. 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 원저자 깃허브 ","date":"2020-12-23","objectID":"/2020-12-23_init-parent/:6:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 40. super로 부모 클래스를 초기화하라' 정리","uri":"/2020-12-23_init-parent/#10-참고-자료"},{"categories":["python"],"content":" 0. 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c5. Classes and Interfaces\u003e Item 39. Use @classmethod Polymorphism to Construct Objects Generically Better way 39. 객체를 제너릭하게 구성하려면 @classmethod를 통한 다형성을 활용하라 ","date":"2020-12-22","objectID":"/2020-12-22_multiple-constructor/:1:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 39. 객체를 제너릭하게 구성하려면 @classmethod를 통한 다형성을 활용하라' 정리","uri":"/2020-12-22_multiple-constructor/#0-들어가며"},{"categories":["python"],"content":" 1. 한 줄 요약 및 첨언@classmethod 를 사용해서 하위 클래스를 같은 방식으로 사용할 수 있습니다. ","date":"2020-12-22","objectID":"/2020-12-22_multiple-constructor/:2:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 39. 객체를 제너릭하게 구성하려면 @classmethod를 통한 다형성을 활용하라' 정리","uri":"/2020-12-22_multiple-constructor/#1-한-줄-요약-및-첨언"},{"categories":["python"],"content":" 2. 사용 예시책의 예제는 너무 복잡해서 조금 줄여 보았습니다. class GenericInputData: def read(self): raise NotImplementedError @classmethod # 클래스메서드로 표시 def generate_inputs(cls, config): raise NotImplementedError class PathInputData(GenericInputData): def __init__(self, i): super().__init__() self.path = f'temp_dir/{i}' def read(self): return self.path @classmethod def generate_inputs(cls, start): # 클래스를 인자로 받음 for i in range(start, start + 5): yield cls(i) # 인자로 받은 클래스로 인스턴스 생성 # 부모 클래스(GenericInput) 로 코딩 def temp_generate_inputs(input_class, start): it = input_class.generate_inputs(start) return it # 최초 사용 부분에서 자식 클래스 지정(PathInputData) data = temp_generate_inputs(PathInputData, 3) for x in data: # x는 PathInputData 객체 print(x.read()) temp_dir/3 temp_dir/4 temp_dir/5 temp_dir/6 temp_dir/7 ","date":"2020-12-22","objectID":"/2020-12-22_multiple-constructor/:3:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 39. 객체를 제너릭하게 구성하려면 @classmethod를 통한 다형성을 활용하라' 정리","uri":"/2020-12-22_multiple-constructor/#2-사용-예시"},{"categories":["python"],"content":" 3. 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Python only supports a single constructor per class: the __init__ method. 파이썬의 클래스에는 생성자가 __init__ 메서드 뿐이다. Tip Use @classmethod to define alternative constructors for your classes. @classmethod를 사용하면 클래스에 다른 생성자를 정의할 수 있다. Tip Use class method polymorphism to provide generic ways to build and connect many concrete subclasses. 클래스 메서드 다형성을 활용하면 여러 구체적인 하위 클래스의 객체를 만들고 연결하는 제너릭한 방법을 제공할 수 있다. ","date":"2020-12-22","objectID":"/2020-12-22_multiple-constructor/:4:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 39. 객체를 제너릭하게 구성하려면 @classmethod를 통한 다형성을 활용하라' 정리","uri":"/2020-12-22_multiple-constructor/#3-기억해야-할-내용"},{"categories":["python"],"content":" 10. 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 원저자 깃허브 ","date":"2020-12-22","objectID":"/2020-12-22_multiple-constructor/:5:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 39. 객체를 제너릭하게 구성하려면 @classmethod를 통한 다형성을 활용하라' 정리","uri":"/2020-12-22_multiple-constructor/#10-참고-자료"},{"categories":["python"],"content":" 0. 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c5. Classes and Interfaces\u003e Item 38: Accept Functions Instead of Classes for Simple Interfaces Better way 38. 간단한 인터페이스의 경우 클래스 대신 함수를 받아라 ","date":"2020-12-22","objectID":"/2020-12-22_functions-vs-class/:1:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 38. 간단한 인터페이스의 경우 클래스 대신 함수를 받아라' 정리","uri":"/2020-12-22_functions-vs-class/#0-들어가며"},{"categories":["python"],"content":" 1. 한 줄 요약 및 첨언간단한 인터페이스가 필요할 때는 클래스를 정의하고 인스턴스화하는 대신 간단히 함수를 사용할 수 있습니다. ","date":"2020-12-22","objectID":"/2020-12-22_functions-vs-class/:2:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 38. 간단한 인터페이스의 경우 클래스 대신 함수를 받아라' 정리","uri":"/2020-12-22_functions-vs-class/#1-한-줄-요약-및-첨언"},{"categories":["python"],"content":" 2. 사용 예시defaultdict 은, 특정 상황(없는 키로 접근)에서 호출할 함수를 넘겨 받습니다. from collections import defaultdict # Example 2 def log_missing(): print('Key added') return 0 # Example 3 current = {'green': 12, 'blue': 3} # 특정상황에서 넘겨 준 함수(log_missing)을 실행해 줌 # 인자로 받는 함수를 훅(hook)이라고 함. result = defaultdict(log_missing, current) print('Before:', dict(result)) increments = [ ('red', 5), ('blue', 17), ('orange', 9), ] for key, amount in increments: result[key] += amount print('After: ', dict(result)) Before: {'green': 12, 'blue': 3} Key added Key added After: {'green': 12, 'blue': 20, 'red': 5, 'orange': 9} 이제 존재하지 않는 키에 접근한 횟수를 세고 싶은 상황입니다. 호출 가능(callable) 객체를 사용한 예제입니다. 저 아래 클로저를 사용하는 것보다 명확합니다. from collections import defaultdict # Example 8 class BetterCountMissing: def __init__(self): self.added = 0 def __call__(self): # 호출 가능 객체 self.added += 1 return 0 current = {'green': 12, 'blue': 3} increments = [ ('red', 5), ('blue', 17), ('orange', 9), ] # Example 9 counter = BetterCountMissing() result = defaultdict(counter, current) # Relies on __call__ for key, amount in increments: result[key] += amount print(counter.added) # 2 print(dict(result)) # {'green': 12, 'blue': 20, 'red': 5, 'orange': 9} ","date":"2020-12-22","objectID":"/2020-12-22_functions-vs-class/:3:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 38. 간단한 인터페이스의 경우 클래스 대신 함수를 받아라' 정리","uri":"/2020-12-22_functions-vs-class/#2-사용-예시"},{"categories":["python"],"content":" 3. 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Instead of defining and instantiating classes, you can often simple use functions for simple interfaces between components in Python. 파이썬의 여러 컴포넌트 사이에 간단한 인터페이스가 필요할 때는 클래스를 정의하고 인스턴스화하는 대신 간단히 함수를 사용할 수 있다. Tip References to functions and methods in Python are first class, meaning they can be used in expressions (like any other type). 파이썬 함수나 메서드는 일급 시민이다. 따라서 (다른 타입의 값과 마찬가지로) 함수나 함수 참조를 식에 사용할 수 있다. Tip The __call__ special method enables instances of a class to be called like plain Python functions. __call__ 특별 메서드를 사용하면 클래스의 인스턴스 객체를 일반 파이썬 함수처럼 호출할 수 있다. Tip When you need a function to maintain state, consider defining a class that provides the __call__ method instead of defining a stateful closure. 상태를 유지하기 위한 함수가 필요한 경우에는 상태가 있는 클로저를 정의하는 대신 __call__ 메서드가 있는 클래스를 정의할지 고려해보라. ","date":"2020-12-22","objectID":"/2020-12-22_functions-vs-class/:4:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 38. 간단한 인터페이스의 경우 클래스 대신 함수를 받아라' 정리","uri":"/2020-12-22_functions-vs-class/#3-기억해야-할-내용"},{"categories":["python"],"content":" 4. 더 알아보기위와 같이 존재하지 않는 키에 접근한 횟수를 세고 싶은 상황입니다. ","date":"2020-12-22","objectID":"/2020-12-22_functions-vs-class/:5:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 38. 간단한 인터페이스의 경우 클래스 대신 함수를 받아라' 정리","uri":"/2020-12-22_functions-vs-class/#4-더-알아보기"},{"categories":["python"],"content":" 4.1 상태가 있는 클로저 사용Stateful closure를 사용한 예제입니다. 복잡하니 사용하지 맙시다. from collections import defaultdict # Example 4 def increment_with_report(current, increments): added_count = 0 def missing(): nonlocal added_count # Stateful closure added_count += 1 return 0 result = defaultdict(missing, current) for key, amount in increments: result[key] += amount return result, added_count current = {'green': 12, 'blue': 3} increments = [ ('red', 5), ('blue', 17), ('orange', 9), ] # Example 5 result, count = increment_with_report(current, increments) print(count) # 2 print(dict(result)) # {'green': 12, 'blue': 20, 'red': 5, 'orange': 9} ","date":"2020-12-22","objectID":"/2020-12-22_functions-vs-class/:5:1","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 38. 간단한 인터페이스의 경우 클래스 대신 함수를 받아라' 정리","uri":"/2020-12-22_functions-vs-class/#41-상태가-있는-클로저-사용"},{"categories":["python"],"content":" 4.2 메서드 사용추적하고 싶은 상태를 저장하는 작은 클래스를 정의하였습니다. from collections import defaultdict # Example 6 class CountMissing: def __init__(self): self.added = 0 def missing(self): self.added += 1 return 0 current = {'green': 12, 'blue': 3} increments = [ ('red', 5), ('blue', 17), ('orange', 9), ] # Example 7 counter = CountMissing() result = defaultdict(counter.missing, current) # Method ref for key, amount in increments: result[key] += amount print(counter.added) # 2 print(dict(result)) # {'green': 12, 'blue': 20, 'red': 5, 'orange': 9} 바로 위 Stateful closure를 사용하는 것보다 깔끔합니다. 하지만 CountMissing 클래스의 목적이 명확하게 보이지 않습니다. 누가 CountMissing 객체를 만들지, 누가 missing 메서드를 호출할지, 공개 메서드가 더 추가될 수 있을지, 사용 예제를 보기 전까지는 수수께끼일 뿐입니다. ","date":"2020-12-22","objectID":"/2020-12-22_functions-vs-class/:5:2","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 38. 간단한 인터페이스의 경우 클래스 대신 함수를 받아라' 정리","uri":"/2020-12-22_functions-vs-class/#42-메서드-사용"},{"categories":["python"],"content":" 10. 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 원저자 깃허브 ","date":"2020-12-22","objectID":"/2020-12-22_functions-vs-class/:6:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 38. 간단한 인터페이스의 경우 클래스 대신 함수를 받아라' 정리","uri":"/2020-12-22_functions-vs-class/#10-참고-자료"},{"categories":["python"],"content":" 0. 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c5. Classes and Interfaces\u003e Item 37: Compose Classes Instead of Nesting Many Levels of Built-in Types Better way 37. 내장 타입을 여러 단계로 내포시키기보다는 클래스를 합성하라 ","date":"2020-12-22","objectID":"/2020-12-22_compose-classes/:1:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 37. 내장 타입을 여러 단계로 내포시키기보다는 클래스를 합성하라' 정리","uri":"/2020-12-22_compose-classes/#0-들어가며"},{"categories":["python"],"content":" 1. 한 줄 요약 및 첨언내포 단계가 두 단계 이상이 되면 더 이상 딕셔너리, 리스트, 튜플 계층을 추가하지 말아야 합니다. 다른 사람이 이해하기 어려워지고, 조금만 지나도 기억나지 않을 겁니다. 값을 관리하는 부분이 점점 복잡해지고 있다면, 해당 기능을 클래스로 분리합시다. ","date":"2020-12-22","objectID":"/2020-12-22_compose-classes/:2:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 37. 내장 타입을 여러 단계로 내포시키기보다는 클래스를 합성하라' 정리","uri":"/2020-12-22_compose-classes/#1-한-줄-요약-및-첨언"},{"categories":["python"],"content":" 2. 사용 예시과목별로 여러번 시험을 보고, 그 시험마다 가중치가 다를 수 있는 상황입니다. namedtuple을 사용하는 Subject 클래스 정의했습니다. from collections import defaultdict, namedtuple # namedtuple을 사용하면 작은 불변 데이터 클래스를 쉽게 정의할 수 있음 Grade = namedtuple('Grade', ('score', 'weight')) # Example 12 class Subject: def __init__(self): self._grades = [] def report_grade(self, score, weight): self._grades.append(Grade(score, weight)) def average_grade(self): total, total_weight = 0, 0 for grade in self._grades: total += grade.score * grade.weight total_weight += grade.weight return total / total_weight Student는 Subject를 value 로 갖는 defaultdict을 가지고 있고, Gradebook은 Student를 value로 갖는 defaultdict을 가지고 있습니다. # Example 13 class Student: def __init__(self): self._subjects = defaultdict(Subject) def get_subject(self, name): return self._subjects[name] def average_grade(self): total, count = 0, 0 for subject in self._subjects.values(): total += subject.average_grade() count += 1 return total / count # Example 14 class Gradebook: def __init__(self): self._students = defaultdict(Student) def get_student(self, name): return self._students[name] 클래스 사용 # Example 15 book = Gradebook() albert = book.get_student('Albert Einstein') math = albert.get_subject('Math') math.report_grade(75, 0.05) math.report_grade(65, 0.15) math.report_grade(70, 0.80) print('Albert - Math:', math.average_grade()) # Albert - Math: 69.5 gym = albert.get_subject('Gym') gym.report_grade(100, 0.40) gym.report_grade(85, 0.60) print('Albert - Gym:', gym.average_grade()) # Albert - Gym: 91.0 print('Albert - Total:', albert.average_grade()) # Albert - Total: 80.25 ","date":"2020-12-22","objectID":"/2020-12-22_compose-classes/:3:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 37. 내장 타입을 여러 단계로 내포시키기보다는 클래스를 합성하라' 정리","uri":"/2020-12-22_compose-classes/#2-사용-예시"},{"categories":["python"],"content":" 3. 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Avoid making dictionaries with values that are dictionaries, long tuples, or complex nesting of other built-in types. 딕셔너리, 긴 튜플, 다른 내장 타입이 복잡하게 내포된 데이터를 값으로 사용하는 딕셔너리를 만들지 말라. Tip Use namedtuple for lightweight, immutable data containers before you need the flexibility of a full class. 완전한 클래스가 제공하는 유연성이 필요하지 않고 가벼운 불변 데이터 컨테이너가 필요하다면 namedtuple을 사용하라. Tip Move your bookkeeping code to using multiple classes when your internal state dictionaries get complicated. 내부 상태를 표현하는 딕셔너리가 복잡해지면 이 데이터를 관리하는 코드를 여러 클래스로 나눠서 재작성하라. ","date":"2020-12-22","objectID":"/2020-12-22_compose-classes/:4:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 37. 내장 타입을 여러 단계로 내포시키기보다는 클래스를 합성하라' 정리","uri":"/2020-12-22_compose-classes/#3-기억해야-할-내용"},{"categories":["python"],"content":" 4. 더 알아보기","date":"2020-12-22","objectID":"/2020-12-22_compose-classes/:5:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 37. 내장 타입을 여러 단계로 내포시키기보다는 클래스를 합성하라' 정리","uri":"/2020-12-22_compose-classes/#4-더-알아보기"},{"categories":["python"],"content":" 4.1 namedtuple의 한계namedtuple이 유용한 상황이 많지만, 아닌 경우도 많다고 합니다. namedtuple 클래스는 디폴트 인자 값을 지정할 수 없다. 따라서 선택적인 프로퍼티가 많은 데이터에 namedtuple을 사용하기는 어렵다. 프로퍼티가 4~5개보다 더 많아지면 dataclasses 내장 모듈을 사용하는 편이 낫다. 여전히 namedtuple 인스턴스의 애트리뷰트 값을 숫자 인덱스를 사용해 접근할 수 있도 이터레이션도 가능하다. 특히 외부에 제공하는 API의 경우 이런 특성으로 인해 나중에 namedtuple을 실제 클래스로 변경하기 어려울 수도 있다. 여러분이 namedtuple을 사용하는 모든 부분을 제어할 수 있는 상황이 아니라면 명시적으로 새로운 클래스를 정의하는 편이 더 낫다. ","date":"2020-12-22","objectID":"/2020-12-22_compose-classes/:5:1","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 37. 내장 타입을 여러 단계로 내포시키기보다는 클래스를 합성하라' 정리","uri":"/2020-12-22_compose-classes/#41-namedtuple의-한계"},{"categories":["python"],"content":" 10. 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 원저자 깃허브 ","date":"2020-12-22","objectID":"/2020-12-22_compose-classes/:6:0","series":["effective python 5. 클래스와 인터페이스"],"tags":["python"],"title":"'Better way 37. 내장 타입을 여러 단계로 내포시키기보다는 클래스를 합성하라' 정리","uri":"/2020-12-22_compose-classes/#10-참고-자료"},{"categories":["python"],"content":" 0. 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c4. Comprehensions and Generators\u003e Item 36: Consider itertools for Working with Iterators and Generators Better way 36. 이터레이터나 제너레이터를 다룰 때는 itertools를 사용하라 ","date":"2020-12-21","objectID":"/2020-12-21_itertools/:1:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 36. 이터레이터나 제너레이터를 다룰 때는 itertools를 사용하라' 정리","uri":"/2020-12-21_itertools/#0-들어가며"},{"categories":["python"],"content":" 1. 한 줄 요약 및 첨언작성하고 있는 이터레이션 코드가 뭔가 복잡하다면 itertools 에 솔루션이 있을지 모릅니다. ","date":"2020-12-21","objectID":"/2020-12-21_itertools/:2:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 36. 이터레이터나 제너레이터를 다룰 때는 itertools를 사용하라' 정리","uri":"/2020-12-21_itertools/#1-한-줄-요약-및-첨언"},{"categories":["python"],"content":" 2. 사용 예시N/A ","date":"2020-12-21","objectID":"/2020-12-21_itertools/:3:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 36. 이터레이터나 제너레이터를 다룰 때는 itertools를 사용하라' 정리","uri":"/2020-12-21_itertools/#2-사용-예시"},{"categories":["python"],"content":" 3. 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip The itertools functions fall into three main categories for working with iterators and generators: linking iterators together, filtering items they output, and producing combinations of items. 이터레이터나 제너레이터를 다루는 itertools 함수는 세 가지 범주로 나눌 수 있다. 여러 이터레이터를 연결함. 이터레이터의 원소를 걸러냄. 원소의 조합을 만들어냄. Tip There are more advanced functions, additional parameters, and useful recipes available in the documentation at help(itertools). 파이썬 인터프리터에서 help(itertools)를 입력한 수 표시되는 문서를 살펴보면 더 많은 고급 함수와 추가 파라미터를 알 수 있으며, 이를 사용하는 유용한 방법도 확인할 수 있다. ","date":"2020-12-21","objectID":"/2020-12-21_itertools/:4:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 36. 이터레이터나 제너레이터를 다룰 때는 itertools를 사용하라' 정리","uri":"/2020-12-21_itertools/#3-기억해야-할-내용"},{"categories":["python"],"content":" 4. 더 알아보기","date":"2020-12-21","objectID":"/2020-12-21_itertools/:5:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 36. 이터레이터나 제너레이터를 다룰 때는 itertools를 사용하라' 정리","uri":"/2020-12-21_itertools/#4-더-알아보기"},{"categories":["python"],"content":" 4.1 이터레이터 연결순서대로 연결 (chain) # Example 2 it = itertools.chain([1, 2, 3], [4, 5, 6]) print(list(it)) # [1, 2, 3, 4, 5, 6] 한 값을 계속 반복 (repeat) # Example 3 it = itertools.repeat('hello', 3) print(list(it)) # ['hello', 'hello', 'hello'] 계속 반복 (cycle) # Example 4 it = itertools.cycle([1, 2]) result = [next(it) for _ in range(10)] print(result) # [1, 2, 1, 2, 1, 2, 1, 2, 1, 2] it = itertools.cycle([1, 2]) print(next(it)) # 1 print(next(it)) # 2 print(next(it)) # 1 print(next(it)) # 2 동일한 여러 이터레이터 생성(tee) 생성한 이터레이터들은 같은 속도로 쓰는게 좋음 # Example 5 it1, it2, it3 = itertools.tee(['first', 'second'], 3) print(list(it1)) # ['first', 'second'] print(list(it2)) # ['first', 'second'] print(list(it3)) # ['first', 'second'] 여러 이터레이터 중 짧은 쪽 다 쓰면 지정한 값 채워줌 (zip_longest) zip의 변종. zip 은 한 쪽 다 쓰면 끝. # Example 6 keys = ['one', 'two', 'three'] # 3개 values = [1, 2] # 2개 normal = list(zip(keys, values)) print('zip: ', normal) # zip: [('one', 1), ('two', 2)] it = itertools.zip_longest(keys, values, fillvalue='nope') longest = list(it) print('zip_longest:', longest) # zip_longest: [('one', 1), ('two', 2), ('three', 'nope')] ","date":"2020-12-21","objectID":"/2020-12-21_itertools/:5:1","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 36. 이터레이터나 제너레이터를 다룰 때는 itertools를 사용하라' 정리","uri":"/2020-12-21_itertools/#41-이터레이터-연결"},{"categories":["python"],"content":" 4.2 이터레이터에서 원소 거르기인덱스로 슬라이싱(islice) import itertools # Example 7 values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] first_five = itertools.islice(values, 5) # 끝 지정 (인자 하나만 넘기면 끝) print('First five: ', list(first_five)) # First five: [1, 2, 3, 4, 5] middle_odds = itertools.islice(values, 2, 8, 2) # 시작, 끝, 증가값 지정 print('Middle odds:', list(middle_odds)) # Middle odds: [3, 5, 7] 조건이 True 인 동안 동작(takewhile) False 인 녀석 만나면 끝. # Example 8 values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 2] less_than_seven = lambda x: x \u003c 7 it = itertools.takewhile(less_than_seven, values) print(list(it)) # [1, 2, 3, 4, 5, 6] 조건이 True 인 동안 건너 뜀(dropwhile) 맨 처음 False 나오면 시작. # Example 9 values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 2] less_than_seven = lambda x: x \u003c 7 it = itertools.dropwhile(less_than_seven, values) print(list(it)) # [7, 8, 9, 10, 2] 조건이 False 인 녀석들만(filterfalse) filter 내장 함수의 반대 # Example 10 values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] evens = lambda x: x % 2 == 0 filter_result = filter(evens, values) print('Filter: ', list(filter_result)) # [2, 4, 6, 8, 10] filter_false_result = itertools.filterfalse(evens, values) print('Filter false:', list(filter_false_result)) # [1, 3, 5, 7, 9] ","date":"2020-12-21","objectID":"/2020-12-21_itertools/:5:2","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 36. 이터레이터나 제너레이터를 다룰 때는 itertools를 사용하라' 정리","uri":"/2020-12-21_itertools/#42-이터레이터에서-원소-거르기"},{"categories":["python"],"content":" 4.3 이터레이터에서 원소 조합 만들기누적 합 혹은 계산(accumulate) 이전 결과와 현재 원소로 결과 도출 # Example 11 values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # 함수를 지정하지 않으면 두 인자의 합 sum_reduce = itertools.accumulate(values) print('Sum: ', list(sum_reduce)) # Sum: [1, 3, 6, 10, 15, 21, 28, 36, 45, 55] # 두 개의 인자를 받는 함수 def sum_modulo_20(first, second): output = first + second return output % 20 modulo_reduce = itertools.accumulate(values, sum_modulo_20) print('Modulo:', list(modulo_reduce)) # Modulo: [1, 3, 6, 10, 15, 1, 8, 16, 5, 15] 데카르트 곱(product) # Example 12 single = itertools.product([1, 2], repeat=2) print('Single: ', list(single)) # Single: [(1, 1), (1, 2), (2, 1), (2, 2)] multiple = itertools.product([1, 2], ['a', 'b']) print('Multiple:', list(multiple)) # Multiple: [(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b')] 순열(permutations)과 조합(combinations, combinations_with_replacement) # Example 13 it = itertools.permutations([1, 2, 3], 2) print(list(it)) # [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)] # Example 14 it = itertools.combinations([1, 2, 3], 2) print(list(it)) # [(1, 2), (1, 3), (2, 3)] # Example 15 (원소의 반복 허용) it = itertools.combinations_with_replacement([1, 2, 3], 2) print(list(it)) # [(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)] ","date":"2020-12-21","objectID":"/2020-12-21_itertools/:5:3","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 36. 이터레이터나 제너레이터를 다룰 때는 itertools를 사용하라' 정리","uri":"/2020-12-21_itertools/#43-이터레이터에서-원소-조합-만들기"},{"categories":["python"],"content":" 10. 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 원저자 깃허브 itertools — Functions creating iterators for efficient looping / 파이썬 공식 문서 ","date":"2020-12-21","objectID":"/2020-12-21_itertools/:6:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 36. 이터레이터나 제너레이터를 다룰 때는 itertools를 사용하라' 정리","uri":"/2020-12-21_itertools/#10-참고-자료"},{"categories":["python"],"content":" 0. 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c4. Comprehensions and Generators\u003e Item 35: Avoid Causing State Transitions in Generators with throw Better way 35. 제너리이터 안에서 throw로 상태를 변화시키지 말라 ","date":"2020-12-21","objectID":"/2020-12-21_throw-in-generator/:1:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 35. 제너리이터 안에서 throw로 상태를 변화시키지 말라' 정리","uri":"/2020-12-21_throw-in-generator/#0-들어가며"},{"categories":["python"],"content":" 1. 한 줄 요약 및 첨언제너레이터에 throw 를 호출하지 말고, __iter__ 를 구현한 클래스를 이용해서 상태를 바꾸는 게 좋다고 합니다. 요런 것까지 쓸 일이 있나 싶긴 합니다. ","date":"2020-12-21","objectID":"/2020-12-21_throw-in-generator/:2:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 35. 제너리이터 안에서 throw로 상태를 변화시키지 말라' 정리","uri":"/2020-12-21_throw-in-generator/#1-한-줄-요약-및-첨언"},{"categories":["python"],"content":" 2. 사용 예시RESETS = [ False, False, True, False, True, False, False, False, False, False] def check_for_reset(): # Poll for external event return RESETS.pop(0) # 앞에꺼 하나씩 (2, 4번 인덱스 True) def announce(remaining): print(f'{remaining} ticks remaining') # Example 5 class Timer: def __init__(self, period): self.current = period self.period = period def reset(self): print(\"reset!!\", end=' ') self.current = self.period def __iter__(self): while self.current: self.current -= 1 yield self.current def run(): timer = Timer(4) for i, current in enumerate(timer): # __iter__() 사용해서 for 문 수행됨 print(f'[{i}] current({current})', end=': ') if check_for_reset(): # 외부 이벤트 확인 timer.reset() # 다시 처음(4) 부터 announce(current) run() 실행 결과 [0] current(3): 3 ticks remaining [1] current(2): 2 ticks remaining [2] current(1): reset!! 1 ticks remaining [3] current(3): 3 ticks remaining [4] current(2): reset!! 2 ticks remaining [5] current(3): 3 ticks remaining [6] current(2): 2 ticks remaining [7] current(1): 1 ticks remaining [8] current(0): 0 ticks remaining ","date":"2020-12-21","objectID":"/2020-12-21_throw-in-generator/:3:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 35. 제너리이터 안에서 throw로 상태를 변화시키지 말라' 정리","uri":"/2020-12-21_throw-in-generator/#2-사용-예시"},{"categories":["python"],"content":" 3. 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip The throw method can be used to re-raise exceptions within generators at the position of the most recently executed yield expression. throw 메서드를 사용하면 제너레이터가 마지막으로 실행한 yield 식의 위치에서 예외를 다시 발생시킬 수 있다. Tip Using throw harms readability because it requires additional nesting and boilerplate in order to raise and catch exceptions. throw를 사용하면 가독성이 나빠진다. 예외를 잡아내고 다시 발생시키는 데 준비 코드가 필요하며 내포 단계가 깊어지기 때문이다. Tip A better way to provide exceptional behavior in generators is to use a class that implements the __iter__ method along with methods to cause exceptional state transitions. 제너레이터에서 예외적인 동작을 제공하는 더 나은 방법은 __iter__ 메서드를 구현하는 클래스를 사용하면서 예외적인 경우에 상태를 전이시키는 것이다. ","date":"2020-12-21","objectID":"/2020-12-21_throw-in-generator/:4:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 35. 제너리이터 안에서 throw로 상태를 변화시키지 말라' 정리","uri":"/2020-12-21_throw-in-generator/#3-기억해야-할-내용"},{"categories":["python"],"content":" 4. 더 알아보기","date":"2020-12-21","objectID":"/2020-12-21_throw-in-generator/:5:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 35. 제너리이터 안에서 throw로 상태를 변화시키지 말라' 정리","uri":"/2020-12-21_throw-in-generator/#4-더-알아보기"},{"categories":["python"],"content":" 4.1 제너레이터에 throw 호출제너레이터 안에서 마지막으로 실행된 yield 문을 둘러쌈으로써 예외를 잡아낼 수 있습니다. class MyError(Exception): pass # Example 2 def my_generator(): yield 1 try: yield 2 # 여기까지 진행된 상태 except MyError: print('Got MyError!') # throw 로 받았음 else: yield 3 # except 들어 갔으니 요건 패스 yield 4 # except 처리하고 요거 리턴 it = my_generator() print(next(it)) # 1 print(next(it)) # 2 print(it.throw(MyError('test error'))) # 4 실행 결과 1 2 Got MyError! 4 ","date":"2020-12-21","objectID":"/2020-12-21_throw-in-generator/:5:1","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 35. 제너리이터 안에서 throw로 상태를 변화시키지 말라' 정리","uri":"/2020-12-21_throw-in-generator/#41-제너레이터에-throw-호출"},{"categories":["python"],"content":" 4.2 throw 로 위의 Timer 와 같은 동작을 한다면제너레이터 안에서 exception 을 캐치하면 바로 수정된 값을 던져주는 게 다르지만, 비슷한 컨셉으로 동작합니다. 어쨋든 사용하지 맙시다. # Example 3 class Reset(Exception): pass def timer(period): current = period while current: current -= 1 try: yield current except Reset: print('Reset!!', end=' ') current = period RESETS = [ False, False, True, False, True, False, False, False, False, False] def check_for_reset(): # Poll for external event return RESETS.pop(0) # 앞에꺼 하나씩 (3, 5번 인덱스 True) def announce(remaining): print(f'{remaining} ticks remaining') def run(): it = timer(4) i = 0 while True: print(f'[{i}]', end=' ') try: if check_for_reset(): current = it.throw(Reset()) # throw 하면, 바로 3을 받음 else: current = next(it) except StopIteration: break else: announce(current) i += 1 run() 실행 결과 [0] 3 ticks remaining [1] 2 ticks remaining [2] Reset!! 3 ticks remaining [3] 2 ticks remaining [4] Reset!! 3 ticks remaining [5] 2 ticks remaining [6] 1 ticks remaining [7] 0 ticks remaining [8] ","date":"2020-12-21","objectID":"/2020-12-21_throw-in-generator/:5:2","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 35. 제너리이터 안에서 throw로 상태를 변화시키지 말라' 정리","uri":"/2020-12-21_throw-in-generator/#42-throw-로-위의-timer-와-같은-동작을-한다면"},{"categories":["python"],"content":" 10. 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 원저자 깃허브 ‘Better way 31. 인자에 대해 이터레이션 할 때는 방어적이 되라’ 정리 ","date":"2020-12-21","objectID":"/2020-12-21_throw-in-generator/:6:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 35. 제너리이터 안에서 throw로 상태를 변화시키지 말라' 정리","uri":"/2020-12-21_throw-in-generator/#10-참고-자료"},{"categories":["python"],"content":" 0. 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c4. Comprehensions and Generators\u003e Item 34: Avoid Injecting Data into Generators with send Better way 34. send로 제너레이터에 데이터를 주입하지 말라 ","date":"2020-12-21","objectID":"/2020-12-21_send-in-generator/:1:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 34. send로 제너레이터에 데이터를 주입하지 말라' 정리","uri":"/2020-12-21_send-in-generator/#0-들어가며"},{"categories":["python"],"content":" 1. 한 줄 요약 및 첨언제너레이터에 send를 통해 데이터를 주입하는게 가능하기는 합니다. 하지만 제너레이터는 그렇게 안쓰는 게 좋다고 합니다. 원래 몰랐으니, 계속 모르도록 하겠습니다. ","date":"2020-12-21","objectID":"/2020-12-21_send-in-generator/:2:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 34. send로 제너레이터에 데이터를 주입하지 말라' 정리","uri":"/2020-12-21_send-in-generator/#1-한-줄-요약-및-첨언"},{"categories":["python"],"content":" 2. 사용 예시N/A ","date":"2020-12-21","objectID":"/2020-12-21_send-in-generator/:3:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 34. send로 제너레이터에 데이터를 주입하지 말라' 정리","uri":"/2020-12-21_send-in-generator/#2-사용-예시"},{"categories":["python"],"content":" 3. 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip The send method can be used to inject data into a generator by giving the yield expression a value that can be assigned to a variable. send 메서드를 사용해 데이터를 제너레이터에 주입할 수 있다. 제너레이터는 send로 주입된 값을 yield 식이 반환하는 값을 통해 받으며, 이 값을 변수에 저장해 활용할 수 있다. Tip Using send with yield from expressions may cause surprising behavior, such as None values appearing at unexpected times in the generator output. send와 yield from 식을 함께 사용하면 제너레이터의 출력에 None이 불쑥불쑥 나타나는 의외의 결과를 얻을 수도 있다. Tip Providing an input iterator to a set of composed generators is a better approach than using the send method, which should be avoided. 합성할 제너레이터들의 입력으로 이터레이터를 전달하는 방식이 send를 사용하는 방식보다 더 낫다. send는 가급적 사용하지 말라. ","date":"2020-12-21","objectID":"/2020-12-21_send-in-generator/:4:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 34. send로 제너레이터에 데이터를 주입하지 말라' 정리","uri":"/2020-12-21_send-in-generator/#3-기억해야-할-내용"},{"categories":["python"],"content":" 4. 더 알아보기","date":"2020-12-21","objectID":"/2020-12-21_send-in-generator/:5:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 34. send로 제너레이터에 데이터를 주입하지 말라' 정리","uri":"/2020-12-21_send-in-generator/#4-더-알아보기"},{"categories":["python"],"content":" 4.1 제너레이터에 send를 꼭 사용한다면import math # Example 2 (output 사용처) def transmit(output): if output is None: print(f'Output is None') else: print(f'Output: {output:\u003e5.1f}') # Example 5 (제너레이터) def wave_modulating(steps): step_size = 2 * math.pi / steps amplitude = yield # Receive initial amplitude (최초 None 을 send 하면 여기까지 진행) print(' received ', amplitude) # 두번째 7 send 하면, 위 라인에서 받아서 다음 yield 까지 진행 for step in range(steps): radians = step * step_size fraction = math.sin(radians) output = amplitude * fraction print(' prepared output', amplitude, output) amplitude = yield output # Receive next amplitude print(' received ', amplitude) # Example 6 def run_modulating(it): # 시작 안된 제너레이터에는 None 만 보낼 수 있음 amplitudes = [None, 7, 7, 7, 2, 2, 2, 2, 10, 10, 10, 10, 10] for i, amplitude in enumerate(amplitudes): print(f'\\nbefore send. amplitude[{i}]: {amplitude}') output = it.send(amplitude) print(f'after send. output: {output}') transmit(output) run_modulating(wave_modulating(12)) before send. amplitude[0]: None after send. output: None Output is None before send. amplitude[1]: 7 received 7 prepared output 7 0.0 after send. output: 0.0 Output: 0.0 ... before send. amplitude[3]: 7 received 7 prepared output 7 6.06217782649107 after send. output: 6.06217782649107 Output: 6.1 before send. amplitude[4]: 2 received 2 prepared output 2 2.0 after send. output: 2.0 Output: 2.0 ","date":"2020-12-21","objectID":"/2020-12-21_send-in-generator/:5:1","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 34. send로 제너레이터에 데이터를 주입하지 말라' 정리","uri":"/2020-12-21_send-in-generator/#41-제너레이터에-send를-꼭-사용한다면"},{"categories":["python"],"content":" 10. 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 원저자 깃허브 ","date":"2020-12-21","objectID":"/2020-12-21_send-in-generator/:6:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 34. send로 제너레이터에 데이터를 주입하지 말라' 정리","uri":"/2020-12-21_send-in-generator/#10-참고-자료"},{"categories":["python"],"content":" 0. 들어가며파이썬을 사용할 때 리스트와 딕셔너리는 정말 큰 비중을 차지하는 것 같습니다. 그중에서 딕셔너리는 특정 키가 없는 상황을 잘 처리해야 합니다. 이 때, 유용한 defaultdict 객체에 대해서 정리하려고 합니다. 기존 리스트에서 약간의 변형이 필요하거나 필터링이 필요할 때, 리스트 컴프리헨션을 이용해 짧은 코드로 원하는 리스트를 손쉽게 만들 수 있습니다. 딸내미가 그려준 파이썬 로고를 자랑하고 싶었던 건 안비밀입니다. ","date":"2020-12-20","objectID":"/2020-12-20_defaultdict/:1:0","series":null,"tags":["python"],"title":"디폴트 값을 자동으로 만들어 주는 defaultdict 컨테이너","uri":"/2020-12-20_defaultdict/#0-들어가며"},{"categories":["python"],"content":" 1. 한 줄 요약defaultdict은 dict 대신에 사용할 수 있습니다. 없는 키로 접근하면 해당 키에 디폴트 값을 일단 할당한 후 리턴해 줍니다. 없는 키에 대한 부담없이 딕셔너리를 사용할 수 있게 됩니다. ","date":"2020-12-20","objectID":"/2020-12-20_defaultdict/:2:0","series":null,"tags":["python"],"title":"디폴트 값을 자동으로 만들어 주는 defaultdict 컨테이너","uri":"/2020-12-20_defaultdict/#1-한-줄-요약"},{"categories":["python"],"content":" 2. 사용방법from collections import defaultdict s = 'mississippi' d = defaultdict(int) # 없는 키로 접근하면, 먼저 해당 키에 `int()` 호출해서 대입해 줌 for k in s: d[k] += 1 # d[k] 에 적절한 값이 항상 있다고 확신할 수 있음 temp = sorted(d.items()) print(temp) # [('i', 4), ('m', 1), ('p', 2), ('s', 4)] print(d) # defaultdict(\u003cclass 'int'\u003e, {'m': 1, 'i': 4, 's': 4, 'p': 2}) ","date":"2020-12-20","objectID":"/2020-12-20_defaultdict/:3:0","series":null,"tags":["python"],"title":"디폴트 값을 자동으로 만들어 주는 defaultdict 컨테이너","uri":"/2020-12-20_defaultdict/#2-사용방법"},{"categories":["python"],"content":" 3. 더 알아보기","date":"2020-12-20","objectID":"/2020-12-20_defaultdict/:4:0","series":null,"tags":["python"],"title":"디폴트 값을 자동으로 만들어 주는 defaultdict 컨테이너","uri":"/2020-12-20_defaultdict/#3-더-알아보기"},{"categories":["python"],"content":" 3.1 그냥 dict을 사용 (get)없는 키에 대해서 리턴 받을 값을 지정할 수 있는 dict.get()1을 사용하면 아래처럼 됩니다. s = 'mississippi' d = {} for k in s: d[k] = d.get(k, 0) + 1 temp = sorted(d.items()) print(temp) # [('i', 4), ('m', 1), ('p', 2), ('s', 4)] print(d) # {'m': 1, 'i': 4, 's': 4, 'p': 2} ","date":"2020-12-20","objectID":"/2020-12-20_defaultdict/:4:1","series":null,"tags":["python"],"title":"디폴트 값을 자동으로 만들어 주는 defaultdict 컨테이너","uri":"/2020-12-20_defaultdict/#31-그냥-dict을-사용-get"},{"categories":["python"],"content":" 3.2 그냥 dict을 사용 (setdefault)dict.setdefault()2을 사용할 수도 있지만, setdefault는 이름이 좀 애매해서(혼동을 줄 수 있어서) 비추하는 것 같습니다. s = 'mississippi' d = {} for k in s: d[k] = d.setdefault(k, 0) + 1 temp = sorted(d.items()) print(temp) # [('i', 4), ('m', 1), ('p', 2), ('s', 4)] print(d) # {'m': 1, 'i': 4, 's': 4, 'p': 2} ","date":"2020-12-20","objectID":"/2020-12-20_defaultdict/:4:2","series":null,"tags":["python"],"title":"디폴트 값을 자동으로 만들어 주는 defaultdict 컨테이너","uri":"/2020-12-20_defaultdict/#32-그냥-dict을-사용-setdefault"},{"categories":["python"],"content":" 10. 참고자료 defaultdict objects / Python 공식문서 ‘Better way 17. 내부 상태에서 원소가 없는 경우를 처리할 때는 setdefault보다 defaultdict를 사용하라’ 정리 dict.get(key [,default]) 파이썬 공식 문서 링크 딕셔너리에 key가 있으면 해당 value 리턴. 없으면 인자로 받은 default 값(안 넘겼으면 None)을 리턴. ↩︎ dict.setdefault(key [,default]) 파이썬 공식 문서 링크 딕셔너리에 key가 있으면 해당 value 리턴. 없으면 인자로 받은 default 값(안 넘겼으면 None)을 해당 키에 할당하고 리턴. ↩︎ ","date":"2020-12-20","objectID":"/2020-12-20_defaultdict/:5:0","series":null,"tags":["python"],"title":"디폴트 값을 자동으로 만들어 주는 defaultdict 컨테이너","uri":"/2020-12-20_defaultdict/#10-참고자료"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c4. Comprehensions and Generators\u003e Item 33: Compose Multiple Generators with yield from Better way 33. yield from을 사용해 여러 제너레이터를 합성하라 ","date":"2020-12-18","objectID":"/2020-12-18_yield-from/:1:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 33. yield from을 사용해 여러 제너레이터를 합성하라' 정리","uri":"/2020-12-18_yield-from/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언제너레이터가 제너레이터를 내포할 때는 yield from으로 내포된 제네레이터에서 값을 바로 내보냅시다. ","date":"2020-12-18","objectID":"/2020-12-18_yield-from/:2:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 33. yield from을 사용해 여러 제너레이터를 합성하라' 정리","uri":"/2020-12-18_yield-from/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 사용 예시제너레이터를 사용해 한 루프마다 이미지의 변위를 만들어 내는 동작이 필요한 상황입니다. def move(period, speed): for _ in range(period): yield speed def pause(delay): for _ in range(delay): yield 0 def render(delta): print(f'Delta: {delta:.1f}') # Move the images onscreen def run(func): for delta in func(): render(delta) # Example 4 (yield from 사용) def animate_composed(): yield from move(4, 5.0) yield from pause(3) yield from move(2, 3.0) run(animate_composed) Delta: 5.0 Delta: 5.0 Delta: 5.0 Delta: 5.0 Delta: 0.0 Delta: 0.0 Delta: 0.0 Delta: 3.0 Delta: 3.0 ","date":"2020-12-18","objectID":"/2020-12-18_yield-from/:3:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 33. yield from을 사용해 여러 제너레이터를 합성하라' 정리","uri":"/2020-12-18_yield-from/#사용-예시"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip The yield from expression allows you to compose multiple nested generators together into a single combined generator. yield from 식을 사용하면 여러 내장 제너레이터를 모아서 제너레이터 하나로 합성할 수 있다. Tip yield from provides better performance than manually iterating nested generators and yielding their outputs. 직접 내포된 제너레이터를 이터레이션하면서 각 제너레이터의 출력을 내보내는 것보다 yield from을 사용하는 것이 성능 면에서 더 좋다. ","date":"2020-12-18","objectID":"/2020-12-18_yield-from/:4:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 33. yield from을 사용해 여러 제너레이터를 합성하라' 정리","uri":"/2020-12-18_yield-from/#기억해야-할-내용"},{"categories":["python"],"content":" yield from 성능 비교tileit 내장 모듈을 사용한 벤치마크 # Example 5 import timeit def child(): for i in range(1_000_000): yield i # yield from 사용하지 않은 구현 def slow(): for i in child(): yield i # yield from 사용한 구현 def fast(): yield from child() baseline = timeit.timeit( stmt='for _ in slow(): pass', globals=globals(), number=50) print(f'Manual nesting {baseline:.2f}s') comparison = timeit.timeit( stmt='for _ in fast(): pass', globals=globals(), number=50) print(f'Composed nesting {comparison:.2f}s') reduction = -(comparison - baseline) / baseline print(f'{reduction:.1%} less time') Manual nesting 6.00s Composed nesting 5.11s 14.8% less time ","date":"2020-12-18","objectID":"/2020-12-18_yield-from/:5:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 33. yield from을 사용해 여러 제너레이터를 합성하라' 정리","uri":"/2020-12-18_yield-from/#yield-from-성능-비교"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 길벗출판사 깃허브 원저자 깃허브 ","date":"2020-12-18","objectID":"/2020-12-18_yield-from/:6:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 33. yield from을 사용해 여러 제너레이터를 합성하라' 정리","uri":"/2020-12-18_yield-from/#참고-자료"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c4. Comprehensions and Generators\u003e Item 32: Consider Generator Expressions for Large List Comprehensions Better way 32. 긴 리스트 컴프리헨션보다는 제너레이터 식을 사용하라 ","date":"2020-12-18","objectID":"/2020-12-18_generator-vs-comprehension/:1:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 32. 긴 리스트 컴프리헨션보다는 제너레이터 식을 사용하라' 정리","uri":"/2020-12-18_generator-vs-comprehension/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언()사이에 리스트 컴프리헨션과 비슷한 구문을 넣어 제너레이터 식(generator expression)을 만들 수 있습니다. 입력의 길이가 긴 경우에 적극 고려합시다. ","date":"2020-12-18","objectID":"/2020-12-18_generator-vs-comprehension/:2:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 32. 긴 리스트 컴프리헨션보다는 제너레이터 식을 사용하라' 정리","uri":"/2020-12-18_generator-vs-comprehension/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 사용 예시두 리스트에 대해서 같은 인덱스를 봐야하는 상황에서 사용할 수 있습니다. path = 'my_file.txt' # aaaaaa # aaaa # aaa # # aaaa # # 리스트 컴프리헨션 value = [len(x) for x in open('my_file.txt')] print(value) # [7, 5, 4, 1, 5] (뉴라인 문자가 있어 눈에 보이는 것 보다 1 길다) # Example 2 (제너레이터 식) it = (len(x) for x in open('my_file.txt')) print(it) # \u003cgenerator object \u003cgenexpr\u003e at 0x000002F4E761DAC0\u003e print(next(it)) # 7 print(next(it)) # 5 ","date":"2020-12-18","objectID":"/2020-12-18_generator-vs-comprehension/:3:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 32. 긴 리스트 컴프리헨션보다는 제너레이터 식을 사용하라' 정리","uri":"/2020-12-18_generator-vs-comprehension/#사용-예시"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip List comprehensions can cause problems for large inputs by using too much memory. 입력이 크면 메모리를 너무 많이 사용하기 때문에 리스트 컴프리헨션은 문제를 일으킬 수 있다. Tip Generator expressions avoid memory issues by producing outputs one at a time as iterators. 제너레이터 식은 이터레이터처럼 한 번에 원소를 하나씩 출력하기 때문에 메모리 문제를 피할 수 있다. Tip Generator expressions can be composed by passing the iterator from one generator expression into the for subexpression of another. 제너레이터 식이 반환한 이터레이터를 다른 제너레이터 식의 하위 식으로 사용함으로써 제너레이터 식을 서로 합성할 수 있다. Tip Generator expressions execute very quickly when chained together and are memory efficient. 서로 연결된 제너레이터 식은 매우 빠르게 실행되며 메모리도 효율적으로 사용한다. ","date":"2020-12-18","objectID":"/2020-12-18_generator-vs-comprehension/:4:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 32. 긴 리스트 컴프리헨션보다는 제너레이터 식을 사용하라' 정리","uri":"/2020-12-18_generator-vs-comprehension/#기억해야-할-내용"},{"categories":["python"],"content":" 제너레이터 식 합성제너레이터 식이 반환한 이터레이터를 다른 제너레이터 식의 입력으로 사용. # Example 2 (제너레이터 식) it = (len(x) for x in open('my_file.txt')) print(it) # \u003cgenerator object \u003cgenexpr\u003e at 0x000002F4E761DAC0\u003e # 제너레이터 식 합성 (roots 에 next가 불리면 it 먼저 한 칸 진행함) roots = ((x, x**0.5) for x in it) print(next(roots)) # (7, 2.6457513110645907) print(next(roots)) # (5, 2.23606797749979) ","date":"2020-12-18","objectID":"/2020-12-18_generator-vs-comprehension/:5:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 32. 긴 리스트 컴프리헨션보다는 제너레이터 식을 사용하라' 정리","uri":"/2020-12-18_generator-vs-comprehension/#제너레이터-식-합성"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 길벗출판사 깃허브 원저자 깃허브 ","date":"2020-12-18","objectID":"/2020-12-18_generator-vs-comprehension/:6:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 32. 긴 리스트 컴프리헨션보다는 제너레이터 식을 사용하라' 정리","uri":"/2020-12-18_generator-vs-comprehension/#참고-자료"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c4. Comprehensions and Generators\u003e Item 31: Be Defensive When Iterating Over Arguments Better way 31. 인자에 대해 이터레이션 할 때는 방어적이 되라 ","date":"2020-12-18","objectID":"/2020-12-18_iterating-over-argument/:1:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 31. 인자에 대해 이터레이션 할 때는 방어적이 되라' 정리","uri":"/2020-12-18_iterating-over-argument/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언인자로 이터레이터를 받을 때는 주의해야 합니다. (이미 사용한 이터레이터와 원래 비어있는 이터레이터를 구분 불가) 한 번 사용한 이터레이터는 (소진된 상태 이므로) 다시 사용할 수 없습니다. 같은 항목들에 대해서 순회가 필요하면, 필요할 때마다 새로운 이터레이터를 만들거나, 이터레이터 프로토콜(iterator protocol)을 구현한 새로운 컨테이터 클래스를 만들어 사용할 수 있습니다. (후자를 추천) ","date":"2020-12-18","objectID":"/2020-12-18_iterating-over-argument/:2:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 31. 인자에 대해 이터레이션 할 때는 방어적이 되라' 정리","uri":"/2020-12-18_iterating-over-argument/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 사용 예시이터레이터 프로토콜을 구현한 컨테이너 클래스 사용(Example 10) # Example 1 (받은 인자로 두 번 순회 수행함) def normalize(numbers): total = sum(numbers) # 한 번 result = [] for value in numbers: # 두 번 (numbers 가 이터레이터면 위에서 소진 되었음) percent = 100 * value / total result.append(percent) return result # Example 10 (이터레이터 프로토콜을 구현한 컨테이너 클래스) class ReadVisits: def __init__(self, data_path): self.data_path = data_path def __iter__(self): # 요걸 제너레이터로 구현. for 구문에 쓰일 때 요게 사용됨 with open(self.data_path) as f: for line in f: yield int(line) path = 'my_numbers.txt' # 15 # 35 # 80 # Example 11 visits = ReadVisits(path) percentages = normalize(visits) print(percentages) # [11.538461538461538, 26.923076923076923, 61.53846153846154] assert sum(percentages) == 100.0 ","date":"2020-12-18","objectID":"/2020-12-18_iterating-over-argument/:3:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 31. 인자에 대해 이터레이션 할 때는 방어적이 되라' 정리","uri":"/2020-12-18_iterating-over-argument/#사용-예시"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Beware of functions and methods that iterate over input arguments multiple times. If these arguments are iterators, you may see strange behavior and missing values. 입력 인자를 여러 번 이터레이션하는 함수나 메서드를 조심하라. 입력받은 인자가 이터레이터면 함수가 이상하게 작동하거나 결과가 없을 수 있다. Tip Python’s iterator protocol defines how containers and iterators interact with the iter and next built-in functions, for loops, and related expressions. 파이썬의 이터레이터 프로토콜은 컨테이너와 이터레이터가 iter, next 내장 함수나 for 루프 등의 관련 식과 상호작용하는 절차를 정의한다. Tip You can easily define your own iterable container type by implementing the __iter__ method as a generator. __iter__ 메서드를 제너레이터로 정의하면 쉽게 이터러블 컨테이너 타입을 정의할 수 있다. Tip You can detect that a value is an iterator (instead of a container) if calling iter on it produces the same value as what you passed in. Alternatively, you can use the isinstance built-in function along with the collections.abc.Iterator class. 어떤 값이 (컨테이너가 아닌) 이터레이터인지 감지하려면, 이 값을 iter 내장 함수에 넘겨서 반환되는 값이 원래 값과 같은지 확인하면 된다. 다른 방법으로 collections.abc.Iterator 클래스를 isinstance와 함께 사용할 수도 있다. ","date":"2020-12-18","objectID":"/2020-12-18_iterating-over-argument/:4:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 31. 인자에 대해 이터레이션 할 때는 방어적이 되라' 정리","uri":"/2020-12-18_iterating-over-argument/#기억해야-할-내용"},{"categories":["python"],"content":" lambda 이용해서 필요할 때마다 이터레이터 생성이터레이터를 필요할 때마다 다시 만드는 방법입니다. 추천하지는 않습니다. def read_visits(data_path): with open(data_path) as f: for line in f: yield int(line) # Example 8 def normalize_func(get_iter): total = sum(get_iter()) # New iterator result = [] for value in get_iter(): # New iterator percent = 100 * value / total result.append(percent) return result # Example 9 path = 'my_numbers.txt' percentages = normalize_func(lambda: read_visits(path)) print(percentages) # [11.538461538461538, 26.923076923076923, 61.53846153846154] assert sum(percentages) == 100.0 ","date":"2020-12-18","objectID":"/2020-12-18_iterating-over-argument/:5:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 31. 인자에 대해 이터레이션 할 때는 방어적이 되라' 정리","uri":"/2020-12-18_iterating-over-argument/#lambda-이용해서-필요할-때마다-이터레이터-생성"},{"categories":["python"],"content":" 인자가 Iterator 인지 확인isinstance 로 Iterator 인지 확인할 수 있습니다. 우리가 원하는 건 컨테이너여야 합니다. 리스트와 이터레이터 프로토콜을 구현한 컨테이너 클래스는 Iterator 가 아닌 걸로 판단되서 문제가 없고, 제너레이터 함수로 만들어진 이터레이터는 조건에 걸려서 에러가 발생합니다. # Example 13 from collections.abc import Iterator def normalize_defensive(numbers): if isinstance(numbers, Iterator): # Another way to check raise TypeError(f'Must supply a container, {type(numbers)}') total = sum(numbers) result = [] for value in numbers: percent = 100 * value / total result.append(percent) return result # Example 10 class ReadVisits: def __init__(self, data_path): self.data_path = data_path def __iter__(self): with open(self.data_path) as f: for line in f: yield int(line) # 제너레이터 def read_visits(data_path): with open(data_path) as f: for line in f: yield int(line) # Example 14 visits = [15, 35, 80] print(type(visits)) # \u003cclass 'list'\u003e percentages = normalize_defensive(visits) assert sum(percentages) == 100.0 path = 'my_numbers.txt' visits = ReadVisits(path) print(type(visits)) # \u003cclass '__main__.ReadVisits'\u003e percentages = normalize_defensive(visits) assert sum(percentages) == 100.0 visits = read_visits(path) # 요건 제너레이터 print(type(visits)) # \u003cclass 'generator'\u003e percentages = normalize_defensive(visits) # TypeError: Must supply a container, \u003cclass 'generator'\u003e ","date":"2020-12-18","objectID":"/2020-12-18_iterating-over-argument/:6:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 31. 인자에 대해 이터레이션 할 때는 방어적이 되라' 정리","uri":"/2020-12-18_iterating-over-argument/#인자가-iterator-인지-확인"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 길벗출판사 깃허브 원저자 깃허브 ","date":"2020-12-18","objectID":"/2020-12-18_iterating-over-argument/:7:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 31. 인자에 대해 이터레이션 할 때는 방어적이 되라' 정리","uri":"/2020-12-18_iterating-over-argument/#참고-자료"},{"categories":["투자 일반"],"content":"요즘 강환국 형님의 ‘할수있다 알고투자’ 채널을 열심히 시청하고 있습니다. 요 채널을 너무 늦게 알았습니다 ㅠㅜ 100개 때마다 기존 영상들 정리해 주시는데, 따라가기 쉽게 링크 정리해 봤습니다. 언제 다 듣나요 ㅠㅜㅠㅜ 400. (채널가이드) 돈 버는 모든 비법, 400개 영상에 담다!에서 정리해주신 목차들의 영상 링크를 모아 보았습니다. ","date":"2020-12-17","objectID":"/2020-12-17_halto-400/:0:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '400. (채널가이드) 돈 버는 모든 비법, 400개 영상에 담다!' 정리","uri":"/2020-12-17_halto-400/#"},{"categories":["투자 일반"],"content":" 1. 강환국의 하이라이트 투자를 왜 해야 하는가 35. [초보] 투자는 선택이 아니라 생존이다!! (1) 36. [초보] 투자는 선택이 아니라 생존이다!! (2) (왕초보 1억)시리즈: 345에서 시작 345. (왕초보) 5년만에 무에서 1억 만들기 - 돈의 노예에서 벗어나자! 4계절 포트폴리오(올웨더) 37. [초보] 투자자 99%에 맞는 필승 투자법 - 4계절 포트폴리오 38. [초보] 투자자 99%에 맞는 필승 투자법 - 4계절 포트폴리오의 한국화 353. (왕초보 1억) 4계절 포트폴리오(올웨더) 초간단 설명! 영구 폴트폴리오 348. (왕초보 1억) - 초보자 투자는 이렇게 - 영구 포트폴리오의 모든 것! 강환국님 현재 포트폴리오 338. 나라면 이런거 사겠다 - 2020 4월 버전! 부동산 슈퍼전략 88. 벌 수 있다! 아파트로 복리 30%!! 40세 은퇴 시리즈: 278부터 278. [왕초보] 40세 은퇴, 가능한가? (1) 부의 추월차선 시리즈: 297부터 297. (초보) 부자들이 모두 추천하는 그 책, 부의 추월차선 (1) 투자를 망치는 40여개 편향: 285부터. 318은 보너스 285. [초보] 투자를 망치는 40여개의 편향, 총정리 (1) 318. (투자심리) 강환국 폭망에서 무엇을 배울 수 있는가? ","date":"2020-12-17","objectID":"/2020-12-17_halto-400/:1:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '400. (채널가이드) 돈 버는 모든 비법, 400개 영상에 담다!' 정리","uri":"/2020-12-17_halto-400/#1-강환국의-하이라이트"},{"categories":["투자 일반"],"content":" 2. 초보들은 이런 영상부터 먼저! 정말 바쁘셔서 영상 한 개만 보신다고요? 218번 추천 (좀 더 시간이 되시면: 12, 34, 364 - 큰그림) 218. (초보) 투자의 기초, 한시간 만에 완료!! 12. [초보] 초보도 이해할 수 있는 주식투자! 34. [초보] 투자의 진정한 빅 픽쳐 - 나에게는 어떤 투자전략이 어울리는가? 364. (초보)혼란스러운 투자의 세계, 15분만에 간단정리! 투자를 왜 해야 하는가? 35, 36 35. [초보] 투자는 선택이 아니라 생존이다!! (1) 36. [초보] 투자는 선택이 아니라 생존이다!! (2) 닥치고 1억부터 모읍시다! 돈의 노예냐 주인이냐? 345. (왕초보) 5년만에 무에서 1억 만들기 - 돈의 노예에서 벗어나자! 사회초년생, 처음부터 부자 마인드 장착! 343, 350, 351, 372, 373, 391, 392, 396, 401 343. 레이 달리오 투자, 인생 3대 원칙! 350. (왕초보 1억) - 부자 인생을 계획해보자 - 동기부여란 이런것! 351. (왕초보 1억) - 강환국이 경험한 독일 부자와 금수저들! 372. (왕초보 1억) 1억을 모으면 다음 월급부터 다 써도 된다? 373. (왕초보 1억) 사회초년생, 이것만은 무조건 하자! 391. (왕초보 1억) 월세 살면서 주식에 올인? 392. (왕초보 1억) 부자는 나쁜놈들인가? 396. (왕초보 1억) 부자의 공통점 5개 401. 제로금리 시대 채권에 투자해도 되나요 + 신규 올웨더 전략 ","date":"2020-12-17","objectID":"/2020-12-17_halto-400/:2:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '400. (채널가이드) 돈 버는 모든 비법, 400개 영상에 담다!' 정리","uri":"/2020-12-17_halto-400/#2-초보들은-이런-영상부터-먼저"},{"categories":["투자 일반"],"content":" 3. 초보 투자 - 좀 더 구체적으로? 40세까지 어떻게 은퇴? (직장인) 138, 278, 281, 282, 289 138. [왕초보] 얼마를 모아야 은퇴가 가능한가? 278. [왕초보] 40세 은퇴, 가능한가? (1) 281. [왕초보] 40세 은퇴, 가능한가? (2) 282. [왕초보] 40세 은퇴, 가능한가? (3) 289. [왕초보] 40세 은퇴, 가능한가? (4) 40세까지 어떻게 은퇴? (창업) 297, 298, 309, 312, 315 297. (초보) 부자들이 모두 추천하는 그 책, 부의 추월차선 (1) 298. (초보) 부자들이 모두 추천하는 그 책, 부의 추월차선 (2) 309. 부자들이 모두 추천하는 그 책, 부의 추월차선 (3) 312. (초보) 부자들이 모두 추천하는 그 책, 부의 추월차선 (4) 315. (초보) 부자들이 가장 중요시 여기는 것은 무엇일까 - 부의 추월차선 (5) 40세 은퇴 시리즈 요약 316. 40세 은퇴 + 부의 추월차선 시리즈 결론 및 맞춤형 응용! 투자 시작을 결심하셨다고요? 당장 시작!!(166, 197), 돈 모으기 영상(64) 166. [왕초보] 주식 미신 9개 타파! 197. [초보] 강환국의 4대 투자 흑역사 공개! 64. [왕초보] 재테크의 기본 중 기본 - 종잣돈 모으기 목돈 있어? 남에게 맡기면 안되! (71, 72, 130, 137,157, 202, 354, 389) . 펀드매니저, 버핏, 신? 다 필요 없습니다! 당신이 해야되요!! 71. [초보] 투자, 남에게 맡기면 큰일나!! 72. [왕초보] 투자 사기의 공통점 130. [초보] 초중급자에게 위험한 버핏의 가르침 (上) 157. [초보] 초중급자에게 위험한 버핏의 가르침 (下) 202. [왕초보] DLS, DLF 등 원금보장형 파생상품의 진실! 354.(왕초보 1억) 당신 연금펀드가 쓰레기일 가능성 - 95%! 389. (왕초보 1억) 주식펀드 - 절대 하지 마세요! . 애널리스트/경제학자도 믿으면 절대 안되죠 (207, 288, 341) 207. 애널리스트 추천은 쓸모가 있나? 288. [초보] 애널리스트 리포트 활용은 이렇게! 341.(초보)IMF 2020년 경제전망 보고서, 개구라네요! . 사기 당하면 안됩니다!! (72, 240, 241) 72. [왕초보] 투자 사기의 공통점 240. [왕초보] 최신 투자사기 사례 (1) - 강환국, 주식사기꾼과 대화하다! 241. 정의의 사도 강환국, 가짜뉴스 저격! ","date":"2020-12-17","objectID":"/2020-12-17_halto-400/:3:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '400. (채널가이드) 돈 버는 모든 비법, 400개 영상에 담다!' 정리","uri":"/2020-12-17_halto-400/#3-초보-투자---좀-더-구체적으로"},{"categories":["투자 일반"],"content":" 4. 초보 투자 - 그래서 어떻게 하란 말여? 당장 영구포트폴리오 또는 올웨더로 시작! (강환국은 어떻게? 338) 338. 나라면 이런거 사겠다 - 2020 4월 버전! . 영구포트폴리오: 348(메인), 119, 337, 399, (LAA)344 348. (왕초보 1억) - 초보자 투자는 이렇게 - 영구 포트폴리오의 모든 것! 119. [초보] 초보가 알아야 하는 자산배분의 모든 것 337.폭락장 대처법 - 코로나도 피해가는 자산배분 전략 4개! 399. (왕초보 1억) 상위 10%에서 상위 1% 투자자 가즈아! (Feat. 레이 달리오) 344. 매우 게으른 자산배분 전략으로 복리 10% 달성! . 올웨더(4계절 포트폴리오) 메인 영상: 353, 37, 38 353. (왕초보 1억) 4계절 포트폴리오(올웨더) 초간단 설명! 37. [초보] 투자자 99%에 맞는 필승 투자법 - 4계절 포트폴리오 38. [초보] 투자자 99%에 맞는 필승 투자법 - 4계절 포트폴리오의 한국화 . 사이드: 232, 283(김단테 실전투자) 296, 335, 337, 371, 375, 376, 394, 399 232. [초보] 4계절 포트폴리오, 경제공황과 금리인상에도 먹히나? 283. 4계절 포트폴리오에 10억을 투자한 사나이, 수익공개! 296. (초보) 자산배분에 어떤 자산군을? 335.레이 달리오의 4계절 포트폴리오 vs. 코로나바이러스! 371. 100년 동안 최대손실 11% 자산배분이 있습니다! 375. (왕초보 1억) 4계절 포트폴리오(올웨더) QnA 시간! 376. (왕초보 1억) 올웨더로만 책을 쓰다! - ‘절대수익 투자법칙’ 발간! 394. (왕초보 1억) 부모님을 위한 투자상품 추천! (이루다, RPAR) 399. (왕초보 1억) 상위 10%에서 상위 1% 투자자 가즈아! (Feat. 레이 달리오) 일단 질러 놓은 후 - 공부를 해야겠죠! - 훌륭한 초보용 책/유튜브는 . 책: 302, 363, 367 302. [왕초보] 주식 입문자 가이드! 363. (왕초보 1억) 재테크, 투자 입문서 10권 소개! 367. 강환국 인생 최고 주식책 7권! . 유튜브: 186, 211, 213(이건 영어), 227, 302 186. [초보] 진짜 돈이 벌리는 유튜브 채널 소개! 211. (초보) 유익한 유튜브 주식채널들 10개 소개! 213. (초보) 역대급 주식 전설들의 유튜브 채널들 10개 소개! 227. [초보] 유익한 유튜브 주식채널 10개 추가요! 302. [왕초보] 주식 입문자 가이드! . 공부 안하는 자들의 비참한 말로: 379, 380 379. (전국민 필수영상) 전업투자! 이렇게는 하지 맙시다(1) 380. (전국민 필수영상) 전업투자! 이렇게는 하지 맙시다(II) 초보 멘터링? 229, 230, 249, 252, 261, 262 229. [초보] 원숭이 계몽 프로젝트! - 자산배분 230. 배주의 씨의 투자전략 소개! 249. (초보) 그녀가 돌아왔다! 새로운 동적자산배분 탄생 - 리스크패리티+ 11~4월전략! 252. (초보) 투자 때문에 피눈물을 흘린 사람이 있다!? 261. 동적자산배분의 끝판왕? 262 . (초보) 시장의 마법사 끝장토론! ","date":"2020-12-17","objectID":"/2020-12-17_halto-400/:4:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '400. (채널가이드) 돈 버는 모든 비법, 400개 영상에 담다!' 정리","uri":"/2020-12-17_halto-400/#4-초보-투자---그래서-어떻게-하란-말여"},{"categories":["투자 일반"],"content":" 5. 초보 영상 - 그런데 중고급자들도 꼭 알아야 하는 정보! 매번 깨진다고요? 단신 두뇌는 망하는 것에 최적화! (투자 심리) . 투자 편향 40여개 총집합! (285, 290, 292, 299) 285. [초보] 투자를 망치는 40여개의 편향, 총정리 (1) 290. [초보] 투자를 망치는 40여개 편향 총정리 (2) 292. [초보] 투자를 망치는 40여개 편향, 총정리 (3) 299. [초보] 투자를 망치는 40여개 편향, 총정리 (4) . 왜 대부분 투자자는 망할 수 밖에 없는지! (30, 31, 58, 162, 190, 191) 30. [초보] 왜 당신이 주식을 하면 맨날 깨지는지 (1) - 손실회피 \u0026 처분효과 편향 31. [초보] 왜 당신이 주식을 하면 맨날 깨지는지 (2) - 과잉확신 편향 편 58. [초보] 정석적인 투자, 왜 이리 어려울까? 162. 투자가 심리적으로 어려운 이유 - 절대모멘텀 사례 190. 구독자 10,000명 기념! 투자 10계명 대공개! 191. 내가 100만불 잃으면서 배운 것! (上) . 우리 두뇌/심리를 극복하는 방법! (63, 74, 76, 132, 190, 192, 263) 63. [초보] 주식시장에서 무조건 이기는 방법 74. [초보] 성공투자? 3가지만 잘하면 된다! 76. [초보] 성공투자? 한 개만 버리면 된다! 132. [초보] 성공투자 - 과학이 아닌 종교의 영역 190. 구독자 10,000명 기념! 투자 10계명 대공개! 192. 내가 100만불 잃으면서 배운 것! (下) 263. [왕초보] 투자는 왜 드럽게 어려운가? . 심리 + 백테스트 = 성공투자! (46) 46. [초보] 주식투자 10계명 . 버블이란 무엇? (215) 215. (초보) 지금이 버블인지 아닌지 어떻게 파악하나? . 백테스트 하는 방법 (47, 51, 75, 92, 128, 131번 등) 47. [초보] 백테스트 매뉴얼 (1) - 자산배분 51. [초보] 백테스트 매뉴얼 (2) - 마켓타이밍 편 75. 개별주식 전략 백테스트 정복 92. [초보] 투자전략 백테스트, 환상과 현실 128. [초보] 백테스트와 리밸런싱, 이렇게 하는 겁니다! 131. [중요] 직접 백테스트를 해야 합니다!! ","date":"2020-12-17","objectID":"/2020-12-17_halto-400/:5:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '400. (채널가이드) 돈 버는 모든 비법, 400개 영상에 담다!' 정리","uri":"/2020-12-17_halto-400/#5-초보-영상---그런데-중고급자들도-꼭-알아야-하는-정보"},{"categories":["투자 일반"],"content":" 6. 초보 딱지를 벗으려면 - 이런 것도 알아야 합니다! 이 정도는 투자의 상식이라고 볼 수 있죠! . 왜 초보자에게 계량투자를 강추하는 것인가? (13, 44) 13. [초보] 왜 계량투자인가? OR 단순공식이 전문가에게 이기는 원인 44. [초보] 워렌 버핏이 어쩔 수 없이 가치투자자가 된 이유 + 버핏의 한국 투자기행 . 분산투자, 자산배분에 대한 이해: 33, 91, 111, 143, 147, 296, 387, 393 33. [초보] 마코비츠, 12페이지 논문으로 노벨상 받다 91. [초보] 주식투자 전략만 연구하면 안 되는 이유! 111. [초보] 주식 vs 예금, 수익이 더 높은 투자는? 143. 개별주 포트폴리오에 종목 몇 개? 147. [왕초보] 주식은 무엇이고, 채권은 무엇이냐? - 자금조달의 3,000년 역사 296. (초보) 자산배분에 어떤 자산군을? 387. 장기투자 수익률 어느 자산이 더 높나 - 주식 vs.채권 393. (왕초보 1억) 이것만 안 하면 상위 10% 투자자! . 요즘 한국(중국)보다 미국 시장이 더 낫다는데? 134, 209, 221, 226, 228 134. [초보] 미국 주식은 좋고, 한국 주식은 구린가? 209. (초보) 레이 달리오 - 미국이냐, 중국이냐? 그게 문제로다! 221. 국제 장기투자는 선진국인가? 개발도상국인가? 226. [초보] Meb Faber - 미국 주식 터무니없이 비싸다! 228. [초보] 그래도 미국 주식이 한국 주식보다 낫다? . 그래도 죽어도 개별주/잡주에 투자하고 싶다면: 216, 235 216. [초보] 개별주 투자 필승법 (Feat. Peter Lynch and the Turtles) 235. [왕초보] 당신이 잡주를 사고도 살아남는 방법! . 연금? DB? DC? 그런거 뭐여? 108, 109, 174 108. 책 ‘마법의 연금 굴리기’ 독후감 109. 마법의 연금 굴리기, 김성일 작가님 질문답변 174. [왕초보] 직장인 필수정보 - 퇴직금? DB, DC가 뭐죠? . 버블은 어떻게 알아채? 215, 투자와 투기의 차이는 머여? 231 215. (초보) 지금이 버블인지 아닌지 어떻게 파악하나? 231. [초보] 투자, 투기, 도박의 차이는 무엇? . 나는 회계 아무것도 모르는데! 29 29. [초보] 회계의 기초 . 리밸런싱은 뭐야? 381 381. 포트폴리오 리밸런싱은 어느 날에 할까요? ","date":"2020-12-17","objectID":"/2020-12-17_halto-400/:6:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '400. (채널가이드) 돈 버는 모든 비법, 400개 영상에 담다!' 정리","uri":"/2020-12-17_halto-400/#6-초보-딱지를-벗으려면---이런-것도-알아야-합니다"},{"categories":["투자 일반"],"content":" 7. 초보 영상을 3번 정도 정독하면 슬슬 중고급 전략에 도전할 수 있다! 일단 중고급 투자 전략 본격적 스터디 전 두 영상 먼저 봐야죠! 330, 340 330. (초보필독) 할투 채널 주의사항 안내! 340.주식의 정석 - 30년 데이터로 입증! 아님 이 영상 다시 한번 복습!? 218 218. (초보) 투자의 기초, 한시간 만에 완료!! ","date":"2020-12-17","objectID":"/2020-12-17_halto-400/:7:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '400. (채널가이드) 돈 버는 모든 비법, 400개 영상에 담다!' 정리","uri":"/2020-12-17_halto-400/#7-초보-영상을-3번-정도-정독하면-슬슬-중고급-전략에-도전할-수-있다"},{"categories":["투자 일반"],"content":" 8. 모멘텀 전략 - 가격 데이터만 사용하는 가장 퓨어하고 간단한 전략! 상대모멘텀: 8, 9, 14, 39, 99, 184, 270 8. 모멘텀의 오묘한 세계 (1) - 상대모멘텀 9. 모멘텀의 오묘한 세계 (2) - 1990~2018년 라이브 백테스트 14. 모멘텀의 오묘한 세계 (3) - JT, 20년만에 화려하게 컴백하다 39. 217년 데이터 분석, 시장에서 이기는 방법은 영원하리! 99. 모멘텀의 오묘한 세계 (13) - 최근 한 달이 중요! 184. 비밀논문 - 한국에서 2000년에 무슨 일이 있었나? 270. [초보] 미국 ETF로 돈 버는 초간단 방법 소개! . 전략 모멘텀: 49 49. 모멘텀의 오묘한 세계 (9) - 투자 전략에도 모멘텀이 통한다! 절대모멘텀: 17, 18, 43, 99, 162, 217, 397 17. 모멘텀의 오묘한 세계 (4) - 절대모멘텀 18. 모멘텀의 오묘한 세계 (5) - 절대모멘텀 라이브 백테스트 43. 상승장과 하락장을 구분하는 비법!! - 평균 모멘텀 스코어 99. 모멘텀의 오묘한 세계 (13) - 최근 한 달이 중요! 162. 투자가 심리적으로 어려운 이유 - 절대모멘텀 사례 217. 토끼 전략 (1) - 50년간 복리 14%, MDD 16% 397. 최고의 방어벽 절대모멘텀, 또 한번 업그레이드! . 52주 신고가/최고가: 183, 217, 266 183. 52주 최고가에 근접한 주식을 사라고? 217. 토끼 전략 (1) - 50년간 복리 14%, MDD 16% 266. [왕초보] 복리 11%, 최대손실 11% 초간단 전략! 듀얼모멘텀: 21, 22, 23, 39, 96, 210, 287 21. 모멘텀의 오묘한 세계 (6) - GTAA (자산배분 + 절대모멘텀) 22. 모멘텀의 오묘한 세계 (7) - 듀얼모멘텀 23. 모멘텀의 오묘한 세계 (8) - 듀얼모멘텀 백테스트 39. 217년 데이터 분석, 시장에서 이기는 방법은 영원하리! 96. 회사채 수익을 높이는 방법은? 210. 미·중 듀얼모멘텀으로 복리 15% (백테스트 포함) 287. 2만명 기념 복리 20% 전략 투척! 듀얼모멘텀 업그레이드: 97, 125, 126, 136, 142, 148, 293, 374, 377 . FAA, AAA, PAA, MPAA, VAA, DAA 등 97. 최근 20년간 복리 20% 벌고 최대손실 20% 나온 전략 대공개! 125. 듀얼모멘텀 전략의 업그레이드 (1-1) 126. 듀얼모멘텀 전략의 업그레이드 (1-2) - FAA 전략 활용법 136. 듀얼모멘텀 전략의 업그레이드 (2) - PAA 전략 142. 듀얼모멘텀 전략의 업그레이드 (3) - MPAA 전략 148. 듀얼모멘텀 전략의 업그레이드 (4) - 종합 듀얼모멘텀 293.(고급) 복리 15% 전략, 15분만에 완전 정복! 374. 최강전략 VAA - 50년만에 원금 3,800배! 377. DAA 전략, 복리 22%, MDD 13%가 실화인가! 변동성 돌파전략: 53, 60, 61, 131 53. 역대 최강의 트레이더의 가장 위대한 전략 - 변동성 돌파전략 60. 암호화폐 - 사기인가 미래의 금인가 61. 암호화폐에 부동산보다 더 안전하게 투자한다고!? 131. [중요] 직접 백테스트를 해야 합니다!! 단기 역추세: 68, 169, 208, 233, 319, 320 68. 최근 1주일 폭망한 주식을 사보자 169. 최근 상한가 친 주식 사면 폭망! 208. IBS - 전세계에서 매년 돈을 버는 단타전략이 있다고? 233. 터틀 vs 터틀스프 - 정반대 전략으로 돈을 번다고? 319. 코로나19 감염자, 500만명이 넘었나! 320. 코로나 대하락장에도 수익을 내는 단기전략 (1) 장기 역추세: 85 85. 모멘텀의 오묘한 세계 (10) - 중기 윈너, 장기 루저 주식, 시너지 대박 대하락 후 역추세: 90 90. 모멘텀의 오묘한 세계 (11) - 대하락장 직후는 안 먹혀! 모멘텀 콤보전략: 85, 95 . 중기윈너 + 장기루저(85), 트윈모멘텀(95) 85. 모멘텀의 오묘한 세계 (10) - 중기 윈너, 장기 루저 주식, 시너지 대박 95. 모멘텀의 오묘한 세계 (12) - 트윈모멘텀 모멘텀 전략이 통하는 이유: 204 204. [초보] 그것이 알고싶다 - 최근 오른 자산이 왜 계속 오르는가? ","date":"2020-12-17","objectID":"/2020-12-17_halto-400/:8:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '400. (채널가이드) 돈 버는 모든 비법, 400개 영상에 담다!' 정리","uri":"/2020-12-17_halto-400/#8-모멘텀-전략---가격-데이터만-사용하는-가장-퓨어하고-간단한-전략"},{"categories":["투자 일반"],"content":" 9. 가치주 전략 - 저평가된 주식 찾기! 대하락 후 싹쓸이 전략: 323, 324, 326, 327, 329, 331, 332, 333, 334 323. 3만명 기념 - 폭락장 후 싹쓸이 전략! 324. 대폭락 후 싹쓸이 전략 업그레이드 (1) Delay 326. 대폭락 후 싹쓸이 전략 업그레이드 (2) - MDD Delay 327. 대폭락 후 싹쓸이 전략 업그레이드(3) - 코스닥 329. 대폭락 후 싹쓸이 전략 업그레이드(4) - 미국시장편 331. 폭락장 후 싹쓸이 전략 업그레이드(5) - 중국, 일본, 원유시장 332. 폭락장 후 싹쓸이 전략 업그레이드(6) - 2008년 개별주 333. 폭락장 후 싹쓸이 전략 업그레이드! (7) - 2000, 03년 개별주 334.할투 최고 영상 - 폭락장 후 한국 대형주 싹쓸이! 우량주 + 가치주 전략들: 2, 3, 4, 7, 52, 79, 156, 223, 370 . 버핏, 타이거 우량가치, 그린블라트 마법공식, 서준식 등 2. 버핏의 계량화 (1) 3. 버핏의 계량화 (2) - 우량주란 무엇인가 4. 버핏의 계량화 (3) - 소형주/저 PBR 효과 또는 계량투자계에서 가장 중요한 논문! 7. 실전타임 : 한국시장에서 버핏류 주식을 찾아보자 52. 한국 최고 스마트베타 ETF, ‘타이거 우량가치’ 업그레이드 79. [초보] 그린블라트의 마법공식, 실화냐 신화냐? 156. 서준식의 버핏형 채권형 주식 발굴법 223. [초보] 워렌 버핏의 연 50% 수익 비법 공개 370. 세계 최강 퀀트투자 오타쿠가 만든 복리 20% 전략! 우량주 + 가치주 + 모멘텀 전략들: 10, 11, 116, 118, 187 . AQR, Robeco 등 10. 저평가 우량주 모멘텀 주식에 투자한다면? 11. 저평가 우량주 모멘텀주 발굴 실습! 116. 매우 심플한 복리 15% 대형주 전략 118. 매우 심플한 복리 15% 대형주 전략 종목 찾기 187. [초보] 복리 15% 이상 버는 한국 밸류 모멘텀 초간단 전략 종목 뽑기 배당주 전략: 237 237. [초보] 고배당주로 복리 15-20% 달성 가능하단다! PBR: 4, 5, 362 4. 버핏의 계량화 (3) - 소형주/저 PBR 효과 또는 계량투자계에서 가장 중요한 논문! 5. 라이브 백테스트! 소형주/저 PBR 투자전략 아직도 먹히나? 362. (고급) 복리 20% 저 PER 저 PBR 전략이 죽었나! (Feat. Cliff Asness from AQR) NCAV: 20, 54, (EV) 388 20. 나라면 이런 거 사겠다 (1) - NCAV 54. 나라면 이런 거 사겠다 (5) - NCAV 전략 388. 당신을 깜짝 놀라게 할 연 50% 전략 - Negative EV ","date":"2020-12-17","objectID":"/2020-12-17_halto-400/:9:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '400. (채널가이드) 돈 버는 모든 비법, 400개 영상에 담다!' 정리","uri":"/2020-12-17_halto-400/#9-가치주-전략---저평가된-주식-찾기"},{"categories":["투자 일반"],"content":" 10. 우량주 투자는 이렇게 하는거다! 버핏: 2, 3 2. 버핏의 계량화 (1) 3. 버핏의 계량화 (2) - 우량주란 무엇인가 피오트로스트 F-Score: 24, 25 24. 우량주란 무엇인가 (2) - F Score 25. 우량주란 무엇인가 (3) - F Score, 미국 외 시장에서도 먹히는가 노비 마르크스 GP/A: 27 27. 우량주란 무엇인가 (4) - GP/A 우량주 전략 배틀: 28, 73, 146 28. 우량주란 무엇인가 (5) - 7개 우량주 전략 배틀 73. 매출, 영업이익, 배당의 주식투자 활용법 146. 우량주란 무엇인가? 자산성장률: 259 259. 자산성장과 주식수익률을 파헤쳐보자! (1) ","date":"2020-12-17","objectID":"/2020-12-17_halto-400/:10:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '400. (채널가이드) 돈 버는 모든 비법, 400개 영상에 담다!' 정리","uri":"/2020-12-17_halto-400/#10-우량주-투자는-이렇게-하는거다"},{"categories":["투자 일반"],"content":" 11. 시즈널리티, 기타 전략들 주식이 유난히 잘되는 시기가 있다! (시즈널리티) . 11-4월 투자 전략(40, 110, 117, 122, 163, 179, 193, 269) 잘 먹힘! 40. 전세계에서 통하는 만능 전략 - 11월 초 매수, 4월 말 매도 110. [초보] 주식 투자는 역시 11월~4월이 적정기! 117. 11월~4월에 투자해서 복리 20% 이상! 122. [초보] 5월~10월, 주식을 안하면 어디에 투자해? 163. 자산배분에 11월~4월 전략을 섞으면? 179. 진정한 강철멘탈만 버틸 수 있는 복리 15% 전략! 193. [초보] 주가 폭락, 11월에 다시 들어가 말아? 269. 주식, 11월-4월보다 더 좋은 타이밍이 있다고? (2) . 오버나잇, 월말월초, 1월, 기타(48, 55, 56, 104, 113, 115, 275, 277, 365, 378, 382) 48. 세상에서 가장 시니컬한 전략! 종가 매수, 시가 매도 (라이브 백테스트) 55. 한달에 나흘만 투자하면 된다고?? 56. 정말 한달에 4일만 투자하면 되는가?? 104. 당장 다음 달 급등할 주식을 찾는 기적의 한수! 113. 개잡주에 투자해서 돈 좀 법시다 115. 소형주 + 1월 = 고수익? 275. (초보) 2020-2100년 투자 대예언! 277. [초보] 1월 효과를 노려 봅시다! 365. 단타비법 천기누설!(낚시 아님) 378. 미국 선물투자 필승법! 382. 믿기지 않는 월말월초 전략! 한달 수익을 10일만에 벌다! 기타(주식) 전략 . 변동성 투자전략(42, 89): 전 세계에서 먹힘 42. 리스크가 낮은 주식이 수익이 더 높다!? 89. 해외투자, 이 3가지만 알고 시작하자! . 내부자 거래(70, 258): 내부자들 수익이 당신보다 높습니다! 70. 내부자 거래의 비밀 (Feat. 피터 린치) 258. (감동) 퀀트+ 내부자 = 거래 돈을 부르는 공식! . 슈퍼 투자자 따라하기: 305 305. [초보] 거인의 힘을 빌리는 미국주식 전략! . 대하락장 방어법! (180) 180. 대하락장에서 나 혼자 버는 방법, 대공개! ","date":"2020-12-17","objectID":"/2020-12-17_halto-400/:11:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '400. (채널가이드) 돈 버는 모든 비법, 400개 영상에 담다!' 정리","uri":"/2020-12-17_halto-400/#11-시즈널리티-기타-전략들"},{"categories":["투자 일반"],"content":" 12. 경제와 주식도 밀접한 관계가 있죠! 레이 달리오, 켄 피셔 등 구루 분석: 103, 172, 175, 176, 178, 189, 198, 201, 212(문재인), 301, 322, 352 103. [초보] 경제성장이 높은 국가에 투자하면 폭망한다!! 172. [초보] 연준이 금리를 내리면 주식시장은? 175. 레이 달리오, 2020~2029년 투자 대예언! (上) 176. 레이 달리오, 2020~2029년 투자 대예언! (下) 178. 한국시장 일드커브 전략 189. [초보] 초간단 매크로 전략으로 부자 되자! (上) 198. [초보] 초간단 매크로 전략! (下) - 한국에서 통하는가? 201. OECD 선행지수로 한국에서 초과수익! 212. (초보) 대한민국 최강 마켓타이머들은 - 청와대에 계신다! 301. 금융위기 예측은 가능하다! (Feat. 레이 달리오) 322. [초보] 레이 달리오의 경제이론, 현실세계에 응용! 352. 레이 달리오 - 통화 붕괴, 혁명, 전쟁의 시대가 온다고? 경제지표와 주식 수익의 상관관계! 314, 346, 349, 357, 358, 359, 361 314. [초보] 경제와 주식시장, 너희들의 관계는? (1) 346.금리 타이밍으로 코스피 +7% 달성! 349. (경제와 주식) 유가와 물가지표는 투자에 도움이 되나? 357. (왕초보) 경제는 위기인데 주식은 왜 올라? 358. (왕초보 1억) 환율이 오르면 주식이 오르나? 359. (왕초보 1억) 수출이 증가하면 주식도 오르겠지! 361. 경제지표 마켓타이밍으로 복리 10% 이상 벌기! 투자 전망 보실래요? 273, 275, 280 273. 이 세상 모든 자산의 2020-24년 기대수익 공개! 275. (초보) 2020-2100년 투자 대예언! 280. [왕초보] 2020년 주식시장 강환국 대예언! 전쟁나면 주식은? 284, 286 284. 전쟁, 주식시장에 어떤 영향을? 286. 전쟁이 나면 빛을 보는 2개 자산 소개! ","date":"2020-12-17","objectID":"/2020-12-17_halto-400/:12:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '400. (채널가이드) 돈 버는 모든 비법, 400개 영상에 담다!' 정리","uri":"/2020-12-17_halto-400/#12-경제와-주식도-밀접한-관계가-있죠"},{"categories":["투자 일반"],"content":" 13. 주식쟁이, 다른 자산군도 알아야 합니다. 세계 최초! 부동산 계량투자! . 상대 모멘텀(81, 82): 최근 3개월 오른 부동산 굿, 전세율(84) 갭투자는? 81. 부동산도 퀀트투자로 (1-1) - 상대모멘텀 82. 부동산도 퀀트투자로 (1-2) - 전세 낀 상대모멘텀 84. 부동산도 퀀트투자로 (2) - 갭투자 . 강환국 부동산 마법공식 1.0(88), 주식이냐 부동산이냐? (151, 152) 88. 벌 수 있다! 아파트로 복리 30%!! 151. [초보] 부동산 vs 주식, 어떤게 나은가? 152. 부동산 수익이 주식 수익보다 높다는 것은 있을 수 없다고? . 서울이냐 지방이냐 (336) 336.(충격) 한국 아파트의 진실 - 서울 vs. 지방아파트 배틀의 승자는! 암호화폐 - 변동성 돌파전략, 백테스트 등 이모저모: 60, 61, 127, 131, 161, 165, 342 60. 암호화폐 - 사기인가 미래의 금인가 61. 암호화폐에 부동산보다 더 안전하게 투자한다고!? 127. 김동주 퀀트팀장, 헤이비트의 투자전략 공개! 131. [중요] 직접 백테스트를 해야 합니다!! 161. 암호화폐에 펀더멘털 투자가 가능하다고? 165. 주식전략 20개, 암호화폐 시장에서 돌려보다! 342. 강환국 가상화폐 전략, 18~19년 하락장에 먹혔나! 채권: 97, 159, 214, 222, 245 97. 최근 20년간 복리 20% 벌고 최대손실 20% 나온 전략 대공개! 159. [초보] 주식쟁이 강환국의 채권 탐험 214. 금리가 이렇게 낮은데 채권에 투자해도 되나? 222. [초보] 미국 채권, 궁금한 거 다 알려줄게! 245. [초보] 35조 달러 규모 글로벌 채권 버블이 터지면? 금: 383, 395 383. 금과 은을 살 타이밍이 왔나? 395. 레이 달리오, 워렌버핏이 금을 사는 이유? 취미자산(레고, 위스키) 243, 248 243. [초보] 레고 수익이 주식보다 높다고?? 248. [초보] 최근 11년간 복리 22%의 수익을 낸 자산군이 있다고? ","date":"2020-12-17","objectID":"/2020-12-17_halto-400/:13:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '400. (채널가이드) 돈 버는 모든 비법, 400개 영상에 담다!' 정리","uri":"/2020-12-17_halto-400/#13-주식쟁이-다른-자산군도-알아야-합니다"},{"categories":["투자 일반"],"content":" 14. 백테스트는 퀀트투자의 핵심! (I) 뉴지스탁 소개(75) - 21세기의 첨단 종목 백테스트! 75. 개별주식 전략 백테스트 정복 모멘텀 . 상대모멘텀(9), 절대모멘텀(18), 듀얼모멘텀(96) 9. 모멘텀의 오묘한 세계 (2) - 1990~2018년 라이브 백테스트 18. 모멘텀의 오묘한 세계 (5) - 절대모멘텀 라이브 백테스트 96. 회사채 수익을 높이는 방법은? . 평균모멘텀스코어(43) 43. 상승장과 하락장을 구분하는 비법!! - 평균 모멘텀 스코어 . 가속듀얼모멘텀(97, 287) 97. 최근 20년간 복리 20% 벌고 최대손실 20% 나온 전략 대공개! 287. 2만명 기념 복리 20% 전략 투척! . 마켓타이밍(50) 50. [초보] 주식투자에서 표준편차는 무엇? . 변동성 돌파(53) 53. 역대 최강의 트레이더의 가장 위대한 전략 - 변동성 돌파전략 . 가치 + 우량주(206) 206. [서평] 퀀트로 가치투자하라 자산배분 (47) 47. [초보] 백테스트 매뉴얼 (1) - 자산배분 ","date":"2020-12-17","objectID":"/2020-12-17_halto-400/:14:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '400. (채널가이드) 돈 버는 모든 비법, 400개 영상에 담다!' 정리","uri":"/2020-12-17_halto-400/#14-백테스트는-퀀트투자의-핵심-i"},{"categories":["투자 일반"],"content":" 15. 백테스트는 퀀트투자의 핵심! (II) 저평가 우량주 . 소형주 저 PBR(5) 5. 라이브 백테스트! 소형주/저 PBR 투자전략 아직도 먹히나? . 버핏류 주식(7, 356) 7. 실전타임 : 한국시장에서 버핏류 주식을 찾아보자 356. 워렌 버핏이 한국에 오면 살 주식 . 저평가 우량주(111) 111. [초보] 주식 vs 예금, 수익이 더 높은 투자는? . 강환국 슈퍼가치전략(83) 83. 강환국 슈퍼가치전략 백테스트! . NCAV(92) 92. [초보] 투자전략 백테스트, 환상과 현실 시즈널리티: 11-4월(40, 110), 오버나잇(48), 월말월초(56) 40. 전세계에서 통하는 만능 전략 - 11월 초 매수, 4월 말 매도 110. [초보] 주식 투자는 역시 11월~4월이 적정기! 48. 세상에서 가장 시니컬한 전략! 종가 매수, 시가 매도 (라이브 백테스트) 56. 정말 한달에 4일만 투자하면 되는가?? 암호화폐: 60, 61, 131, 342 60. 암호화폐 - 사기인가 미래의 금인가 61. 암호화폐에 부동산보다 더 안전하게 투자한다고!? 131. [중요] 직접 백테스트를 해야 합니다!! 342. 강환국 가상화폐 전략, 18~19년 하락장에 먹혔나! ","date":"2020-12-17","objectID":"/2020-12-17_halto-400/:15:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '400. (채널가이드) 돈 버는 모든 비법, 400개 영상에 담다!' 정리","uri":"/2020-12-17_halto-400/#15-백테스트는-퀀트투자의-핵심-ii"},{"categories":["투자 일반"],"content":" 16. 별 희한한 걸 다 했네요! (I) 나라면 이런거 사겠다: 20, 26, 32, 45, 54, 77, 239, 242, 246, 247, 254, 255, 338 . 현재 버전 338, 11월에 컴백할 예정! 20. 나라면 이런 거 사겠다 (1) - NCAV 26. 나라면 이런 거 사겠다 (2) - 대형주 짬뽕전략 32. 나라면 이런 거 사겠다 (3) - 행복전략 45. 나라면 이런거 사겠다 (4) - 강환국 슈퍼가치전략 54. 나라면 이런 거 사겠다 (5) - NCAV 전략 77. 나라면 이런거 사겠다 (6) - 대형주 짬뽕전략 239. 나라면 이런거 사겠다 (7) - 전략 편 242. 나라면 이런거 사겠다 (8) - NCAV 전략 246. 나라면 이런거 사겠다 (9) - 버핏형 주식 247. 나라면 이런거 사겠다 (10) - 대형주 짬뽕전략 254. 나라면 이런거 사겠다 (11) - 행복전략 255. 나라면 이런거 사겠다 (12) - 심플한 대형주 전략 338. 나라면 이런거 사겠다 - 2020 4월 버전! 구독자 사례: 105, 112, 114, 120, 308 105. 구독자 사례 (1) - 은퇴 후 투자는 어떻게? 112. 구독자님들의 할투 활용 후기! 114. 구독자사례 (2) - 30대 초반, 자산 2억대 후반, 어떻게 투자? 120. 구독자사례 (3) - 언제 자산배분의 정석을 깰 수 있나? 308. [왕초보] 맞벌이 신혼부부, 10년 후 은퇴가능? 투자서적 독후감 . 이거 다 읽으면 진정한 윈너! . 108, 109, 123, 144, 149, 150, 158, 167, 177, 191, 192, 194, 195, 196, 205, 236(내책), 253, 256, 257, 265 108. 책 ‘마법의 연금 굴리기’ 독후감 109. 마법의 연금 굴리기, 김성일 작가님 질문답변 123. 코인이 오른다! 책 ‘가상화폐 투자 마법공식’ 셀프 독후감 144. [초보] 세계 최고의 주식 책 149. [서평] 버핏클럽2 - 버핏의 친구들 150. [서평] 버핏클럽2 - 가치투자, 이렇게 배우자 158. [서평] 나는 카지노에서 투자를 배웠다 167. [서평] 주식시장은 어떻게 반복되는가 (上) 177. 우파정권? 좌파정권? 투자자에게는 뭐가 좋은거지? 191. 내가 100만불 잃으면서 배운 것! (上) 192. 내가 100만불 잃으면서 배운 것! (下) 194. [초보] 역대 최고 자기계발서 - 투자에 관련 있는 3가지! 195. [초보] 워렌 버핏 투자비법 초보 매뉴얼! 196. 존버, 그는 누구인가? 205. ‘퀀트로 가치투자하라’ - 한국형 복리 20% 주식 찾기! 236. 할 수 있다 퀀트투자 탄생기! 253. [국내최초] 복리 66%! 제임스 사이먼스의 투자 전략 공개! 256. (초보) 투자의 신, 복리 30% 피터 린치의 비법 (1) 257. (초보) 투자의 신 피터 린치의 비법 (2) 265. 투자의 신 피터 린치의 비법 (3) . 시장의 마법사: 129, 133, 135, 139, 145, 153, 164 129. 인생 \u0026 투자 성공 전략 - 시장의 마법사들에게 배우다 (1) 133. 인생 \u0026 투자 성공 전략 - 시장의 마법사들에게 배우다 (2-1) 135. 인생 \u0026 투자 성공 전략 - 시장의 마법사들에게 배우다 (2-2) 139. 인생 \u0026 투자 성공 전략 - 시장의 마법사들에게 배우다 (3) - “니 자신을 알라” 145. 제프 베조스, 투자가 빡세서 창업을 하다 - (시장의 마법사들에게 배우다 시리즈 4, 5) 153. 시장의 마법사들에게 배우다 (6,7) - 매일매일 깨지면 어떻게 하는가? 164. 시장의 마법사들에게 배운다 (8) - 하이라이트! 리스크 관리 재미있는 사이트/채널들: 168, 171, 264 168. 금융 학습 최강 사이트 발견! 171. [초보] 미국 대박종목 찾기 264. 금융 논문, 어떻게 찾나요? ","date":"2020-12-17","objectID":"/2020-12-17_halto-400/:16:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '400. (채널가이드) 돈 버는 모든 비법, 400개 영상에 담다!' 정리","uri":"/2020-12-17_halto-400/#16-별-희한한-걸-다-했네요-i"},{"categories":["투자 일반"],"content":" 17. 별 희한한 걸 다 했네요 (II) 역사/위인 이야기 . 일본 최초 퀀트(203), 아프리카의 워렌 버핏(219) 203. 일본 최초 퀀트투자자, 1000억 원 번 스토리! 219. [초보] 아프리카의 워렌 버핏, 종목 한 개로 169조원 벌다! . 무서운 어니들(220, 238, 306) - 린다 라쉬케 등 220. [초보] 역대 최강 여성 투자자 3인방 소개 238. 여성 최강 트레이더 린다 라쉬케 - 1시간짜리 인터뷰에 이렇게 많은 지혜가! 306. 역대 최강 여성 트레이더, 미국시장 거래 비법 공개! . 포커로 빠진 주식쟁이(224), 트럼프(225), 케인스(234) 224. [초보] 주식투자자가 역대 최고 400억원 포커판에서 배우는 교훈 225. 트럼프 트윗을 보는 지표 + 더 이상한 지표들 집합! 234. (초보) 케인스 - 역대 최고 경제학자의 투자실력은? . 역대 최강은 누구?(251), 짐 사이먼스(253), 피터 린치(256, 257, 265) 251 . (초보) 역대 최강의 투자자는 누구인가? (feat. 버핏, 소로스, 그로스, 린치) 253. [국내최초] 복리 66%! 제임스 사이먼스의 투자 전략 공개! 256. (초보) 투자의 신, 복리 30% 피터 린치의 비법 (1) 257. (초보) 투자의 신 피터 린치의 비법 (2) 265. 투자의 신 피터 린치의 비법 (3) . 헤지펀드 최강자(272, 276, 279, 294) 272. 헤지펀드의 역사 (1) - 헤지펀드의 아버지 존스 276. 헤지펀드의 역사 (2) - 역발상 사이코 슈타인하트 279. 헤지펀드의 역사 (3) - 연금술사 소로스 294. 헤지펀드의 역사 (4) - 영국을 굴복시킨 사나이들 . 강환국 흑역사(197, 318) 197. [초보] 강환국의 4대 투자 흑역사 공개! 318. (투자심리) 강환국 폭망에서 무엇을 배울 수 있는가? . 워렌 버핏: 355, 356 355. (왕초보 1억) 워렌 버핏이 1억 달러를 한국에 올인한 이유! 356. 워렌 버핏이 한국에 오면 살 주식 . 켈러씨 인터뷰: 385, 386 385. 동적자산배분의 절대지존 Wouter Keller와의 인터뷰 요약(I) 386. 동적자산배분의 절대지존, Wouter Keller와의 인터뷰(II) ","date":"2020-12-17","objectID":"/2020-12-17_halto-400/:17:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '400. (채널가이드) 돈 버는 모든 비법, 400개 영상에 담다!' 정리","uri":"/2020-12-17_halto-400/#17-별-희한한-걸-다-했네요-ii"},{"categories":["투자 일반"],"content":" 18. 요약 ","date":"2020-12-17","objectID":"/2020-12-17_halto-400/:18:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '400. (채널가이드) 돈 버는 모든 비법, 400개 영상에 담다!' 정리","uri":"/2020-12-17_halto-400/#18-요약"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c4. Comprehensions and Generators\u003e Item 30: Consider Generators Instead of Returning Lists Better Way 30. 리스트를 반환하기보다는 제너레이터를 사용하라 ","date":"2020-12-17","objectID":"/2020-12-17_generator/:1:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 30. 리스트를 반환하기보다는 제너레이터를 사용하라' 정리","uri":"/2020-12-17_generator/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언제너레이터는 이터레이터를 반환하는 함수인데, 이터레이터가 next 내장 함수를 호출할 때마다 yield 식을 만날 때까지 제너레이터 함수가 진행됩니다. 입력이 아주 커도 메모리 이슈 없이 잘 동작하고, 코드도 깔끔해지니 적극 고려합시다. ","date":"2020-12-17","objectID":"/2020-12-17_generator/:2:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 30. 리스트를 반환하기보다는 제너레이터를 사용하라' 정리","uri":"/2020-12-17_generator/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 사용 예시문장의 각 단어들의 인덱스에 대해서 뭔가를 해야 하는 상황 address = 'Four score and seven years ago...' # Example 3 (제너레이터) def index_words_iter(text): if text: yield 0 # yield for index, letter in enumerate(text): if letter == ' ': yield index + 1 # yield # 실제로는 이런식으로 사용 for i in index_words_iter(address): pass # Example 4 it = index_words_iter(address) print(next(it)) # 0 print(next(it)) # 5 print(list(it)) # [11, 15, 21, 27]. 이터레이터에 상태가 있으므로 주의! 재사용 불가. # Example 5 result = list(index_words_iter(address)) # 리스트로 쉽게 변환 가능 print(result[:10]) # [0, 5, 11, 15, 21, 27] ","date":"2020-12-17","objectID":"/2020-12-17_generator/:3:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 30. 리스트를 반환하기보다는 제너레이터를 사용하라' 정리","uri":"/2020-12-17_generator/#사용-예시"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Using generators can be clearer than the alternative of having a function return a list of accumulated results. 제너레이터를 사용하면 결과를 리스트에 합쳐서 반환하는 것보다 더 깔끔하다. Tip The iterator returned by a generator produces the set of values passed to yield expressions within the generator function’s body. 제너레이터가 반환하는 이터레이터는 제너레이터 함수의 본문에서 yield가 반환하는 값들로 이뤄진 집합을 만들어낸다. Tip Generators can produce a sequence of outputs for arbitrarily large inputs because their working memory doesn’t include all inputs and outputs. 제너레이터를 사용하면 작업 메모리에 모든 입력과 출력을 저장할 필요가 없으므로 입력이 아주 커도 출력 시퀀스를 만들 수 있다. ","date":"2020-12-17","objectID":"/2020-12-17_generator/:4:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 30. 리스트를 반환하기보다는 제너레이터를 사용하라' 정리","uri":"/2020-12-17_generator/#기억해야-할-내용"},{"categories":["python"],"content":" 리스트로 구현 한다면address = 'Four score and seven years ago...' # Example 1 def index_words(text): result = [] if text: result.append(0) for index, letter in enumerate(text): if letter == ' ': result.append(index + 1) return result result = index_words(address) print(result[:10]) # [0, 5, 11, 15, 21, 27] 코드에 잡음이 많고 핵심을 알아보기 어렵습니다. 반환하기 전에 리스트에 모든 결과를 다 저장해야 합니다. 입력이 매우 큰 경우에 문제가 될 수 있습니다. ","date":"2020-12-17","objectID":"/2020-12-17_generator/:5:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 30. 리스트를 반환하기보다는 제너레이터를 사용하라' 정리","uri":"/2020-12-17_generator/#리스트로-구현-한다면"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 원저자 깃허브 ","date":"2020-12-17","objectID":"/2020-12-17_generator/:6:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 30. 리스트를 반환하기보다는 제너레이터를 사용하라' 정리","uri":"/2020-12-17_generator/#참고-자료"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c4. Comprehensions and Generators\u003e Item 29: Avoid Repeated Work in Comprehensions by Using Assignment Expressions Better way 29. 대입식을 사용해 컴프리헨션 안에서 반복 작업을 피하라 ","date":"2020-12-17","objectID":"/2020-12-17_walus-in-comprehension/:1:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 29. 대입식을 사용해 컴프리헨션 안에서 반복 작업을 피하라' 정리","uri":"/2020-12-17_walus-in-comprehension/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언Comprehension 의 조건 부분에서 대입식(왈러스 연산자)를 사용하면 코드가 간결해질 수 있습니다. ","date":"2020-12-17","objectID":"/2020-12-17_walus-in-comprehension/:2:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 29. 대입식을 사용해 컴프리헨션 안에서 반복 작업을 피하라' 정리","uri":"/2020-12-17_walus-in-comprehension/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 사용 예시stock = { 'nails': 125, 'screws': 35, 'wingnuts': 8, 'washers': 24, } BATCH_SIZE = 8 # 부품을 8개씩 써야 함 # 각 부품의 몇 세트 분량의 재고가 있는지 알고 싶음. order = ['screws', 'wingnuts', 'clips'] def get_batches(count, size): return count // size # screws 의 경우 35개 있으니 4세트 # Example 4 (요렇게, Comprehension 의 조건 부분에 대입식 사용) found = {name: batches for name in order if (batches := get_batches(stock.get(name, 0), BATCH_SIZE))} # 조건 부분에 대입식 사용 print(type(found)) # \u003cclass 'dict'\u003e print(found) # {'screws': 4, 'wingnuts': 1} # Example 10 (제너레이터 생성에도 사용 가능) # Comprehension 을 () 로 묶으면 제너레이터가 되는구나! found = ((name, batches) for name in order if (batches := get_batches(stock.get(name, 0), BATCH_SIZE))) # 조건 부분에 대입식 사용 print(type(found)) # \u003cclass 'generator'\u003e print(next(found)) # ('screws', 4) print(next(found)) # ('wingnuts', 1) ","date":"2020-12-17","objectID":"/2020-12-17_walus-in-comprehension/:3:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 29. 대입식을 사용해 컴프리헨션 안에서 반복 작업을 피하라' 정리","uri":"/2020-12-17_walus-in-comprehension/#사용-예시"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Assignment expressions make it possible for comprehensions and generator expressions to reuse the value from one condition elsewhere in the same comprehension, which can improve readability and performance. 대입식을 통해 컴프리헨션이나 제너리에터 식의 조건 부분에서 사용한 값을 같은 컴프리헨션이나 제너레이터의 다른 위치에서 재사용할 수 있다. 이를 통해 가독성과 성능을 향상시킬 수 있다. Tip Although it’s possible to use an assignment expression outside of a comprehension or generator expression’s condition, you should avoid doing so. 조건이 아닌 부분에도 대입식을 사용할 수 있지만, 그런 형태의 사용은 피해야 한다. ","date":"2020-12-17","objectID":"/2020-12-17_walus-in-comprehension/:4:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 29. 대입식을 사용해 컴프리헨션 안에서 반복 작업을 피하라' 정리","uri":"/2020-12-17_walus-in-comprehension/#기억해야-할-내용"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 원저자 깃허브 Better way 10. 대입식을 사용해 반복을 피하라 ","date":"2020-12-17","objectID":"/2020-12-17_walus-in-comprehension/:5:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 29. 대입식을 사용해 컴프리헨션 안에서 반복 작업을 피하라' 정리","uri":"/2020-12-17_walus-in-comprehension/#참고-자료"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c4. Comprehensions and Generators\u003e Item 28: Avoid More Than Two Control Subexpressions in Comprehensions Better way 28. 컴프리헨션 내부에 제어 하위 식을 세 개 이상 사용하지 말라 ","date":"2020-12-17","objectID":"/2020-12-17_readable-comprehension/:1:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 28. 컴프리헨션 내부에 제어 하위 식을 세 개 이상 사용하지 말라' 정리","uri":"/2020-12-17_readable-comprehension/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언리스트 컴프리헨션은 간단하게만 씁시다. (리스트 컴프리헨션 참고) ","date":"2020-12-17","objectID":"/2020-12-17_readable-comprehension/:2:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 28. 컴프리헨션 내부에 제어 하위 식을 세 개 이상 사용하지 말라' 정리","uri":"/2020-12-17_readable-comprehension/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 사용 예시# Example 1 (요정도는 괜찮지만) matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] flat = [x for row in matrix for x in row] # for 루프 중첩 가능 (matrix 의 row, 고 row 안의 x 이용) print(flat) # [1, 2, 3, 4, 5, 6, 7, 8, 9] my_lists = [ [[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]], ] # Example 4 (복잡한건 그냥 이렇게 풀어 쓰자) flat = [] for sublist1 in my_lists: for sublist2 in sublist1: flat.extend(sublist2) print(flat) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] # Example 3 (너무 이해하기 어려움!) flat = [x for sublist1 in my_lists for sublist2 in sublist1 for x in sublist2] print(flat) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] ","date":"2020-12-17","objectID":"/2020-12-17_readable-comprehension/:3:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 28. 컴프리헨션 내부에 제어 하위 식을 세 개 이상 사용하지 말라' 정리","uri":"/2020-12-17_readable-comprehension/#사용-예시"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Comprehensions support multiple levels of loops and multiple conditions per loop level. 컴프리헨션은 여러 수준의 루프를 지원하며 각 수준마다 여러 조건을 지원한다. Tip Comprehensions with more than two control subexpressions are very difficult to read and should be avoided. 제어 하위 식이 세 개 이상인 컴프리헨션은 이해하기 매우 어려우므로 가능하면 피해야 한다. ","date":"2020-12-17","objectID":"/2020-12-17_readable-comprehension/:4:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 28. 컴프리헨션 내부에 제어 하위 식을 세 개 이상 사용하지 말라' 정리","uri":"/2020-12-17_readable-comprehension/#기억해야-할-내용"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 원저자 깃허브 ","date":"2020-12-17","objectID":"/2020-12-17_readable-comprehension/:5:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 28. 컴프리헨션 내부에 제어 하위 식을 세 개 이상 사용하지 말라' 정리","uri":"/2020-12-17_readable-comprehension/#참고-자료"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c4. Comprehensions and Generators\u003e Item 27: Use Comprehensions Instead of map and filter Better Way 27. map과 filter 대신 컴프리헨션을 사용하라 ","date":"2020-12-16","objectID":"/2020-12-16_map-filter-comprehension/:1:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 27. map과 filter 대신 컴프리헨션을 사용하라' 정리","uri":"/2020-12-16_map-filter-comprehension/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언기존 리스트에서 파생하는 간단한 리스트 생성은 리스트 컴프리헨션을 활용하면 편리합니다. (리스트 컴프리헨션 참고) ","date":"2020-12-16","objectID":"/2020-12-16_map-filter-comprehension/:2:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 27. map과 filter 대신 컴프리헨션을 사용하라' 정리","uri":"/2020-12-16_map-filter-comprehension/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 사용 예시# Example 2 (List comprehension 으로 list 생성) a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] squares = [x**2 for x in a] print(squares) # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] # Example 4 (List comprehension 에 if 도 사용) even_squares = [x**2 for x in a if x % 2 == 0] print(even_squares) # [4, 16, 36, 64, 100] # Example 6 (dict, set 도 comprehension 으로 생성) even_squares_dict = {x: x**2 for x in a if x % 2 == 0} threes_cubed_set = {x**3 for x in a if x % 3 == 0} print(even_squares_dict) # {2: 4, 4: 16, 6: 36, 8: 64, 10: 100} print(threes_cubed_set) # {216, 729, 27} ","date":"2020-12-16","objectID":"/2020-12-16_map-filter-comprehension/:3:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 27. map과 filter 대신 컴프리헨션을 사용하라' 정리","uri":"/2020-12-16_map-filter-comprehension/#사용-예시"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip List comprehensions are clearer than the map and filter built-in functions because they don’t require lambda expressions. 리스트 컴프리헨션은 lambda 식을 사용하지 않기 때문에 같은 일을 하는 map과 filter 내장 함수를 사용하는 것보다 더 명확하다. Tip List comprehensions allow you to easily skip items from the input list, a behavior that map doesn’t support without help from filter. 리스트 컴프리헨션을 사용하면 쉽게 입력 리스트의 원소를 건너뛸 수 있다. 하지만 map을 사용하는 경우에는 filter의 도움을 받아야만 한다. Tip Dictionaries and sets may also be created using comprehensions. 딕셔너리와 집합도 컴프리헨션으로 생성할 수 있다. ","date":"2020-12-16","objectID":"/2020-12-16_map-filter-comprehension/:4:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 27. map과 filter 대신 컴프리헨션을 사용하라' 정리","uri":"/2020-12-16_map-filter-comprehension/#기억해야-할-내용"},{"categories":["python"],"content":" map, filter를 사용한다면List Comprehension 이 없다면 아래처럼 구현했어야 합니다. # Example 1 (Example 2와 같은 동작) a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] squares = [] for x in a: squares.append(x**2) print(squares) # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] # Example 3 (map 사용해서 Example 2와 같은 동작) alt = map(lambda x: x ** 2, a) # map 객체 (이터레이터) print(alt) # \u003cmap object at 0x02ECC370\u003e print(list(alt)) # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] filter 까지 사용한 경우 # Example 5 (map, filter 사용해서 Example 4와 같은 동작) alt = map(lambda x: x**2, filter(lambda x: x % 2 == 0, a)) print(list(alt)) # [4, 16, 36, 64, 100] # filter 참고 temp = filter(lambda x: x % 2 == 0, a) print(list(temp)) # [2, 4, 6, 8, 10] ","date":"2020-12-16","objectID":"/2020-12-16_map-filter-comprehension/:5:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 27. map과 filter 대신 컴프리헨션을 사용하라' 정리","uri":"/2020-12-16_map-filter-comprehension/#map-filter를-사용한다면"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 원저자 깃허브 ","date":"2020-12-16","objectID":"/2020-12-16_map-filter-comprehension/:6:0","series":["effective python 4. 컴프리헨션과 제너레이터"],"tags":["python"],"title":"'Better way 27. map과 filter 대신 컴프리헨션을 사용하라' 정리","uri":"/2020-12-16_map-filter-comprehension/#참고-자료"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c3. Functions\u003e Item 26: Define Function Decorators with functools.wraps Better way 26. functools.wrap을 사용해 함수 데코레이터를 정의하라 ","date":"2020-12-16","objectID":"/2020-12-16_function-decorator/:1:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 26. functools.wrap을 사용해 함수 데코레이터를 정의하라' 정리","uri":"/2020-12-16_function-decorator/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언데코레이터를 직접 구현할 일이 생기면 functools 의 wraps 데코레이터를 사용해야 합니다. ","date":"2020-12-16","objectID":"/2020-12-16_function-decorator/:2:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 26. functools.wrap을 사용해 함수 데코레이터를 정의하라' 정리","uri":"/2020-12-16_function-decorator/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 사용 예시import pickle from functools import wraps # Example 8 def trace(func): @wraps(func) # 요걸 사용하라 (func의 중요한 메타데이터를 복사해 리턴할 함수에 적용해 줌) def wrapper(*args, **kwargs): result = func(*args, **kwargs) print(f'{func.__name__}({args!r}, {kwargs!r}) ' f'-\u003e {result!r}') return result return wrapper @trace def fibonacci(n): \"\"\"Return the n-th Fibonacci number\"\"\" if n in (0, 1): return n return fibonacci(n - 2) + fibonacci(n - 1) # help 가 원하는 데로 동작 함 help(fibonacci) ## Help on function fibonacci in module __main__: ## ## fibonacci(n) ## Return the n-th Fibonacci number # pickle 객체 직렬화도 제대로 작동함 print(pickle.dumps(fibonacci)) ## b'\\x80\\x04\\x95\\x1a\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x08__main__\\x94\\x8c\\tfibonacci\\x94\\x93\\x94.' # 함수 사용 print(fibonacci(2)) ## fibonacci((0,), {}) -\u003e 0 ## fibonacci((1,), {}) -\u003e 1 ## fibonacci((2,), {}) -\u003e 1 ## 1 ","date":"2020-12-16","objectID":"/2020-12-16_function-decorator/:3:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 26. functools.wrap을 사용해 함수 데코레이터를 정의하라' 정리","uri":"/2020-12-16_function-decorator/#사용-예시"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Decorators in Python are syntax to allow one function to modify another function at runtime. 파이썬 데코레이터는 실행 시점에 함수가 다른 함수를 변경할 수 있게 해주는 구문이다. Tip Using decorators can cause strange behaviors in tools that do introspection, such as debuggers. 데코레이터를 사용하면 디버거 등 인트로스펙션을 사용하는 도구가 잘못 작동할 수 있다. Tip Use the wraps decorator from the functools built-in module when you define your own decorators to avoid issues. 직접 데코레이터를 구현할 때 인트로스펙션에서 문제가 생기지 않길 바란다면 functools 내장 모듈의 wraps 데코레이터를 사용하라. ","date":"2020-12-16","objectID":"/2020-12-16_function-decorator/:4:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 26. functools.wrap을 사용해 함수 데코레이터를 정의하라' 정리","uri":"/2020-12-16_function-decorator/#기억해야-할-내용"},{"categories":["python"],"content":" 데코레이터의 동작@ 기호를 사용하는 것은 해당 함수를 인자로 데코레이터 호출 후, 반환한 결과를 원래 이름으로 등록하는 동작을 합니다. # Example 1 def trace(func): def wrapper(*args, **kwargs): print(f'before {func.__name__}({args!r}, {kwargs!r})') result = func(*args, **kwargs) print(f'after {func.__name__}({args!r}, {kwargs!r}) -\u003e {result!r}') return result return wrapper # Example 3 def fibonacci(n): \"\"\"Return the n-th Fibonacci number\"\"\" if n in (0, 1): return n return fibonacci(n - 2) + fibonacci(n - 1) # '@' 기호를 사용하는 것은 아래와 같은 의미 (데코레이터 호출 후, 반환한 결과를 원래 이름으로 등록) fibonacci = trace(fibonacci) fibonacci(2) ## before fibonacci((2,), {}) ## before fibonacci((0,), {}) ## after fibonacci((0,), {}) -\u003e 0 ## before fibonacci((1,), {}) ## after fibonacci((1,), {}) -\u003e 1 ## after fibonacci((2,), {}) -\u003e 1 ","date":"2020-12-16","objectID":"/2020-12-16_function-decorator/:5:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 26. functools.wrap을 사용해 함수 데코레이터를 정의하라' 정리","uri":"/2020-12-16_function-decorator/#데코레이터의-동작"},{"categories":["python"],"content":" 의도하지 않은 상황원래의 fibonacci 가 다른 객체(wrapper)로 바뀐 상황이 되버려서, help, pickle 등이 적절하게 동작하지 않게 됩니다. 그래서 functools.wrap 를 사용해야 합니다. # Example 1 import pickle def trace(func): def wrapper(*args, **kwargs): print(f'before {func.__name__}({args!r}, {kwargs!r})') result = func(*args, **kwargs) print(f'after {func.__name__}({args!r}, {kwargs!r}) -\u003e {result!r}') return result return wrapper # Example 2 @trace def fibonacci(n): \"\"\"Return the n-th Fibonacci number\"\"\" if n in (0, 1): return n return (fibonacci(n - 2) + fibonacci(n - 1)) fibonacci(2) ## before fibonacci((2,), {}) ## before fibonacci((0,), {}) ## after fibonacci((0,), {}) -\u003e 0 ## before fibonacci((1,), {}) ## after fibonacci((1,), {}) -\u003e 1 ## after fibonacci((2,), {}) -\u003e 1 print(fibonacci) ## \u003cfunction trace.\u003clocals\u003e.wrapper at 0x000001D4B7CFC790\u003e help(fibonacci) ## Help on function wrapper in module __main__: ## ## wrapper(*args, **kwargs) pickle.dumps(fibonacci) ## Traceback ... ## AttributeError: Can't pickle local object 'trace.\u003clocals\u003e.wrapper' ","date":"2020-12-16","objectID":"/2020-12-16_function-decorator/:6:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 26. functools.wrap을 사용해 함수 데코레이터를 정의하라' 정리","uri":"/2020-12-16_function-decorator/#의도하지-않은-상황"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 길벗출판사 깃허브 원저자 깃허브 ","date":"2020-12-16","objectID":"/2020-12-16_function-decorator/:7:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 26. functools.wrap을 사용해 함수 데코레이터를 정의하라' 정리","uri":"/2020-12-16_function-decorator/#참고-자료"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c3. Functions\u003e Item 25: Enforce Clarity with Keyword-Only and Positional-Only Arguments Better Way 25. 위치로만 인자를 지정하게 하거나 키워드로만 인자를 지정하게 해서 함수 호출을 명확하게 만들라 ","date":"2020-12-16","objectID":"/2020-12-16_enforce-argument/:1:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 25. 위치로만 인자를 지정하게 하거나 키워드로만 인자를 지정하게 해서 함수 호출을 명확하게 만들라' 정리","uri":"/2020-12-16_enforce-argument/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언파라미터에 /, * 를 이용해서 위치로만 지정하는 인자와 (/ 앞의 인자들) 키워드로만 지정하는 인자(* 뒤의 인자들)를 지정할 수 있습니다. Positional-only parameters(/ 로 구분) 은 파이썬 3.8에서 도입되었습니다. ","date":"2020-12-16","objectID":"/2020-12-16_enforce-argument/:2:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 25. 위치로만 인자를 지정하게 하거나 키워드로만 인자를 지정하게 해서 함수 호출을 명확하게 만들라' 정리","uri":"/2020-12-16_enforce-argument/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 사용 예시# Example 16 def safe_division_e(numerator, denominator, # '/' 앞쪽은 positional-only arguments /, ndigits=10, # 사이에 있는건 둘 다 됨 (파이썬 기본) *, ignore_overflow=False, # '*' 뒤쪽은 keyword-only arguments ignore_zero_division=False): try: fraction = numerator / denominator return round(fraction, ndigits) except OverflowError: if ignore_overflow: return 0 else: raise except ZeroDivisionError: if ignore_zero_division: return float('inf') else: raise # Example 17 result = safe_division_e(22, 7) print(result) # 3.1428571429 result = safe_division_e(22, 7, 5) print(result) # 3.14286 result = safe_division_e(22, 7, ndigits=2) print(result) # 3.14 ","date":"2020-12-16","objectID":"/2020-12-16_enforce-argument/:3:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 25. 위치로만 인자를 지정하게 하거나 키워드로만 인자를 지정하게 해서 함수 호출을 명확하게 만들라' 정리","uri":"/2020-12-16_enforce-argument/#사용-예시"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Keyword-only arguments force callers to supply certain arguments by keyword (instead of by position), which makes the intention of a function call clearer. Keyword-only arguments are defined after a single * in the argument list. 키워드로만 지정해야 하는 인자를 사용하면 호출하는 쪽에서 특정 인자를 (위치를 사용하지 않고) 반드시 키워드를 사용해 호출하도록 강제할 수 있다. 이로 인해 함수 호출의 의도를 명확히 할 수 있다. 키워드로만 지정해야 하는 인자는 인자 목록에서 * 다음에 위치한다. Tip Positional-only arguments ensure that callers can’t supply certain parameters using keywords, which helps reduce coupling. Positional-only arguments are defined before a single / in the argument list. 위치로만 지정해야 하는 인자를 사용하면 호출하는 쪽에서 키워드를 사용해 인자를 지정하지 못하게 만들 수 있고, 이에 따라 함수 구현과 함수 호출 지점 사이의 결합을 줄일 수 있다. 위치로만 지정해야 하는 인자는 인자 목록에서 / 앞에 위치한다. Tip Parameters between the / and * characters in the argument list may be supplied by position or keyword, which is the default for Python parameters. 인자 목록에서 /와 * 사이에 있는 파라미터는 키워드를 사용해 전달해도 되고 위치를 기반으로 전달해도 된다. 이런 동작은 파이썬 함수 파라미터의 기본 동작이다. ","date":"2020-12-16","objectID":"/2020-12-16_enforce-argument/:4:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 25. 위치로만 인자를 지정하게 하거나 키워드로만 인자를 지정하게 해서 함수 호출을 명확하게 만들라' 정리","uri":"/2020-12-16_enforce-argument/#기억해야-할-내용"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 길벗출판사 깃허브 원저자 깃허브 What’s New In Python 3.8 / 파이썬 공식 문서 PEP 570 – Python Positional-Only Parameters PEP 3102 – Keyword-Only Arguments ","date":"2020-12-16","objectID":"/2020-12-16_enforce-argument/:5:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 25. 위치로만 인자를 지정하게 하거나 키워드로만 인자를 지정하게 해서 함수 호출을 명확하게 만들라' 정리","uri":"/2020-12-16_enforce-argument/#참고-자료"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c3. Functions\u003e Item 24: Use None and Docstrings to Specify Dynamic Default Arguments Better Way 24. None과 독스트링을 사용해 동적인 디폴트 인자를 지정하라 ","date":"2020-12-16","objectID":"/2020-12-16_default-arguments/:1:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 24. None과 독스트링을 사용해 동적인 디폴트 인자를 지정하라' 정리","uri":"/2020-12-16_default-arguments/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언디폴트 값을 지정할 때, [], {} 요런 mutable 한 애들은 쓰면 안됩니다. None을 사용하고, 함수 안에서 채웁시다. ","date":"2020-12-16","objectID":"/2020-12-16_default-arguments/:2:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 24. None과 독스트링을 사용해 동적인 디폴트 인자를 지정하라' 정리","uri":"/2020-12-16_default-arguments/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 사용 예시# Example 2 def log(message, when=None): \"\"\"Log a message with a timestamp. Args: message: Message to print. when: datetime of when the message occurred. Defaults to the present time. \"\"\" if when is None: when = datetime.now() print(f'{when}: {message}') # Example 3 log('Hi there!') sleep(0.1) log('Hello again!') ","date":"2020-12-16","objectID":"/2020-12-16_default-arguments/:3:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 24. None과 독스트링을 사용해 동적인 디폴트 인자를 지정하라' 정리","uri":"/2020-12-16_default-arguments/#사용-예시"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip A default argument value is evaluated only once: during function definition at module load time. This can cause odd behaviors for dynamic values (like {}, [] or datetime.now()). 디폴트 인자 값은 그 인자가 포함된 함수 정의가 속한 모듈이 로드되는 시점에 단 한번만 평가된다. 이로 인해 동적인 값({}, [], datetime.now() 등)의 경우 이상한 동작이 일어날 수 있다. Tip Use None as the default value for any keyword argument that has a dynamic value. Document the actual default behavior in the function’s docsting. 동적인 값을 가질 수 있는 키워드 인자의 디폴트 값을 표현할 때는 None을 사용하라. 그리고 함수의 독스트링에 실제 동적인 디폴트 인자가 어떻게 동작하는지 문서화해두라. Tip Using None to represent keyword argument default values also works correctly with type annotations. 타입 애너테이션을 사용할 때도 None을 사용해 키워드 인자의 디폴트 값을 표현하는 방식을 적용할 수 있다. ","date":"2020-12-16","objectID":"/2020-12-16_default-arguments/:4:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 24. None과 독스트링을 사용해 동적인 디폴트 인자를 지정하라' 정리","uri":"/2020-12-16_default-arguments/#기억해야-할-내용"},{"categories":["python"],"content":" 에러 케이스# Example 4 import json def decode(data, default={}): # Default argument value is mutable try: return json.loads(data) except ValueError: return default # Example 5 foo = decode('bad data') foo['stuff'] = 5 bar = decode('also bad') bar['meep'] = 1 print('Foo:', foo) # Foo: {'stuff': 5, 'meep': 1} print('Bar:', bar) # Bar: {'stuff': 5, 'meep': 1} # Example 6 assert foo is bar # 같은 객체임 디폴트 값은 (모듈을 로드하는 시점에) 한 번만 평가되고, 그 딕셔너리가 호출 때마다 공유되게 됩니다. ","date":"2020-12-16","objectID":"/2020-12-16_default-arguments/:5:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 24. None과 독스트링을 사용해 동적인 디폴트 인자를 지정하라' 정리","uri":"/2020-12-16_default-arguments/#에러-케이스"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 길벗출판사 깃허브 원작자 깃허브 ","date":"2020-12-16","objectID":"/2020-12-16_default-arguments/:6:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 24. None과 독스트링을 사용해 동적인 디폴트 인자를 지정하라' 정리","uri":"/2020-12-16_default-arguments/#참고-자료"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c3. Functions\u003e Item 23: Provide Optional Behavior with Keyword Arguments Better Way 23. 키워드 인자로 선택적인 기능을 제공하라 ","date":"2020-12-15","objectID":"/2020-12-15_keyword-args/:1:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 23. 키워드 인자로 선택적인 기능을 제공하라' 정리","uri":"/2020-12-15_keyword-args/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언**kwargs를 파라미터로 아무 키워드나 받는 함수를 만들 수 있습니다. (확장성이 좋아집니다.) ","date":"2020-12-15","objectID":"/2020-12-15_keyword-args/:2:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 23. 키워드 인자로 선택적인 기능을 제공하라' 정리","uri":"/2020-12-15_keyword-args/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 사용 예시# Example 8 (아무 키워드나 받을 수 있는 함수) def print_parameters(**kwargs): for key, value in kwargs.items(): print(f'{key} = {value}') print_parameters(alpha=1.5, beta=9, gamma=4) # alpha = 1.5 # beta = 9 # gamma = 4 def remainder(number, divisor): return number % divisor # Example 5 my_kwargs = { 'number': 20, 'divisor': 7, } # '**' 연산자를 통해 딕셔너리에 있는 값들을 함수에 전달, 여러 딕셔너리 전달도 가능 assert remainder(**my_kwargs) == 6 ","date":"2020-12-15","objectID":"/2020-12-15_keyword-args/:3:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 23. 키워드 인자로 선택적인 기능을 제공하라' 정리","uri":"/2020-12-15_keyword-args/#사용-예시"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Functions arguments can be specified by position or by keyword. 함수 인자를 위치에 따라 지정할 수도 있고, 키워드를 사용해 지정할 수도 있다. Tip Keywords make it clear what the purpose of each argument is when it would be confusing with only positional arguments. 키워드를 사용하면 위치 인자만 사용할 때는 혼동할 수 있는 여러 인자의 목적을 명확히 할 수 있다. Tip Keyword arguments with default values make it easy to add new behaviors to a function without needing to migrate all existing callers. 키워드 인자와 디폴트 인자를 함께 사용하면 기본 호출 코드를 마이그레이션하지 않고도 함수에 새로운 기능을 쉽게 추가할 수 있다. Tip Optional keyword arguments should always be passed by keyword instead of by position. 선택적 키워드 인자는 항상 위치가 아니라 키워드를 사용해 전달되어야 한다. ","date":"2020-12-15","objectID":"/2020-12-15_keyword-args/:4:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 23. 키워드 인자로 선택적인 기능을 제공하라' 정리","uri":"/2020-12-15_keyword-args/#기억해야-할-내용"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 길벗출판사 깃허브 원작자 깃허브 ","date":"2020-12-15","objectID":"/2020-12-15_keyword-args/:5:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 23. 키워드 인자로 선택적인 기능을 제공하라' 정리","uri":"/2020-12-15_keyword-args/#참고-자료"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c3. Functions\u003e Item 22: Reduce Visual Noise with Variable Positional Arguments Better Way 22. 변수 위치 인자를 사용해 시작적인 잡음을 줄여라 ","date":"2020-12-15","objectID":"/2020-12-15_star-args/:1:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 22. 변수 위치 인자를 사용해 시작적인 잡음을 줄여라' 정리","uri":"/2020-12-15_star-args/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언함수의 위치 인자(positional argument)를 가변적으로 받을 수 있으면 함수 호출이 깔끔해지는 케이스가 있습니다. 이 인자를 가변 인자(varargs)나 스타 인자(star args)라고 부르기도 합니다. 관례적으로 가변 인자의 이름을 *args라고 붙이는 데서 유래했다고 합니다. 인수의 개수가 충분히 작다는 게 확실한 경우에만 쓰는 게 좋습니다. 또한 새로운 인자를 추가하는 것도 문제가 될 수 있습니다. ","date":"2020-12-15","objectID":"/2020-12-15_star-args/:2:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 22. 변수 위치 인자를 사용해 시작적인 잡음을 줄여라' 정리","uri":"/2020-12-15_star-args/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 사용 예시# Example 2 def log(message, *values): # 가변인자 받음 if not values: print(message) else: values_str = ', '.join(str(x) for x in values) print(f'{message}: {values_str}') log('My numbers are', 1, 2) # My numbers are: 1, 2 log('Hi there') # Hi there # Example 3 favorites = [7, 33, 99] # 가변인자 들어갈 자리에 리스트에 별을 붙이면, 풀어서 전달됨 log('Favorite colors', *favorites) # Favorite colors: 7, 33, 99 # temp = *favorites # Can't uses starred expression here ","date":"2020-12-15","objectID":"/2020-12-15_star-args/:3:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 22. 변수 위치 인자를 사용해 시작적인 잡음을 줄여라' 정리","uri":"/2020-12-15_star-args/#사용-예시"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Functions can accept a variable number of positional arguments by using *args in the def statement. def 문에서 *arg를 사용하면 함수가 가변 위치 기반 인자를 받을 수 있다. Tip You can use the items from a sequence as the positional arguments for a functions with the * operator. * 연산자를 사용하면 가변 인자를 받는 함수에게 시퀀스 내의 원소들을 전달할 수 있다. Tip Using the * operator with a generator may cause a program to run out of memory and crash. 제너레이터에 * 연산자를 사용하면 프로그램이 메모리를 모두 소진하고 중단될 수 있다. Tip Adding new positional parameters to functions that accept *args can introduce hard-to-detect bugs. *args를 받는 함수에 새로운 위치 기반 인자를 넣으면 감지하기 힘든 버그가 생길 수 있다. ","date":"2020-12-15","objectID":"/2020-12-15_star-args/:4:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 22. 변수 위치 인자를 사용해 시작적인 잡음을 줄여라' 정리","uri":"/2020-12-15_star-args/#기억해야-할-내용"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 길벗출판사 깃허브 원저자 깃허브 ","date":"2020-12-15","objectID":"/2020-12-15_star-args/:5:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 22. 변수 위치 인자를 사용해 시작적인 잡음을 줄여라' 정리","uri":"/2020-12-15_star-args/#참고-자료"},{"categories":["투자 일반"],"content":"요즘 강환국 형님의 ‘할수있다 알고투자’ 채널을 열심히 시청하고 있습니다. 주요 영상들을 제대로 이해하고자 정리해 봅니다. 348. (왕초보 1억) - 초보자 투자는 이렇게 - 영구 포트폴리오의 모든 것! ","date":"2020-12-15","objectID":"/2020-12-15_halto-348/:0:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '348. (왕초보 1억) - 초보자 투자는 이렇게 - 영구 포트폴리오' 정리","uri":"/2020-12-15_halto-348/#"},{"categories":["투자 일반"],"content":" 핵심요약 미래는 예측할 수 없으니, 영구 포트폴리오로 기본 베이스를 삼읍시다. (자산배분!) 네 가지 자산(주식, 채권, 금, 현금)을 25%씩 분배하고, 1년에 한 번 리밸런싱 합니다. 주식 자산에 다른 전략을 써보는 건 ok! ","date":"2020-12-15","objectID":"/2020-12-15_halto-348/:1:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '348. (왕초보 1억) - 초보자 투자는 이렇게 - 영구 포트폴리오' 정리","uri":"/2020-12-15_halto-348/#핵심요약"},{"categories":["투자 일반"],"content":" 영구 포트폴리오 개요 1970~2020 50년간 복리 8.8%, 최대 손실(MDD) 12.7%, 자산 68.8 배를 보여주고 있습니다. 무엇보다 MDD가 12.7%로 매우 아름답습니다. 영구 포트폴리오는 매우 쉽고!! 리스크가 적습니다. 상관성이 낮은 자산에 분산 투자하는 것이 리스크를 줄이는 핵심입니다. 주식을 여러 개 샀다고 분산 투자가 아닙니다. 아예 상관성이 없는 자산군이어야 분산 투자입니다. ","date":"2020-12-15","objectID":"/2020-12-15_halto-348/:2:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '348. (왕초보 1억) - 초보자 투자는 이렇게 - 영구 포트폴리오' 정리","uri":"/2020-12-15_halto-348/#영구-포트폴리오-개요"},{"categories":["투자 일반"],"content":" 경제 4계절 경제 4계절이 있는데, 예측하려고 하지 맙시다. 각 계절마다 잘 나가는 자산군이 있습니다. ","date":"2020-12-15","objectID":"/2020-12-15_halto-348/:3:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '348. (왕초보 1억) - 초보자 투자는 이렇게 - 영구 포트폴리오' 정리","uri":"/2020-12-15_halto-348/#경제-4계절"},{"categories":["투자 일반"],"content":" 종목 구성 (한국 시장) ","date":"2020-12-15","objectID":"/2020-12-15_halto-348/:4:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '348. (왕초보 1억) - 초보자 투자는 이렇게 - 영구 포트폴리오' 정리","uri":"/2020-12-15_halto-348/#종목-구성-한국-시장"},{"categories":["투자 일반"],"content":" 종목 구성 (미국 시장) ","date":"2020-12-15","objectID":"/2020-12-15_halto-348/:5:0","series":["할투 정리"],"tags":["할투"],"title":"할투 '348. (왕초보 1억) - 초보자 투자는 이렇게 - 영구 포트폴리오' 정리","uri":"/2020-12-15_halto-348/#종목-구성-미국-시장"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c3. Functions\u003e Item 21: Know How Closures Interact with Variable Scope Better Way 21. 변수 영역과 클로저의 상호작용 방식을 이해하라 ","date":"2020-12-14","objectID":"/2020-12-14_closure/:1:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 21. 변수 영역과 클로저의 상호작용 방식을 이해하라' 정리","uri":"/2020-12-14_closure/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언함수 안에 함수를 정의할 수 있습니다. 이 내부 함수(?)를 클로저라고 부르는데, 클로저는 자신이 정의된 영역 밖의 변수를 참조할 수 있습니다. 요 클로저 안에서 외부 변수에 대입은 불가능합니다. nonlocal 키워드로 가능하게 할 수 있지만, 사용하지 않는 게 좋을 것 같습니다. ","date":"2020-12-14","objectID":"/2020-12-14_closure/:2:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 21. 변수 영역과 클로저의 상호작용 방식을 이해하라' 정리","uri":"/2020-12-14_closure/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 사용 예시numbers 를 정렬하는데, group 안에 있는 녀석들은 더 앞에 두고 싶은 상황 # Example 1 def sort_priority(values, group): def helper(x): # 클로저(자신이 정의된 영역 밖의 변수 참조 가능)라서 group 참조 가능 if x in group: return (0, x) # 튜플을 리턴하면, 앞의 인덱스 (0 or 1) 기준으로 먼저 정렬됨 return (1, x) values.sort(key=helper) # Example 2 numbers = [8, 3, 1, 2, 5, 4, 7, 6] group = {2, 3, 5, 7} sort_priority(numbers, group) print(numbers) # [2, 3, 5, 7, 1, 4, 6, 8] ","date":"2020-12-14","objectID":"/2020-12-14_closure/:3:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 21. 변수 영역과 클로저의 상호작용 방식을 이해하라' 정리","uri":"/2020-12-14_closure/#사용-예시"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Closure functions can refer to variables from any of the scopes in which they were defined. 클로저 함수는 자신이 정의된 영역 외부에서 정의된 변수도 참조할 수 있다. Tip By default, closures can’t affect enclosing scopes by assigning variables. 기본적으로 클로저 내부에 사용한 대입문은 클로저를 감싸는 영역에 영향을 끼칠 수 없다. Tip Use the nonlocal statement to indicate when a closure can modify a variable in its enclosing scopes. 클로저가 자신을 감싸는 영역의 변수를 변경한다는 사실을 표시할 때는 nonlocal 문을 사용하라. Tip Avoid using nonlocal statements for anything beyond simple functions. 간단한 함수가 아닌 경우에는 nonlocal 문을 사용하지 말라. ","date":"2020-12-14","objectID":"/2020-12-14_closure/:4:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 21. 변수 영역과 클로저의 상호작용 방식을 이해하라' 정리","uri":"/2020-12-14_closure/#기억해야-할-내용"},{"categories":["python"],"content":" 상세 설명위 예제에서, group 에 해당하는 원소가 있었는지를 알고 싶은 상황. 하지만 클로저 안에서 외부 scope 의 값을 변경할 수는 없습니다. # Example 6 def sort_priority2(numbers, group): found = False # Scope: 'sort_priority2' def helper(x): if x in group: found = True # Scope: 'helper' -- Bad! (클로저 내부 변수는, 외부 scope 에 영향 주지 못함) return (0, x) return (1, x) numbers.sort(key=helper) return found # Example 4 numbers = [8, 3, 1, 2, 5, 4, 7, 6] group = {2, 3, 5, 7} found = sort_priority2(numbers, group) print('Found:', found) # Found: False (True를 기대했지만, False임) print(numbers) # [2, 3, 5, 7, 1, 4, 6, 8] 꼭 하고 싶다면, nonlocal문을 통해서, 해당 변수가 클로저 외부에 있다는 것을 명시해 줄 수 있습니다. 하지만 가독성이 떨어질 수 있어서, 웬만하면 사용 안하는 것이 좋을 것 같습니다. # Example 7 def sort_priority3(numbers, group): found = False def helper(x): nonlocal found # Added if x in group: found = True return (0, x) return (1, x) numbers.sort(key=helper) return found # Example 4 numbers = [8, 3, 1, 2, 5, 4, 7, 6] group = {2, 3, 5, 7} found = sort_priority3(numbers, group) print('Found:', found) # Found: True print(numbers) # [2, 3, 5, 7, 1, 4, 6, 8] 위 상황을 해결하는 바람직한 접근은, 상태를 관리하는 클래스를 따로 만드는 것입니다. # Example 9 class Sorter: def __init__(self, group): self.group = group self.found = False def __call__(self, x): # Better Way 38 if x in self.group: self.found = True return (0, x) return (1, x) numbers = [8, 3, 1, 2, 5, 4, 7, 6] group = {2, 3, 5, 7} sorter = Sorter(group) numbers.sort(key=sorter) assert sorter.found is True assert numbers == [2, 3, 5, 7, 1, 4, 6, 8] ","date":"2020-12-14","objectID":"/2020-12-14_closure/:5:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 21. 변수 영역과 클로저의 상호작용 방식을 이해하라' 정리","uri":"/2020-12-14_closure/#상세-설명"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 길벗출판사 깃허브 원저자 깃허브 ","date":"2020-12-14","objectID":"/2020-12-14_closure/:6:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 21. 변수 영역과 클로저의 상호작용 방식을 이해하라' 정리","uri":"/2020-12-14_closure/#참고-자료"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c3. Functions\u003e Item 20: Prefer Raising Exceptions to Returning None Better Way 20. None을 반환하기보다는 예외를 발생시켜라 ","date":"2020-12-13","objectID":"/2020-12-13_exception/:1:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 20. None을 반환하기보다는 예외를 발생시켜라' 정리","uri":"/2020-12-13_exception/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언에러의 의미로 None을 리턴하면 명확하지 않을 수 있습니다. (사용처에서 if문으로 검사할 경우 False 와 같은 의미가 되서, 잘 못 해석할 수 있습니다.) Exception 을 발생시켜서 에러 상황을 명확히 하는 게 낫다고 하네요. Docstring 잘 써 주고, 타입 힌트도 적어주도록 합시다. ","date":"2020-12-13","objectID":"/2020-12-13_exception/:2:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 20. None을 반환하기보다는 예외를 발생시켜라' 정리","uri":"/2020-12-13_exception/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 사용 예시# 파라미터와 리턴 타입 표시해줌 (float 이 리턴 타입이니까 None 은 안오겠군) def careful_divide(a: float, b: float) -\u003e float: \"\"\"Divides a by b. Raises: ValueError: When the inputs cannot be divided. \"\"\" try: return a / b except ZeroDivisionError as e: raise ValueError('Invalid inputs') # 사용처 try: result = careful_divide(1, 0) assert False except ValueError: pass # Expected assert careful_divide(1, 5) == 0.2 ","date":"2020-12-13","objectID":"/2020-12-13_exception/:3:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 20. None을 반환하기보다는 예외를 발생시켜라' 정리","uri":"/2020-12-13_exception/#사용-예시"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Functions that return None to indicate special meaning are error prone because None and other values (e.g., zero, the empty string) all evaluate to False in conditional expressions. 특별한 의미를 표시하는 None을 반환하는 함수를 사용하면 None과 다른 값(예: 0이나 빈 문자열)이 조건문에서 False로 평가될 수 있기 때문에 실수하기 쉽다. Tip Raise exceptions to indicate special situations instead of returning None. Expect the calling code to handle exceptions properly when they’re documented. 특별한 상황을 표현하기 위해 None을 반환하는 대신 예외를 발생시켜라. 문서에 예외 정보를 기록해 호출자가 예외를 제대로 처리하도록 하라. Tip Type annotations can be used to make it clear that a function will never return the value None, even in special situations. 함수가 특별한 경우를 포함하는 그 어떤 경우에도 절대로 None을 반환하지 않는다는 사실을 타입 애너테이션으로 명시할 수 있다. ","date":"2020-12-13","objectID":"/2020-12-13_exception/:4:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 20. None을 반환하기보다는 예외를 발생시켜라' 정리","uri":"/2020-12-13_exception/#기억해야-할-내용"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 길벗출판사 깃허브 원저자 깃허브 ","date":"2020-12-13","objectID":"/2020-12-13_exception/:5:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 20. None을 반환하기보다는 예외를 발생시켜라' 정리","uri":"/2020-12-13_exception/#참고-자료"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c3. Functions\u003e Item 19: Never Unpack More Than Three Variables When Functions Return Multiple Values Better Way 19. 함수가 여러 값을 반환하는 경우 절대로 네 값 이상을 언패킹하지 말라 ","date":"2020-12-12","objectID":"/2020-12-12_unpacking-limit/:1:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 19. 함수가 여러 값을 반환하는 경우 절대로 네 값 이상을 언패킹하지 말라' 정리","uri":"/2020-12-12_unpacking-limit/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언언패킹은 세 개까지만 하는게 좋다고 합니다. 너무 많아지면 헷갈리기 쉬우니까요. ","date":"2020-12-12","objectID":"/2020-12-12_unpacking-limit/:2:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 19. 함수가 여러 값을 반환하는 경우 절대로 네 값 이상을 언패킹하지 말라' 정리","uri":"/2020-12-12_unpacking-limit/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 사용 예시def get_stats(numbers): minimum = min(numbers) maximum = max(numbers) return minimum, maximum lengths = [63, 73, 72, 60, 67, 66, 71, 61, 72, 70] minimum, maximum = get_stats(lengths) # 반환 값이 두 개 print(f'최소: {minimum}, 최대: {maximum}') # 최소: 60, 최대: 73 ","date":"2020-12-12","objectID":"/2020-12-12_unpacking-limit/:3:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 19. 함수가 여러 값을 반환하는 경우 절대로 네 값 이상을 언패킹하지 말라' 정리","uri":"/2020-12-12_unpacking-limit/#사용-예시"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip You can have functions return multiple values by putting them in a tuple and having the caller take advantage of Python’s unpacking syntax. 함수가 여러 값을 반환하기 위해 값들을 튜플에 넣어서 반환하고, 호출하는 쪽에서는 파이썬 언패킹 구문을 쓸 수 있다. Tip Multiple return values from a function can also be unpacked by catch-all starred expressions. 함수가 반환한 여러 값을, 모든 값을 처리하는 별표 식을 사용해 언패킹할 수도 있다. Tip Unpacking into four or more variables is error prone and should be avoided; instead, return a small class or namedtuple instance. 언패킹 구문에 변수가 네 개 이상 나오면 실수하기 쉬우므로 변수를 네 개 이상 사용하면 안 된다. 대신 작은 클래스를 반환하거나 namedtuple 인스턴스를 반환하라. ","date":"2020-12-12","objectID":"/2020-12-12_unpacking-limit/:4:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 19. 함수가 여러 값을 반환하는 경우 절대로 네 값 이상을 언패킹하지 말라' 정리","uri":"/2020-12-12_unpacking-limit/#기억해야-할-내용"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 길벗출판사 깃허브 ","date":"2020-12-12","objectID":"/2020-12-12_unpacking-limit/:5:0","series":["effective python 3. 함수"],"tags":["python"],"title":"'Better way 19. 함수가 여러 값을 반환하는 경우 절대로 네 값 이상을 언패킹하지 말라' 정리","uri":"/2020-12-12_unpacking-limit/#참고-자료"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c2. Lists and Dictionaries\u003e Item 18: Know How to Construct Key-Dependent Default Values with __missing__ Better Way 18. __missing__을 사용해 키에 따라 다른 디폴트 값을 생성하는 방법을 알아두라 ","date":"2020-12-11","objectID":"/2020-12-11_dict-missing/:1:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better Way 18. __missing__을 사용해 키에 따라 다른 디폴트 값을 생성하는 방법을 알아두라' 정리","uri":"/2020-12-11_dict-missing/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언키가 없는 상황을 처리하고자 할 때, defaultdict 으로도 해결이 안되는 상황이 올 수도 있습니다. (defaultdict 은 키에 따라 다른 동작을 하게 할 수 없습니다.) 이 때, dict 을 확장하고 __missing__() 을 구현하면, key에 따라 다른 디폴트 값을 돌려 주게 할 수 있습니다. ","date":"2020-12-11","objectID":"/2020-12-11_dict-missing/:2:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better Way 18. __missing__을 사용해 키에 따라 다른 디폴트 값을 생성하는 방법을 알아두라' 정리","uri":"/2020-12-11_dict-missing/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 사용 예시def open_picture(profile_path): try: return open(profile_path, 'a+b') except OSError: print(f'경로를 열 수 없습니다: {profile_path}') raise class Pictures(dict): def __missing__(self, key): value = open_picture(key) self[key] = value return value pictures = Pictures() handle = pictures[path] handle.seek(0) image_data = handle.read() ","date":"2020-12-11","objectID":"/2020-12-11_dict-missing/:3:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better Way 18. __missing__을 사용해 키에 따라 다른 디폴트 값을 생성하는 방법을 알아두라' 정리","uri":"/2020-12-11_dict-missing/#사용-예시"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip The setdefault method of dict is a bad fit when creating the default value has high computational cost or may raise exceptions. 디폴트 값을 만드는 계산 비용이 높거나 만드는 과정에서 예외가 발생할 수 있는 상황에서는 dict의 setdefault 메서드를 사용하지 말라. Tip The function passed to defaultdict must not require any arguments, which makes it impossible to have the default value depend on the key being accessed. defaultdict에 전달되는 함수는 인자를 받지 않는다. 따라서 접근에 사용한 키 값에 맞는디폴트 값을 생성하는 것은 불가능하다. Tip You can define your own dict subclass with a __missing__ method in order to construct default values that must know which key was being accessed. 디폴트 키를 만들 때 어떤 키를 사용했는지 반드시 알아야 하는 상황이라면 직접 dict의 하위 클래스와 __mising__ 메서드를 정의하면 된다. ","date":"2020-12-11","objectID":"/2020-12-11_dict-missing/:4:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better Way 18. __missing__을 사용해 키에 따라 다른 디폴트 값을 생성하는 방법을 알아두라' 정리","uri":"/2020-12-11_dict-missing/#기억해야-할-내용"},{"categories":["python"],"content":" 상세 설명위 Visits 클래스의 add 에서 setdefault 를 사용한다면 class Visits: def __init__(self): self.data = {} def add(self, country, city): city_set = self.data.setdefault(country, set()) city_set.add(city) setdefault라는 메서드 이름이 좀 애매해서 코드를 처음 읽는 사람이 동작을 바로 이애하기 어렵습니다. 그리고 setdefault() 부를 때, 키가 있더라도 set()이 항상 불리므로 효율적이라 할 수 없습니다. ","date":"2020-12-11","objectID":"/2020-12-11_dict-missing/:5:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better Way 18. __missing__을 사용해 키에 따라 다른 디폴트 값을 생성하는 방법을 알아두라' 정리","uri":"/2020-12-11_dict-missing/#상세-설명"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 길벗출판사 깃허브 ","date":"2020-12-11","objectID":"/2020-12-11_dict-missing/:6:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better Way 18. __missing__을 사용해 키에 따라 다른 디폴트 값을 생성하는 방법을 알아두라' 정리","uri":"/2020-12-11_dict-missing/#참고-자료"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c2. Lists and Dictionaries\u003e Item 17: Prefer defaultdict Over setdefault to Handle Missing Items in Internal State Better Way 17. 내부 상태에서 원소가 없는 경우를 처리할 때는 setdefault보다 defaultdict를 사용하라 ","date":"2020-12-11","objectID":"/2020-12-11_default-dict/:1:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 17. 내부 상태에서 원소가 없는 경우를 처리할 때는 setdefault보다 defaultdict를 사용하라' 정리","uri":"/2020-12-11_default-dict/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언defaultdict 을 사용하면, 키가 없는 경우를 편리하게 처리할 수 있습니다. 보통은 dict를 get() 을 통해 조회하고, 조금 복잡한 상황이라면 dict 대신에 defaultdict 을 사용하는 걸 고려해 보면 좋을 것 같습니다. ","date":"2020-12-11","objectID":"/2020-12-11_default-dict/:2:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 17. 내부 상태에서 원소가 없는 경우를 처리할 때는 setdefault보다 defaultdict를 사용하라' 정리","uri":"/2020-12-11_default-dict/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 사용 예시from collections import defaultdict class Visits: def __init__(self): # 없는 키를 조회하면 set() (빈 set)을 해당 키에 연관시키고 리턴해 줌 self.data = defaultdict(set) def add(self, country, city): self.data[country].add(city) visits = Visits() visits.add('영국', '바스') visits.add('영국', '런던') print(visits.data) # defaultdict(\u003cclass 'set'\u003e, {'영국': {'런던', '바스'}}) ","date":"2020-12-11","objectID":"/2020-12-11_default-dict/:3:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 17. 내부 상태에서 원소가 없는 경우를 처리할 때는 setdefault보다 defaultdict를 사용하라' 정리","uri":"/2020-12-11_default-dict/#사용-예시"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip If you’re creating a dictionary to manage an arbitrary set of potential keys, then you should prefer using a defaultdict instance from the collections built-in module if it suits your problem. 키로 어떤 값이 들어올지 모리는 딕셔너리를 관래해야 하는데 collections 내장 모둘에 있는 defaultdict 인스턴스가 여러분의 필요에 맞아 떨어진다면 defaultdict를 사용하라. Tip If a dictionary of arbitrary keys is passed to you, and you don’t control its creation, then you should prefer the get method to access its items. However, it’s worth considering using the setdefault method for the few situations in which it leads to shorter code. 임의의 키가 들어있는 딕셔너리가 여러분에게 전달됐고 그 딕셔너리가 어떻게 생성됐는지 모르는 경우, 딕셔너리의 원소에 접근하려면 우선 get을 사용해야 한다. 하지만 setdefault가 더 짧은 코드를 만들어내는 몇 가지 경우에는 setdefault를 사용하는 것도 고려해볼 만하다. ","date":"2020-12-11","objectID":"/2020-12-11_default-dict/:4:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 17. 내부 상태에서 원소가 없는 경우를 처리할 때는 setdefault보다 defaultdict를 사용하라' 정리","uri":"/2020-12-11_default-dict/#기억해야-할-내용"},{"categories":["python"],"content":" 상세 설명위 Visits 클래스의 add 에서 setdefault 를 사용한다면 class Visits: def __init__(self): self.data = {} def add(self, country, city): city_set = self.data.setdefault(country, set()) city_set.add(city) setdefault라는 메서드 이름이 좀 애매해서 코드를 처음 읽는 사람이 동작을 바로 이애하기 어렵습니다. 그리고 setdefault() 부를 때, 키가 있더라도 set()이 항상 불리므로 효율적이라 할 수 없습니다. ","date":"2020-12-11","objectID":"/2020-12-11_default-dict/:5:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 17. 내부 상태에서 원소가 없는 경우를 처리할 때는 setdefault보다 defaultdict를 사용하라' 정리","uri":"/2020-12-11_default-dict/#상세-설명"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 길벗출판사 깃허브 ","date":"2020-12-11","objectID":"/2020-12-11_default-dict/:6:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 17. 내부 상태에서 원소가 없는 경우를 처리할 때는 setdefault보다 defaultdict를 사용하라' 정리","uri":"/2020-12-11_default-dict/#참고-자료"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c2. Lists and Dictionaries\u003e Item 16: Prefer get Over in and KeyError to Handle Missing Dictionary Keys Better Way 16. in을 사용하고 딕셔너리 키가 없을 때 KeyError를 처리하기보다는 get을 사용하라 ","date":"2020-12-10","objectID":"/2020-12-10_get-for-missing-key/:1:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 16. in을 사용하고 딕셔너리 키가 없을 때 KeyError를 처리하기보다는 get을 사용하라' 정리","uri":"/2020-12-10_get-for-missing-key/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언딕셔너리 키가 없을 때 처리는 get을 사용하는 게 좋습니다. ","date":"2020-12-10","objectID":"/2020-12-10_get-for-missing-key/:2:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 16. in을 사용하고 딕셔너리 키가 없을 때 KeyError를 처리하기보다는 get을 사용하라' 정리","uri":"/2020-12-10_get-for-missing-key/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 사용 예시counters = { '품퍼니켈': 2, '사워도우': 1, } key = '밀' count = counters.get(key, 0) # key 가 딕셔너리에 없으면 0(디폴트 값) 리턴. 두 번째 파라미터 없으면 None 리턴 counters[key] = count + 1 print(counters) # {'품퍼니켈': 2, '사워도우': 1, '밀': 1} ","date":"2020-12-10","objectID":"/2020-12-10_get-for-missing-key/:3:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 16. in을 사용하고 딕셔너리 키가 없을 때 KeyError를 처리하기보다는 get을 사용하라' 정리","uri":"/2020-12-10_get-for-missing-key/#사용-예시"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip There are four common ways to detect and handle missing keys in dictionaries: using in expressions, KeyError exceptions, the get method, and the setdefault method. 딕셔너리 키가 없는 경우를 처리하는 방법으로는 in 식을 이용하는 방법, KeyError 예외를 사용하는 방법, get 메서드를 사용하는 방법, setdefault 메서드를 사용하는 방법이 있다. Tip The get method is best for dictionaries that contain basic types like counters, and it is preferable along with assignment expressions when creating dictionary values has a high cost or may raise exceptions. 카운터와 같이 기본적인 타입의 값이 들어가는 딕셔너리를 다룰 때는 get 메서드가 가정 좋고, 딕셔너리에 넣을 값을 만드는 비용이 비싸거나 만드는 과정에 예외가 발생할 수 있는 경우에도 get 메서드를 사용하는 편이 낫다. Tip When the setdefault method of dict seems like the best fit for your problem, you should consider using defaultdict instead. 해결하려는 문제에 dict의 setdefault 메서드를 사용하는 방법이 가장 적합해 보인다면 setdefault 대신 defaultdict를 사용할지 고려해 보라. ","date":"2020-12-10","objectID":"/2020-12-10_get-for-missing-key/:4:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 16. in을 사용하고 딕셔너리 키가 없을 때 KeyError를 처리하기보다는 get을 사용하라' 정리","uri":"/2020-12-10_get-for-missing-key/#기억해야-할-내용"},{"categories":["python"],"content":" 상세 설명","date":"2020-12-10","objectID":"/2020-12-10_get-for-missing-key/:5:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 16. in을 사용하고 딕셔너리 키가 없을 때 KeyError를 처리하기보다는 get을 사용하라' 정리","uri":"/2020-12-10_get-for-missing-key/#상세-설명"},{"categories":["python"],"content":" in, KeyError 로 확인 (안티패턴)아래 처럼 하지 말고, get을 추천합니다. counters = { '품퍼니켈': 2, '사워도우': 1, } key = '밀' # 해당 키가 존재하는 지 'in' 으로 확인 (요것보다 get이 좋음) if key in counters: count = counters[key] else: count = 0 counters[key] = count + 1 # KeyError 예외 처리 (요것보다 get이 좋음) try: count = counters[key] except KeyError: count = 0 counters[key] = count + 1 ","date":"2020-12-10","objectID":"/2020-12-10_get-for-missing-key/:5:1","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 16. in을 사용하고 딕셔너리 키가 없을 때 KeyError를 처리하기보다는 get을 사용하라' 정리","uri":"/2020-12-10_get-for-missing-key/#in-keyerror-로-확인-안티패턴"},{"categories":["python"],"content":" setdefault요거는 키가 없는 경우에, 넘겨준 디폴트 값을 바로 딕셔너리에 추가를 해줍니다. 하지만, 네이밍과 동작이 직관적으지 않을 수 있으니 사용을 지향해야 한다고 합니다. (defaultdict 고려) votes = { '바게트': ['철수', '순이'], '치아바타': ['하니', '유리'], } # get() 으로 key 존재 여부 확인 key = '브리오슈' who = '단이' names = votes.get(key) if names is None: votes[key] = names = [] names.append(who) print(votes) # {'바게트': ['철수', '순이'], '치아바타': ['하니', '유리'], '브리오슈': ['단이']} # setdefault() 로 key 없으면 바로 딕셔너리에 추가 key = '베이글' who = '현아' names = votes.setdefault(key, []) names.append(who) print(votes) # {'바게트': ['철수', '순이'], '치아바타': ['하니', '유리'], '브리오슈': ['단이'], '베이글': ['현아']} ","date":"2020-12-10","objectID":"/2020-12-10_get-for-missing-key/:5:2","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 16. in을 사용하고 딕셔너리 키가 없을 때 KeyError를 처리하기보다는 get을 사용하라' 정리","uri":"/2020-12-10_get-for-missing-key/#setdefault"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 길벗출판사 깃허브 ","date":"2020-12-10","objectID":"/2020-12-10_get-for-missing-key/:6:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 16. in을 사용하고 딕셔너리 키가 없을 때 KeyError를 처리하기보다는 get을 사용하라' 정리","uri":"/2020-12-10_get-for-missing-key/#참고-자료"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c2. Lists and Dictionaries\u003e Item 15: Be Cautious When Relying on dict Insertion Ordering Better way 15. 딕셔너리 삽입 순서에 의존할 때는 조심하라 ","date":"2020-12-09","objectID":"/2020-12-09_dict-insertion-order/:1:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 15. 딕셔너리 삽입 순서에 의존할 때는 조심하라' 정리","uri":"/2020-12-09_dict-insertion-order/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언파이썬 3.7부터는 딕셔너리에 추가한 순서대로 순회가 됩니다. 이전 버전의 파이썬도 고려해야 한다면 collections.OrderedDict을 사용해야 합니다. 혹 dict라는 게 확실하지 않다면, 추가 순서에 의존하는 로직을 짜는 건 위험합니다. ","date":"2020-12-09","objectID":"/2020-12-09_dict-insertion-order/:2:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 15. 딕셔너리 삽입 순서에 의존할 때는 조심하라' 정리","uri":"/2020-12-09_dict-insertion-order/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Since Python 3.7, you can rely on the fact that iterating a dict instance’s contents will occur in the same order in which the keys were initially added. 파이썬 3.7부터는 dict 인스턴스에 들어 있는 내용을 이터레이션할 때 키를 삽입한 순서대로 돌려받는다는 사실에 의존할 수 있다. Tip Python makes it easy to define objects that act like dictionaries but that aren’t dict instances. For these types, you can’t assume that insertion ordering will be preserved. 파이썬은 dict는 아니지만 딕셔너리와 비슷한 객체를 쉽게 만들 수 있게 해준다. 이런 타입의 경우 키 삽입 순서가 그대로 보존된다고 가정할 수 없다. Tip There are three ways to be careful about dictionary-like classes: Write code that doesn’t rely on insertion ordering, explicitly check for the dict type at runtime, or require dict values using type annotations and static analysis. 딕셔너리와 비슷한 클래스를 조심스럽게 다루는 방법으로는 dict 인스턴스의 삽입 순서 보존에 의존하지 않고 코드를 작성하는 방법, 실행 시점에 명시적으로 dict 타입을 검사하는 방법, 타입 애너테이션과 정적 분석(static analysis)을 사용해 dict 값을 요구하는 방법이 있다. ","date":"2020-12-09","objectID":"/2020-12-09_dict-insertion-order/:3:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 15. 딕셔너리 삽입 순서에 의존할 때는 조심하라' 정리","uri":"/2020-12-09_dict-insertion-order/#기억해야-할-내용"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 길벗출판사 깃허브 ","date":"2020-12-09","objectID":"/2020-12-09_dict-insertion-order/:4:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 15. 딕셔너리 삽입 순서에 의존할 때는 조심하라' 정리","uri":"/2020-12-09_dict-insertion-order/#참고-자료"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c2. Lists and Dictionaries\u003e Item 14: Sort by Complex Criteria Using the key Parameter 14. 복잡한 기준을 사용해 정렬할 때는 key 파라미터를 사용하라 ","date":"2020-12-08","objectID":"/2020-12-08_key-parameter/:1:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 14. 복잡한 기준을 사용해 정렬할 때는 key 파라미터를 사용하라' 정리","uri":"/2020-12-08_key-parameter/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언객체 리스트를 커스텀하게 정렬해야 한다면, 정렬 기준이 될 값을 리턴하는 함수를 key 파라미터로 넘기면 됩니다. 혹 애트리뷰트가 많고 정렬 기준이 복잡하다면, 행렬 데이터 처리에 많이 쓰이는 pandas 모듈을 사용하는 것이 좋은 선택일 수 있습니다. ","date":"2020-12-08","objectID":"/2020-12-08_key-parameter/:2:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 14. 복잡한 기준을 사용해 정렬할 때는 key 파라미터를 사용하라' 정리","uri":"/2020-12-08_key-parameter/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 사용 예시class Tool: def __init__(self, name, weight): self.name = name self.weight = weight def __repr__(self): return f'Tool({self.name!r}, {self.weight})' tools = [ Tool('수준계', 3.5), Tool('해머', 1.25), Tool('스크류드라이버', 0.5), Tool('끌', 0.25), ] print('미정렬:', repr(tools)) # 미정렬: [Tool('수준계', 3.5), Tool('해머', 1.25), Tool('스크류드라이버', 0.5), Tool('끌', 0.25)] tools.sort(key=lambda x: x.name) print('정렬: ', tools) # 정렬: [Tool('끌', 0.25), Tool('수준계', 3.5), Tool('스크류드라이버', 0.5), Tool('해머', 1.25)] tools.sort(key=lambda x: x.weight) print('무게순 정렬:', tools) # 무게순 정렬: [Tool('끌', 0.25), Tool('스크류드라이버', 0.5), Tool('해머', 1.25), Tool('수준계', 3.5)] ","date":"2020-12-08","objectID":"/2020-12-08_key-parameter/:3:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 14. 복잡한 기준을 사용해 정렬할 때는 key 파라미터를 사용하라' 정리","uri":"/2020-12-08_key-parameter/#사용-예시"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip The sort method of the list type can be used to rearrange a list’s content by the natural ordering of built-in types like strings, integers, tuples, and so on. 리스트 타입에 들어 있는 sort 메서드를 사용하면 원소 타입이 문자열, 정수, 튜플 등과 같은 내장 타입인 경우 자연스러운 순서로 리스트의 원소를 정렬할 수 있다. Tip The sort method doesn’t work for objects unless they define a natural ordering using special methods, which is uncommon. 원소 타입에 특별 메서드를 통해 자연스러운 순서가 정의돼 있지 않으면 sort 메서드를 쓸 수 없다. 하지만 원소 타입에 순서 특별 메서드를 정의하는 경우는 드물다. Tip The key parameter of the sort method can be used to supply a helper function that returns the value to use for sorting in place of each item for the list. sort 메서드의 key 파라미터를 사용하면 리스트의 각 원소 대신 비교에 사용할 객체를 반환하는 도우미 함수를 제공할 수 있다. Tip Returning a tuple from the key function allows you to combine multiple sorting criteria together. The unary minus operator can be used to reverse individual sort orders for types that allow it. key 함수에서 튜플을 반환하면 여러 정렬 기준을 하나로 엮을 수 있다. 단항 부호 반전 연산자를 사용하면 부호를 바꿀 수 있는 타입이 정렬 기준인 경우 정렬 순서를 반대로 바꿀 수 있다. Tip For types that can’t be negated, you can combine many sorting criteria together by calling the sort method multiple times using different key functions and reverse values, in the order of lowest rank sort call to highest rank sort call. 부호를 바꿀 수 없는 타입의 경우 여러 정렬 기준을 조합하려면 각 정렬 기준마다 reverse 값으로 정렬 순서를 지정하면서 sort 메서드를 여러 번 사용해야 한다. 이때 정렬 기준의 우선순위가 점점 높아지는 순서로 sort를 호출해야 한다. ","date":"2020-12-08","objectID":"/2020-12-08_key-parameter/:4:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 14. 복잡한 기준을 사용해 정렬할 때는 key 파라미터를 사용하라' 정리","uri":"/2020-12-08_key-parameter/#기억해야-할-내용"},{"categories":["python"],"content":" 추가 사용 예시class Tool: def __init__(self, name, weight): self.name = name self.weight = weight def __repr__(self): return f'Tool({self.name!r}, {self.weight})' power_tools = [ Tool('연마기', 4), Tool('드릴', 4), Tool('원형 톱', 5), Tool('착암기', 40), ] # 튜플을 리턴하는 함수를 넘기면, 여러 기준으로 정렬 가능 power_tools.sort(key=lambda x: (x.weight, x.name)) # weight 로 먼저 정렬한 후, 같은 weight 안에서는 name 으로 정렬 print(power_tools) # [Tool('드릴', 4), Tool('연마기', 4), Tool('원형 톱', 5), Tool('착암기', 40)] power_tools.sort(key=lambda x: (x.weight, x.name), reverse=True) # 모든 비교 기준을 내림차순으로 만든다 print(power_tools) # [Tool('착암기', 40), Tool('원형 톱', 5), Tool('연마기', 4), Tool('드릴', 4)] power_tools.sort(key=lambda x: (-x.weight, x.name)) # 숫자 값의 경우 정렬 방향 반대로 할 수 있음 (문자열은 안됨) print(power_tools) # [Tool('착암기', 40), Tool('원형 톱', 5), Tool('드릴', 4), Tool('연마기', 4)] # sort 를 두 번 해서 원하는 기준들로 정렬하기 (weight 로 먼저 정렬한 후, 같은 weight 안에서는 name 으로 정렬) power_tools.sort(key=lambda x: x.name) # name 기준 오름차순 (요걸 먼저 불러야 함) power_tools.sort(key=lambda x: x.weight, reverse=True) # weight 기준 내림차순 print(power_tools) # [Tool('착암기', 40), Tool('원형 톱', 5), Tool('드릴', 4), Tool('연마기', 4)] ","date":"2020-12-08","objectID":"/2020-12-08_key-parameter/:5:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 14. 복잡한 기준을 사용해 정렬할 때는 key 파라미터를 사용하라' 정리","uri":"/2020-12-08_key-parameter/#추가-사용-예시"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 길벗출판사 깃허브 ","date":"2020-12-08","objectID":"/2020-12-08_key-parameter/:6:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 14. 복잡한 기준을 사용해 정렬할 때는 key 파라미터를 사용하라' 정리","uri":"/2020-12-08_key-parameter/#참고-자료"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c2. Lists and Dictionaries\u003e Item 13: Prefer Catch-All Unpacking Over Slicing Better Way 13. 슬라이싱보다는 나머지를 모두 잡아내는 언패킹을 사용하라 ","date":"2020-12-07","objectID":"/2020-12-07_catch-all-unpacking/:1:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 13. 슬라이싱보다는 나머지를 모두 잡아내는 언패킹을 사용하라' 정리","uri":"/2020-12-07_catch-all-unpacking/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언리스트를 언패킹할때, 나머지 부분은 별표식(starred expression) 으로 잡아낼 수 있습니다. ","date":"2020-12-07","objectID":"/2020-12-07_catch-all-unpacking/:2:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 13. 슬라이싱보다는 나머지를 모두 잡아내는 언패킹을 사용하라' 정리","uri":"/2020-12-07_catch-all-unpacking/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 사용 예시car_ages = [0, 9, 4, 8, 7, 20, 19, 1, 6, 15] car_ages_descending = sorted(car_ages, reverse=True) print(car_ages_descending) # [20, 19, 15, 9, 8, 7, 6, 4, 1, 0] # 요런 식으로 리스트의 나머지 부분 언패킹 oldest, second_oldest, *others = car_ages_descending print(oldest, second_oldest, others) # 20 19 [15, 9, 8, 7, 6, 4, 1, 0] # 요렇게 쓰지 말자 oldest = car_ages_descending[0] second_oldest = car_ages_descending[1] others = car_ages_descending[2:] print(oldest, second_oldest, others) # 20 19 [15, 9, 8, 7, 6, 4, 1, 0] ","date":"2020-12-07","objectID":"/2020-12-07_catch-all-unpacking/:3:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 13. 슬라이싱보다는 나머지를 모두 잡아내는 언패킹을 사용하라' 정리","uri":"/2020-12-07_catch-all-unpacking/#사용-예시"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Unpacking assignments may use a starred expression to catch all values that weren’t assigned to the other parts of the unpacking pattern into a list. 언패킹 대입에 별표 식을 사용하면 언패킹 패턴에서 대입되지 않는 모든 부분을 리스트에 잡아낼 수 있다. Tip Starred expressions may appear in any position, and they will always become a list containing the zero or more values they receive. 별표 식은 언패킹 패턴의 어떤 위치에든 놓을 수 있다. 별표 식에 대입된 결과는 항상 리스트가 되며, 이 리스트에는 별표 식이 받은 값이 0개 또는 그 이상 들어간다. Tip When dividing a list into non-overlapping pieces, catch-all unpacking is much less error prone than slicing and indexing. 리스트를 서로 겹치지 않게 여러 조각으로 나눌 경우, 슬라이싱과 인덱싱을 사용하기보다는 나머지를 모두 잡아내는 언패킹을 사용해야 실수할 여지가 훨씬 줄어든다. ","date":"2020-12-07","objectID":"/2020-12-07_catch-all-unpacking/:4:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 13. 슬라이싱보다는 나머지를 모두 잡아내는 언패킹을 사용하라' 정리","uri":"/2020-12-07_catch-all-unpacking/#기억해야-할-내용"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 길벗출판사 깃허브 ","date":"2020-12-07","objectID":"/2020-12-07_catch-all-unpacking/:5:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 13. 슬라이싱보다는 나머지를 모두 잡아내는 언패킹을 사용하라' 정리","uri":"/2020-12-07_catch-all-unpacking/#참고-자료"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c2. List and Dictionaries\u003e Item 12: Avoid Striding and Slicing in a Single Expression Better way 12. 스타라이드와 슬라이스를 한 식에 함께 사용하지 말라 ","date":"2020-12-06","objectID":"/2020-12-06_stride-and-slice/:1:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 12. 스타라이드와 슬라이스를 한 식에 함께 사용하지 말라' 정리","uri":"/2020-12-06_stride-and-slice/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언슬라이싱과 인덱싱을 같이 쓰면 너무 복잡해져서 이해하기 어렵습니다. 나눠서 씁시다. 증가값이 음수인 경우도 복잡해지니 웬만하면 쓰지 맙시다. ","date":"2020-12-06","objectID":"/2020-12-06_stride-and-slice/:2:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 12. 스타라이드와 슬라이스를 한 식에 함께 사용하지 말라' 정리","uri":"/2020-12-06_stride-and-slice/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 사용 예시colors = ['빨강', '주황', '노랑', '녹색', '파랑', '자주'] odds = colors[::2] # ['빨강', '노랑', '파랑']. 처음(0) 에서 시작. 두 칸씩 evens = colors[1::2] # ['주황', '녹색', '자주'] temp = colors[::-2] # ['자주', '녹색', '주황']. stride 가 음수면 뒤에서 시작. print(odds) print(evens) print(temp) x = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'] y = x[::2] # ['a', 'c', 'e', 'g'] z = y[1:-1] # ['c', 'e'] print(y) print(z) ","date":"2020-12-06","objectID":"/2020-12-06_stride-and-slice/:3:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 12. 스타라이드와 슬라이스를 한 식에 함께 사용하지 말라' 정리","uri":"/2020-12-06_stride-and-slice/#사용-예시"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Specifying start, end, and stride in a slice can be extremely confusing. 슬라이스에 시작, 끝, 증가값을 함께 지정하면 코드의 의미를 혼동하기 쉽다. Tip Prefer using positive stride values in slices without start or end indexes. Avoid negative stride values if possible. 시작이나 끝 인덱스가 없는 슬라이스를 만들 때는 양수 증가값을 사용하라. 가급적 음수 증가값은 피하라. Tip Avoid using start, end, and stride together in a single slice. If you need all three parameters, consider doing two assignments (one to stride and another to slice) or using islice from the itertools built-in module. 한 슬라이스 안에서 시작, 끝, 증가값을 함께 사용하지 말라. 세 파라미터를 모두 써야 하는 경우, 두 번 대입을 사용(한 번은 스트라이딩, 한 번은 슬라이싱)하거나 itertools 내장 모듈의 islice를 사용하라. ","date":"2020-12-06","objectID":"/2020-12-06_stride-and-slice/:4:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 12. 스타라이드와 슬라이스를 한 식에 함께 사용하지 말라' 정리","uri":"/2020-12-06_stride-and-slice/#기억해야-할-내용"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 길벗출판사 깃허브 ","date":"2020-12-06","objectID":"/2020-12-06_stride-and-slice/:5:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 12. 스타라이드와 슬라이스를 한 식에 함께 사용하지 말라' 정리","uri":"/2020-12-06_stride-and-slice/#참고-자료"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 현재 위치 Note \u003c2. Lists and Dictionaries\u003e Item 11: Know How to Slice Sequences Better way 11. 시퀀스를 슬라이싱하는 방법을 익혀라 ","date":"2020-12-05","objectID":"/2020-12-05_slice-sequence/:1:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 11. 시퀀스를 슬라이싱하는 방법을 익혀라' 정리","uri":"/2020-12-05_slice-sequence/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언슬라이싱은 정말 많이 쓰이고 유용한 기능입니다. list, tuple, str에 사용 가능합니다. ","date":"2020-12-05","objectID":"/2020-12-05_slice-sequence/:2:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 11. 시퀀스를 슬라이싱하는 방법을 익혀라' 정리","uri":"/2020-12-05_slice-sequence/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 사용 예시a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'] print(a[:]) # ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'] 리스트를 복사하는 데 사용 print(a[:5]) # ['a', 'b', 'c', 'd', 'e'] print(a[:-1]) # ['a', 'b', 'c', 'd', 'e', 'f', 'g'] print(a[4:]) # ['e', 'f', 'g', 'h'] print(a[-3:]) # ['f', 'g', 'h'] print(a[2:5]) # ['c', 'd', 'e'] print(a[2:-1]) # ['c', 'd', 'e', 'f', 'g'] print(a[-3:-1]) # ['f', 'g'] # 길이 제한 (슬라이싱은 인덱스 범위를 넘어가도 괜찮음) first_twenty_items = a[:20] last_twenty_items = a[-20:] # 슬라이스에 대입 (쓸 일이 있을까?) print('이전:', a) # ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'] a[2:7] = [99, 22, 14] print('이후:', a) # ['a', 'b', 99, 22, 14, 'h'] ","date":"2020-12-05","objectID":"/2020-12-05_slice-sequence/:3:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 11. 시퀀스를 슬라이싱하는 방법을 익혀라' 정리","uri":"/2020-12-05_slice-sequence/#사용-예시"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Avoid being verbose when slicing: Don’t supply 0 for the start index or the length of the sequence for the end index. 슬라이싱할 때는 간결하게 하라. 시작 인덱스에 0을 넣거나, 끝 인덱스에 시퀀스의 길이를 넣지 말라. Tip Slicing is forgiving of start or end indexed that are our of bounds, which means it’s easy to express slices on the front or back boundaries of a sequence (like a[:20] or a[-20:]). 슬라이싱은 범위를 넘어가는 시작 인덱스나 끝 인덱스도 허용한다. 따라서 시퀀스의 시작이나 끝에서 길이를 제한하는 슬라이스(a[:20]이나 a[-20:])을 쉽게 표현할 수 있다. Tip Assigning to a list slice replaces that range in the original sequence with what’s referenced even if the lengths are different. 리스트 슬라이스에 대입하면 원래 시퀀스에서 슬라이스가 가리키는 부분을 대입 연산자 오른쪽에 있는 시퀀스로 대치한다. 이 때 슬라이스와 대치되는 시퀀스가 달라도 된다. ","date":"2020-12-05","objectID":"/2020-12-05_slice-sequence/:4:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 11. 시퀀스를 슬라이싱하는 방법을 익혀라' 정리","uri":"/2020-12-05_slice-sequence/#기억해야-할-내용"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 길벗출판사 깃허브 ","date":"2020-12-05","objectID":"/2020-12-05_slice-sequence/:5:0","series":["effective python 2. 리스트와 딕셔너리"],"tags":["python"],"title":"'Better way 11. 시퀀스를 슬라이싱하는 방법을 익혀라' 정리","uri":"/2020-12-05_slice-sequence/#참고-자료"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 혹 누군가에게도 도움이 되기를 바랍니다. 현재 위치 Note \u003c1. Pythonic Thinking\u003e Item 10: Prevent Repetition with Assignment Expressions Better way 10. 대입식을 사용해 반복을 피하라 ","date":"2020-12-04","objectID":"/2020-12-04_walrus-operator/:1:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 10. 대입식을 사용해 반복을 피하라' 정리","uri":"/2020-12-04_walrus-operator/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언if문이나 while문 등의 조건식에 왈러스 연산자:=를 활용하면 코드 중복을 없앨 수 있습니다. 표현식 안에 쓰여서 대입 후 실제 평가가 이루어 집니다. ‘왈러스’라는 이름은 연산자가 바다코끼리(walrus)의 눈과 어금니처럼 생겨서 붙여졌다고 합니다. ","date":"2020-12-04","objectID":"/2020-12-04_walrus-operator/:2:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 10. 대입식을 사용해 반복을 피하라' 정리","uri":"/2020-12-04_walrus-operator/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 사용 예시a = [10, 2 , 34, 4, 5, 1] if n := len(a): # 변수 'n' 정의 및 대입. 이 후 if 조건 평가 print(f'List has {n} elements.') # 블록 안에서도 계산된 'n' 사용 print(f'outside. n: {n}') # `n` 은 여기서도 유효함. (if 바로 앞 줄에서 n 을 대입한 것과 같은 결과) \u003e\u003e\u003e List has 6 elements. outside. n: 6 if 조건식 안에서 대입식 사용 if (n := len(a)) \u003e 10: # 변수 'n' 정의 및 대입. 이 후 if 조건 평가 print(f\"List is too long ({n} elements, expected \u003c= 10)\") 더 큰 표현식의 일부라면 괄호로 감싸야 함. (:=의 연산자 우선순위가 부등호 등보다 낮음) ","date":"2020-12-04","objectID":"/2020-12-04_walrus-operator/:3:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 10. 대입식을 사용해 반복을 피하라' 정리","uri":"/2020-12-04_walrus-operator/#사용-예시"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Assignment expressions use the walrus operator (:=) to both assign and evaluate variable names in a single expression, thus reducing repetition. 대입식에서는 왈러스 연산자(:=)를 사용해 하나의 식 안에서 변수 이름에 값을 대입하면서 이 값을 평가할 수 있고, 중복을 줄일 수 있다. Tip When an assignment expression is a subexpression of a larger expression, it must be surrounded with parentheses. 대입식이 더 큰 식의 일부분으로 쓰일 때는 괄로로 둘러싸야 한다. Tip Although switch/case statements and do/while loops are not available in Python, their functionality can be emulated much more clearly by using assignment expressions. 파이썬에서는 switch/case 문이나 do/while 루프를 쓸 수 없지만, 대입식을 사용하면 이런 기능을 더 깔끔하게 흉내 낼 수 있다. ","date":"2020-12-04","objectID":"/2020-12-04_walrus-operator/:4:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 10. 대입식을 사용해 반복을 피하라' 정리","uri":"/2020-12-04_walrus-operator/#기억해야-할-내용"},{"categories":["python"],"content":" 추가 사용 예시# Loop over fixed length blocks while (block := f.read(256)) != '': process(block) while 문의 조건식 안에서 대입식 사용 fresh_fruit = { '사과': 10, '바나나': 8, '레몬': 5, } if (count := fresh_fruit.get('바나나', 0)) \u003e= 2: pieces = slice_bananas(count) to_enjoy = make_smoothies(pieces) elif (count := fresh_fruit.get('사과', 0)) \u003e= 4: to_enjoy = make_cider(count) elif count := fresh_fruit.get('레몬', 0): to_enjoy = make_lemonade(count) else: to_enjoy = '아무것도 없음' 파이썬에는 없는 switch/case 느낌으로 사용 ","date":"2020-12-04","objectID":"/2020-12-04_walrus-operator/:5:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 10. 대입식을 사용해 반복을 피하라' 정리","uri":"/2020-12-04_walrus-operator/#추가-사용-예시"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 길벗출판사 깃허브 What’s New In Python 3.8 (파이썬 공식 문서) ","date":"2020-12-04","objectID":"/2020-12-04_walrus-operator/:6:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 10. 대입식을 사용해 반복을 피하라' 정리","uri":"/2020-12-04_walrus-operator/#참고-자료"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 혹 누군가에게도 도움이 되기를 바랍니다. 현재 위치 Note \u003c1. Pythonic Thinking\u003e Item 9: Avoid else Blocks After for and while Loops Better way 9. for나 while 루프 뒤에 else 블록을 사용하지 말라 ","date":"2020-12-04","objectID":"/2020-12-04_avoid-else-block-after-for/:1:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 9. for나 while 루프 뒤에 else 블록을 사용하지 말라' 정리","uri":"/2020-12-04_avoid-else-block-after-for/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언for나 while 루프 뒤에 else 를 붙이는 문법도 있었네요. 계속 몰라도 될 것 같습니다. ","date":"2020-12-04","objectID":"/2020-12-04_avoid-else-block-after-for/:2:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 9. for나 while 루프 뒤에 else 블록을 사용하지 말라' 정리","uri":"/2020-12-04_avoid-else-block-after-for/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Python has special syntax that allows else blocks to immediately follow for and while loop interior blocks. 파이썬은 for나 while 루프에 속한 블록 바로 뒤에 else 블록을 허용하는 특별한 문법을 제공한다. Tip The else block after a loop runs only if the loop body did not encounter a break statement. 루프 뒤에 오는 else 블록은 루프가 반복되는 도중에 break를 만나지 않은 경우에만 실행된다. Tip Avoid using else blocks after loops because their behavior isn’t intuitive and can be confusing. 동작이 직관적이지 않고 혼동을 야기할 수 있으므로 루프 뒤에 else 블록을 사용하지 말라. ","date":"2020-12-04","objectID":"/2020-12-04_avoid-else-block-after-for/:3:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 9. for나 while 루프 뒤에 else 블록을 사용하지 말라' 정리","uri":"/2020-12-04_avoid-else-block-after-for/#기억해야-할-내용"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) ","date":"2020-12-04","objectID":"/2020-12-04_avoid-else-block-after-for/:4:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 9. for나 while 루프 뒤에 else 블록을 사용하지 말라' 정리","uri":"/2020-12-04_avoid-else-block-after-for/#참고-자료"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 혹 누군가에게도 도움이 되기를 바랍니다. 현재 위치 Note \u003c1. Pythonic Thinking\u003e Item 8: Use zip to Process Iterators in Parallel ","date":"2020-12-03","objectID":"/2020-12-03_zip/:1:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 8. 여러 이터레이터에 나란히 루프를 수행하려면 zip을 사용하라' 정리","uri":"/2020-12-03_zip/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언리스트 여러개에 대해서 같은 인덱스를 봐야 한다면, zip!! 리스트 길이가 다를 때는 쓰지 않는 게 좋을 듯 합니다. ","date":"2020-12-03","objectID":"/2020-12-03_zip/:2:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 8. 여러 이터레이터에 나란히 루프를 수행하려면 zip을 사용하라' 정리","uri":"/2020-12-03_zip/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 사용 예시두 리스트에 대해서 같은 인덱스를 봐야하는 상황에서 사용할 수 있습니다. names = ['Cecilia', '남궁민수', '毛泽东'] counts = [len(n) for n in names] # [7, 4, 3] print(counts) longest_name = None max_count = 0 for name, count in zip(names, counts): if count \u003e max_count: longest_name = name max_count = count print(longest_name, max_count) \u003e\u003e\u003e [7, 4, 3] Cecilia 7 ","date":"2020-12-03","objectID":"/2020-12-03_zip/:3:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 8. 여러 이터레이터에 나란히 루프를 수행하려면 zip을 사용하라' 정리","uri":"/2020-12-03_zip/#사용-예시"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip The zip built-in function can be used to iterate over multiple iterators in parallel. zip 내장 함수를 사용해 여러 이터레이터를 나란히 이터레이션할 수 있다. Tip zip creates a lazy generator that produces tuples, so it can be used on infinitely long inputs. zip은 튜플을 지연 계산하는 제너레이터를 만든다. 따라서 무한히 긴 입력에도 zip을 쓸 수 있다. Tip zip truncates its output silently to the shortest iterator if you supply it with iterators of different lengths. 입력 이터레이터의 길이가 서로 다르면 zip은 아무런 경고도 없이 가장 짧은 이터레이터 길이까지만 튜플을 내놓고 더 긴 이터레이터의 나머지 원소는 무시한다. Tip Use the zip_longest function from the itertools built-in module if you want to use zip on iterators of unequal lengths without truncation. 가장 짧은 이터레이터에 맞춰 길이를 제한하지 않고 길이가 서로 다른 이터레이터에 대해 루프를 수행하려면 itertools 내장 모듈의 zip_longest 함수를 사용하라. ","date":"2020-12-03","objectID":"/2020-12-03_zip/:4:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 8. 여러 이터레이터에 나란히 루프를 수행하려면 zip을 사용하라' 정리","uri":"/2020-12-03_zip/#기억해야-할-내용"},{"categories":["python"],"content":" 상세 설명내부적으로 제너레이터(next 불릴때마다 하나씩 뽑아줌)로 동작한다고 합니다. \u003e\u003e\u003e names = ['Cecilia', '남궁민수', '毛泽东'] \u003e\u003e\u003e counts = [len(n) for n in names] # [7, 4, 3] \u003e\u003e\u003e temp_generator = zip(names, counts) \u003e\u003e\u003e next(temp_generator) ('Cecilia', 7) \u003e\u003e\u003e next(temp_generator) ('남궁민수', 4) \u003e\u003e\u003e next(temp_generator) ('毛泽东', 3) ","date":"2020-12-03","objectID":"/2020-12-03_zip/:5:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 8. 여러 이터레이터에 나란히 루프를 수행하려면 zip을 사용하라' 정리","uri":"/2020-12-03_zip/#상세-설명"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 길벗출판사 깃허브 ","date":"2020-12-03","objectID":"/2020-12-03_zip/:6:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 8. 여러 이터레이터에 나란히 루프를 수행하려면 zip을 사용하라' 정리","uri":"/2020-12-03_zip/#참고-자료"},{"categories":["개발 일반"],"content":"개인적으로 IntelliJ 기반 IDE를 주로 사용합니다. (AndroidStudio, PyCharm) 요새 React를 좀 배워보고 있어, VS Code 를 자주 쓰게 되네요. 다른 블로그 및 유튜브 참고해서, 유용한 단축키 정리해 보았습니다. ","date":"2020-12-02","objectID":"/2020-12-02_vscode-shortcut/:0:0","series":null,"tags":["vs_code"],"title":"Visual Studio Code 유용한 단축키 모음","uri":"/2020-12-02_vscode-shortcut/#"},{"categories":["개발 일반"],"content":" 탐색 정의로 이동: F12 참조하는 곳으로 이동: Shift + F12 이전/다음 위치로 이동: Alt + 뒤/앞 파일 맨 위/아래로 이동: Ctrl + Home/End ","date":"2020-12-02","objectID":"/2020-12-02_vscode-shortcut/:1:0","series":null,"tags":["vs_code"],"title":"Visual Studio Code 유용한 단축키 모음","uri":"/2020-12-02_vscode-shortcut/#탐색"},{"categories":["개발 일반"],"content":" 서식 주석 처리: Ctrl + / 문서 서식: Shift + Alt + F ","date":"2020-12-02","objectID":"/2020-12-02_vscode-shortcut/:2:0","series":null,"tags":["vs_code"],"title":"Visual Studio Code 유용한 단축키 모음","uri":"/2020-12-02_vscode-shortcut/#서식"},{"categories":["개발 일반"],"content":" 커서 마우스가 가는 곳마다 커서 만들기: Shift + Alt + 마우스 드래그 선택된 영역 커서 만들기: Shift + Alt + I 클릭하는 곳마다 커서 생성: Alt + 마우스 클릭 같은 단어에 커서 추가: Ctrl + D ","date":"2020-12-02","objectID":"/2020-12-02_vscode-shortcut/:3:0","series":null,"tags":["vs_code"],"title":"Visual Studio Code 유용한 단축키 모음","uri":"/2020-12-02_vscode-shortcut/#커서"},{"categories":["개발 일반"],"content":" 편집 코드 위/아래로 움직이기: Alt + 위/아래 코드 위/아래로 복사: Alt + Shift + 위/아래 심볼 이름 바꾸기: F2 ","date":"2020-12-02","objectID":"/2020-12-02_vscode-shortcut/:4:0","series":null,"tags":["vs_code"],"title":"Visual Studio Code 유용한 단축키 모음","uri":"/2020-12-02_vscode-shortcut/#편집"},{"categories":["개발 일반"],"content":" 기타 사이드바 숨기기: Ctrl + B ","date":"2020-12-02","objectID":"/2020-12-02_vscode-shortcut/:5:0","series":null,"tags":["vs_code"],"title":"Visual Studio Code 유용한 단축키 모음","uri":"/2020-12-02_vscode-shortcut/#기타"},{"categories":["개발 일반"],"content":" 레퍼런스 코딩 인생 꿀템 VSC 단축키 5분 정리해드림 (노마드코더 유튜브) File - Preferences - Keyboard Shortcuts (Ctrl + K, S 에서 확인 가능) ","date":"2020-12-02","objectID":"/2020-12-02_vscode-shortcut/:6:0","series":null,"tags":["vs_code"],"title":"Visual Studio Code 유용한 단축키 모음","uri":"/2020-12-02_vscode-shortcut/#레퍼런스"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 혹 누군가에게도 도움이 되기를 바랍니다. 현재 위치 Note \u003c1. Pythonic Thinking\u003e Item 7: Prefer enumerate Over range ","date":"2020-12-02","objectID":"/2020-12-02_enumerate/:1:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 7. range 보다는 enumerate를 사용하라' 정리","uri":"/2020-12-02_enumerate/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언list 에 for 루프 돌 일 있으면, enumerate!! ","date":"2020-12-02","objectID":"/2020-12-02_enumerate/:2:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 7. range 보다는 enumerate를 사용하라' 정리","uri":"/2020-12-02_enumerate/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 사용 예시두 리스트에 대해서 같은 인덱스를 봐야하는 상황에서 사용할 수 있습니다. flavor_list = ['바닐라', '초콜릿', '피칸', '딸기'] for i, flavor in enumerate(flavor_list, 1): # enumerate() 두번째 인자로 i의 시작 번호 지정 print(f'{i}: {flavor}') \u003e\u003e\u003e 1: 바닐라 2: 초콜릿 3: 피칸 4: 딸기 ","date":"2020-12-02","objectID":"/2020-12-02_enumerate/:3:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 7. range 보다는 enumerate를 사용하라' 정리","uri":"/2020-12-02_enumerate/#사용-예시"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip enumerate provides concise syntax for looping over an iterator and getting the index of each item from the iterator as you go. enumerate를 사용하면 이터레이터에 대해 루프를 돌면서 이터레이터에서 가져오는 원소의 인덱스까지 얻는 코드를 간결하게 작성할 수 있다. Tip Prefer enumerate instead of looping over a range and indexing into a sequence. range에 대해 루프를 돌면서 시퀀스의 원소를 인덱스로 가져오기보다는 enumerate를 사용하라. Tip You can supply a second parameter to enumerate to specify the number from which to begin counting (zero is the default). enumerate의 두 번째 파라미터로 몇 부터 번호를 부여할지 지정할 수 있다(디폴트 값은 0이다). ","date":"2020-12-02","objectID":"/2020-12-02_enumerate/:4:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 7. range 보다는 enumerate를 사용하라' 정리","uri":"/2020-12-02_enumerate/#기억해야-할-내용"},{"categories":["python"],"content":" 상세 설명내부적으로 제너레이터로 동작합니다. flavor_list = ['바닐라', '초콜릿', '피칸', '딸기'] it = enumerate(flavor_list, 1) print(next(it)) print(next(it)) \u003e\u003e\u003e (1, '바닐라') (2, '초콜릿') ","date":"2020-12-02","objectID":"/2020-12-02_enumerate/:5:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 7. range 보다는 enumerate를 사용하라' 정리","uri":"/2020-12-02_enumerate/#상세-설명"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 길벗출판사 깃허브 ","date":"2020-12-02","objectID":"/2020-12-02_enumerate/:6:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 7. range 보다는 enumerate를 사용하라' 정리","uri":"/2020-12-02_enumerate/#참고-자료"},{"categories":["python"],"content":"파일 읽을 때, 보통 with 구문을 사용합니다. 그러면 with 구문이 끝날 때 해당 파일의 close()가 자동으로 불리게 되지요. with open('output.txt', 'w') as output_file: output_file.write('Life is too short, You need Python') # 아래와 같은 의미 output_file = open('output.txt', 'w') try: output_file.write('Life is too short, You need Python') finally: output_file.close() 직접 만든 클래스도 with 구문을 지원하게 만들 수 있는데, 이는 사용 측에서 해당 인스턴스의 사용 준비(__enter__) 및 리소스 정리(__exit__) 작업을 신경 안써도 되는 효과가 있습니다. 이를 위해, __enter__(with 구문 시작할 때 사용 준비),__exit__(with 구분 끝날 때 정리 작업) 을 구현해주면 됩니다. ","date":"2020-11-29","objectID":"/2020-11-29_with-statement-context_mananger/:0:0","series":null,"tags":["python"],"title":"with 구문 지원하기 (With Statement Context Manager)","uri":"/2020-11-29_with-statement-context_mananger/#"},{"categories":["python"],"content":" 사용 예시스택오버플로우 답변 내용입니다. # with 구문 지원하는 클래스 class DatabaseConnection(object): def __enter__(self): # make a database connection and return it ... return self.dbconn # as 로 받아서 쓸 인스턴스. 보통은 self 를 리턴할 듯 def __exit__(self, exc_type, exc_val, exc_tb): # make sure the dbconnection gets closed self.dbconn.close() ... 해당 클래스의 사용측은 아래처럼 with 구문으로 사용하면 됩니다. # 해당 클래스 사용처 with DatabaseConnection() as mydbconn: # do stuff __enter__ 에서 보통은 self를 리턴할 것 같은데, 아닌 케이스도 가끔 있나 봅니다. 요건 케이스가 나오면 나중에 다시 고민해보도록 하겠습니다. ","date":"2020-11-29","objectID":"/2020-11-29_with-statement-context_mananger/:1:0","series":null,"tags":["python"],"title":"with 구문 지원하기 (With Statement Context Manager)","uri":"/2020-11-29_with-statement-context_mananger/#사용-예시"},{"categories":["python"],"content":" Reference The with statement (파이썬 공식 문서) With Statement Context Managers (파이썬 공식 문서) Context Managers (Python Tips) Explaining Python’s __enter__ and __exit__ (StackOverflow 답변) ","date":"2020-11-29","objectID":"/2020-11-29_with-statement-context_mananger/:2:0","series":null,"tags":["python"],"title":"with 구문 지원하기 (With Statement Context Manager)","uri":"/2020-11-29_with-statement-context_mananger/#reference"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 혹 누군가에게도 도움이 되기를 바랍니다. 현재 위치 Note \u003c1. Pythonic Thinking\u003e Item 6: Prefer Multiple Assignment Unpacking Over Indexing ","date":"2020-11-29","objectID":"/2020-11-29_unpacking/:1:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 6. 인덱스를 사용하는 대신 대입을 사용해 데이터를 언패킹하라' 정리","uri":"/2020-11-29_unpacking/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언코드를 이해하기 쉽도록, 알아 볼 수 있는 이름으로 언패킹해야 합니다. 인덱스로 접근은 지양합시다. ","date":"2020-11-29","objectID":"/2020-11-29_unpacking/:2:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 6. 인덱스를 사용하는 대신 대입을 사용해 데이터를 언패킹하라' 정리","uri":"/2020-11-29_unpacking/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 사용 예시\u003e\u003e\u003e item = ('호박엿', '식혜') \u003e\u003e\u003e \u003e\u003e\u003e # 인덱스를 사용해 접근 (이해하기 어려움) \u003e\u003e\u003e print(item[0], '\u0026', item[1]) 호박엿 \u0026 식혜 \u003e\u003e\u003e # 언패킹 사용 (요렇게 쓰자) \u003e\u003e\u003e first, second = item # 언패킹 \u003e\u003e\u003e print(first, '\u0026', second) 호박엿 \u0026 식혜 튜플도 원소 개 수 알고 있다면, 인덱스로 접근하지 말고 언패킹으로. snacks = [('베이컨', 350), ('도넛', 240), ('머핀', 190)] # 요렇게 쓰자 for i, (name, calories) in enumerate(snacks, 1): # enumerate() 의 1은 i 시작을 1부터 하라는 의미 print(f'#{i}: {name} 은 {calories} 칼로리입니다.') # 요렇게 쓰지 말자 for i in range(len(snacks)): item = snacks[i] name = item[0] calories = item[1] print(f'#{i+1}: {name} 은 {calories} 칼로리입니다.') \u003e\u003e\u003e #1: 베이컨 은 350 칼로리입니다. #2: 도넛 은 240 칼로리입니다. #3: 머핀 은 190 칼로리입니다. ","date":"2020-11-29","objectID":"/2020-11-29_unpacking/:3:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 6. 인덱스를 사용하는 대신 대입을 사용해 데이터를 언패킹하라' 정리","uri":"/2020-11-29_unpacking/#사용-예시"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Python has special syntax called unpacking for assigning multiple values in a single statement. 파이썬은 한 문장 안에서 여러 값을 대입할 수 있는 언패킹이라는 특별한 문법을 제공한다. Tip Unpacking is generalized in Python and can be applied to any iterable, including many levels of iterables within iterables. 파이썬 언패킹은 일반화돼 있으므로 모든 이터러블에 적용할 수 있다. 그리고 이터러블이 여러 계층으로 내포된 경우에도 언패킹을 적용할 수 있다. Tip Reduce visual noise and increase code clarity by using unpacking to avoid explicitly indexing into sequences. 인덱스를 사용해 시퀀스 내부에 접근하는 대신 언패킹을 사용해 시각적인 잡음을 줄이고 코드를 더 명확하게 만들라. ","date":"2020-11-29","objectID":"/2020-11-29_unpacking/:4:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 6. 인덱스를 사용하는 대신 대입을 사용해 데이터를 언패킹하라' 정리","uri":"/2020-11-29_unpacking/#기억해야-할-내용"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) 길벗출판사 깃허브 ","date":"2020-11-29","objectID":"/2020-11-29_unpacking/:5:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 6. 인덱스를 사용하는 대신 대입을 사용해 데이터를 언패킹하라' 정리","uri":"/2020-11-29_unpacking/#참고-자료"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 혹 누군가에게도 도움이 되기를 바랍니다. 현재 위치 Note \u003c1. Pythonic Thinking\u003e Item 5: Write Helper Functions Instead of Complex Expressions ","date":"2020-11-29","objectID":"/2020-11-29_helper-functions/:1:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 5. 복잡한 식을 쓰는 대신 도우미 함수를 작성하라' 정리","uri":"/2020-11-29_helper-functions/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언코드를 짧게 할 수 있다는 생각으로 너무 복잡하게 만들어서는 안됩니다. 항상 나중에 코드를 읽을 사람(미래의 나를 포함)을 배려해야 한다는 생각을 합시다. ","date":"2020-11-29","objectID":"/2020-11-29_helper-functions/:2:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 5. 복잡한 식을 쓰는 대신 도우미 함수를 작성하라' 정리","uri":"/2020-11-29_helper-functions/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Python’s syntax makes it easy to write single-line expressions that are overly complicated and difficult to read. 파이썬 문법을 사용하면 아주 복잡하고 어려운 한 줄짜리 식을 쉽게 작성할 수 있다. Tip Move complex expressions into helper functions, expecially if you need to use the same logic repeatedly. 복잡한 식을 도우미 함수로 옮겨라. 특히 같은 로직을 반복해 사용할 때는 도우미 함수를 꼭 사용하라. Tip An if/else expression provides a more readable alternative to using the Boolean operators or and and in expressions. 불(boolean) 연산자 or나 and를 식에 사용하는 것보다 if/else 식을 쓰는 편이 더 가독성이 좋다. ","date":"2020-11-29","objectID":"/2020-11-29_helper-functions/:3:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 5. 복잡한 식을 쓰는 대신 도우미 함수를 작성하라' 정리","uri":"/2020-11-29_helper-functions/#기억해야-할-내용"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) ","date":"2020-11-29","objectID":"/2020-11-29_helper-functions/:4:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 5. 복잡한 식을 쓰는 대신 도우미 함수를 작성하라' 정리","uri":"/2020-11-29_helper-functions/#참고-자료"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 혹 누군가에게도 도움이 되기를 바랍니다. 현재 위치 Note \u003c1. Pythonic Thinking\u003e Item 4: Prefer Interpolated F-Strings Over C-style Format Strings and str.format ","date":"2020-11-29","objectID":"/2020-11-29_f-string/:1:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 4. C 스타일 형식 문자열을 str.format과 쓰기보다는 f-string을 통한 인터폴레이션을 사용하라' 정리","uri":"/2020-11-29_f-string/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언f-strings(Formatted String Literals) 을 사용합시다. (파이썬 3.6부터 지원) 나머지는 과거의 유산들이니, 알아는 두도록 합시다. ","date":"2020-11-29","objectID":"/2020-11-29_f-string/:2:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 4. C 스타일 형식 문자열을 str.format과 쓰기보다는 f-string을 통한 인터폴레이션을 사용하라' 정리","uri":"/2020-11-29_f-string/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 사용 예시\u003e\u003e\u003e table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678} \u003e\u003e\u003e for name, phone in table.items(): ... print(f'{name:10} ==\u003e {phone:10d}') ... Sjoerd ==\u003e 4127 Jack ==\u003e 4098 Dcab ==\u003e 7678 ","date":"2020-11-29","objectID":"/2020-11-29_f-string/:3:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 4. C 스타일 형식 문자열을 str.format과 쓰기보다는 f-string을 통한 인터폴레이션을 사용하라' 정리","uri":"/2020-11-29_f-string/#사용-예시"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip C-style format strings that use the % operator suffer from a variety of gatchas and verbosity problems. % 연산자를 사용하는 C 스타일 형식화 문자열은 여러가지 단점과 번잡성이라는 문제가 있다. Tip The str.format mathod introduces some useful concepts in its formatting specifiers mini language, but it otherwise repeats the mistakes of C-style format strings and should be avoided. str.format 메서드는 형식 지정자 미니 언어에서 유용한 개념 몇 가지를 새로 제공했다. 하지만 이를 제외하면 str.format 메소드도 C 스타일 형식 문자열의 문제점을 그대로 가지고 있으므로, 가능하면 str.format 사용을 피해야 한다. Tip F-strings are a new syntax for formatting values into strings that solves the biggest problems with C-style format strings. f-string은 값을 문자열 안에 넣는 새로운 구문으로, C 스타일 형식화 문자열의 가장 큰 문제점을 해결해준다. Tip F-strings are succinct yet powerful because they allow for arbitrary Python expressions to be directly embedded within format specifiers. f-string은 간결하지만, 위치 지정자 안에 임의의 파이썬 식을 직접 포함시킬 수 있으므로 매우 강력하다. ","date":"2020-11-29","objectID":"/2020-11-29_f-string/:4:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 4. C 스타일 형식 문자열을 str.format과 쓰기보다는 f-string을 통한 인터폴레이션을 사용하라' 정리","uri":"/2020-11-29_f-string/#기억해야-할-내용"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) The Python Tutorial - Formatted String Literals ","date":"2020-11-29","objectID":"/2020-11-29_f-string/:5:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 4. C 스타일 형식 문자열을 str.format과 쓰기보다는 f-string을 통한 인터폴레이션을 사용하라' 정리","uri":"/2020-11-29_f-string/#참고-자료"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 혹 누군가에게도 도움이 되기를 바랍니다. 현재 위치 Note \u003c1. Pythonic Thinking\u003e Item 3: Know the Differences Between bytes and str ","date":"2020-11-28","objectID":"/2020-11-28_bytes-vs-str/:1:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 3. bytes와 str의 차이를 알아두라' 정리","uri":"/2020-11-28_bytes-vs-str/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언개인적으로 아직 bytes를 쓸 일이 거의 없어서, 딱히 와닿지는 않습니다. 일단은 str 과 bytes는 다른 타입이고 섞어쓸 수 없다는 것을 기억해 둡시다. ","date":"2020-11-28","objectID":"/2020-11-28_bytes-vs-str/:2:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 3. bytes와 str의 차이를 알아두라' 정리","uri":"/2020-11-28_bytes-vs-str/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip bytes contains sequences of 8-bits values, and str contains sequence of Unicode code points. bytes 에는 8비트 값의 시퀀스가 들어 있고, str에는 유니코드 코드 포인트의 시퀀스가 들어 있다. Tip Use helper functions to ensure that the inputs you operate on are the type of character sequence that you expect (8-bit values, UTF-8-encoded strings, Unicode code points, etc). 처리할 입력이 원하는 문자 시퀀스(8비트 값, UTF-8로 인코딩된 문자열, 유니코드 코드 포인트들)인지 확실히 하려면 도우미 함수를 사용하라. Tip bytes and str instances can’t be used together with operators (like \u003e, ==, +, and %). bytes와 str 인스턴스를 (\u003e, ==, +, %와 같은) 연산자에 섞어서 사용할 수 없다. Tip If you want to read or write binary data to/from a file, always open the file using a binary mode (like 'rb' or 'wb'). 이진 데이터를 파일에서 읽거나 파일에 쓰고 싶으면 항상 이진 모드('rb'나 'wb') 로 파일을 열어라. Tip If you want to read or write Unicode data to/from a file, be careful about your system’s default text encoding. Explicitly pass the encoding parameter to open if you want to avoid surprises. 유니코드 데이터를 파일에서 읽거나 파일에 쓰고 싶을 때는 시스템 디폴트 인코딩에 주의하라. 인코딩 차이로 놀라고 싶지 않으면 open에 encoding 파라미터를 명시적으로 전달하라. ","date":"2020-11-28","objectID":"/2020-11-28_bytes-vs-str/:3:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 3. bytes와 str의 차이를 알아두라' 정리","uri":"/2020-11-28_bytes-vs-str/#기억해야-할-내용"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) ","date":"2020-11-28","objectID":"/2020-11-28_bytes-vs-str/:4:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 3. bytes와 str의 차이를 알아두라' 정리","uri":"/2020-11-28_bytes-vs-str/#참고-자료"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 혹 누군가에게도 도움이 되기를 바랍니다. 현재 위치 Note \u003c1. Pythonic Thinking\u003e Item 2: Follow the PEP 8 Style Guide ","date":"2020-11-28","objectID":"/2020-11-28_coding-convention/:1:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 2. PEP 8 스타일 가이드를 따르라' 정리","uri":"/2020-11-28_coding-convention/#들어가며"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Always follow the Python Enhancement Proposal #8 (PEP 8) style guide when writing Python code. 파이썬 코드를 작성할 때는 항상 파이썬 개선 제안 #8(PEP 8) 스타일 가이드를 따르라. Tip Sharing a common style with the larger Python community facilitates collaboration with others. 큰 파이썬 커뮤니티와 공통된 스타일을 공유하면 다른 사람과 협력할 때 도움이 된다. Tip Using a consistent style makes it easier to modify your own code later. 일관성 있는 스타일을 사용하면 나중에 자신이 작성한 코드를 직접 수정할 때도 더 수월해진다. ","date":"2020-11-28","objectID":"/2020-11-28_coding-convention/:2:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 2. PEP 8 스타일 가이드를 따르라' 정리","uri":"/2020-11-28_coding-convention/#기억해야-할-내용"},{"categories":["python"],"content":" 나의 생각어떤 프로젝트를 참여하던지 코딩 컨벤션을 확인하고 거기에 따라야 합니다. 개발자는 코드 작성하는 데 쓰는 시간보다, 이미 작성된 코드를 보는데 훨씬 더 많은 시간을 보낸다고 합니다. 고로, 읽기 좋은 코드가 바로 좋은 코드입니다. 일관성 있는 코드라야 읽기가 쉽습니다. 읽는 사람을 편하게 해주려고 노력해야 합니다. 물론, 읽는 사람에는 미래의 자기 자신도 포함됩니다. ㅎ 일관성 있는 코드 작성을 위해 노력하고, 뭔가 찜찜하다면 스타일 가이드를 확인합시다. PEP 8 https://www.python.org/dev/peps/pep-0008/ PEP 8 한글 요약 https://codechacha.com/ko/pythonic-and-pep8/ 구글 파이썬 스타일 가이드 https://google.github.io/styleguide/pyguide.html 스타일 가이드를 꼼꼼히 읽어보면 좋겠지만, 저는 영어도 짧고 시간도 많지 않습니다. (저 글들이 재미 있지도 않습니다 ㅠㅜㅋ) 기본적인 스타일 가이드를 따랐는지는 IDE에서 쉽게 확인해주고 고쳐줍니다. 여러 IDE가 있겠지만 저는 PyCharm 을 추천 합니다. IDE의 경고는 바로 바로 수정하고, 틈나는 데로 Ctrl+Alt+L (Reformat Code)을 눌러주도록 합시다. 처음부터 모든 코딩 컨벤션을 숙지할 수는 없습니다. 일단 만들고자 하는 걸 만들기 시작하는 게 먼저입니다. 코딩 컨벤션을 지켜야 한다는 걸 마음 한 켠에 남겨두기는 합시다. 덧. 이름 짓는 건 언제나 어렵습니다. ","date":"2020-11-28","objectID":"/2020-11-28_coding-convention/:3:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 2. PEP 8 스타일 가이드를 따르라' 정리","uri":"/2020-11-28_coding-convention/#나의-생각"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) PEP 8 PEP 8 한글 요약 구글 파이썬 스타일 가이드 ","date":"2020-11-28","objectID":"/2020-11-28_coding-convention/:4:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 2. PEP 8 스타일 가이드를 따르라' 정리","uri":"/2020-11-28_coding-convention/#참고-자료"},{"categories":["python"],"content":" 들어가며Effective Python 2nd 파이썬 코딩의 기술 (교보문고 링크)을 제대로 이해하고자 블로그에 정리합니다. 혹 누군가에게도 도움이 되기를 바랍니다. 현재 위치 Note \u003c1. Pythonic Thinking\u003e Item 1: Know Which Version of Python You’re Using ","date":"2020-11-28","objectID":"/2020-11-28_python-version/:1:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 1. 사용 중인 파이썬의 버전을 알아두라' 정리","uri":"/2020-11-28_python-version/#들어가며"},{"categories":["python"],"content":" 한 줄 요약 및 첨언파이썬2 는 이제는 보내줍시다. 파이썬3 를 사용합시다. 컴퓨터에서 어느 버전의 파이썬이 돌 지 알고 있어야 합니다. 파이썬3 안에서도 버전에 따라 지원하지 않는 기능이 있을 수 있습니다. 개인적으로 Miniconda를 설치해서 파이썬을 사용합니다. 파이썬 버전을 명확하게 할 수 있고, 필요하다면 다른 버전을 추가로 설치해서 사용할 수도 있습니다. PC에 새롭게 파이썬을 설치한다면, Miniconda 사용을 추천합니다. ","date":"2020-11-28","objectID":"/2020-11-28_python-version/:2:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 1. 사용 중인 파이썬의 버전을 알아두라' 정리","uri":"/2020-11-28_python-version/#한-줄-요약-및-첨언"},{"categories":["python"],"content":" 기억해야 할 내용책에서 챕터 마지막 부분에 적혀있는 내용입니다. Tip Python 3 is the most up-to-date and well-supported version of Python, and you should use it for your projects. 파이썬 3는 파이썬 최신 버전이며 현재 가장 잘 지원되고 있다. 따라서 여러분은 프로젝트에서 파이썬 3를 써야 한다 Tip Be sure that the command-line executable for running Python on your system is the version you expect it to be. 여러분의 시스템에 있는 파이썬 실행 파일이 여러분이 원하는 버전인지 확인하라. Tip Avoid Python 2 because it will no longer be maintained after January 1, 2020. 파이썬 2는 사용하지 말라. 2020년 1월 1일부터 파이썬 2는 더 이상 지원되지 않는다. ","date":"2020-11-28","objectID":"/2020-11-28_python-version/:3:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 1. 사용 중인 파이썬의 버전을 알아두라' 정리","uri":"/2020-11-28_python-version/#기억해야-할-내용"},{"categories":["python"],"content":" 참고 자료 파이썬 코딩의 기술 (교보문고 링크) ","date":"2020-11-28","objectID":"/2020-11-28_python-version/:4:0","series":["effective python 1. 파이썬답게 생각하기"],"tags":["python"],"title":"'Better way 1. 사용 중인 파이썬의 버전을 알아두라' 정리","uri":"/2020-11-28_python-version/#참고-자료"},{"categories":["python"],"content":"기존 리스트에서 약간의 변형이 필요하거나 필터링이 필요할 때, 리스트 컴프리헨션을 이용해 짧은 코드로 원하는 리스트를 손쉽게 만들 수 있습니다. 아래는 각 과일에 “new_“를 붙인 새로운 리스트를 만들었습니다. \u003e\u003e\u003e fruits = ['apple', 'banana', 'melon'] \u003e\u003e\u003e ['new_' + fruit for fruit in fruits] ['new_apple', 'new_banana', 'new_melon'] 필터를 적용해서, 조건에 맞는 원소로만 리스트를 만들 수도 있습니다. \u003e\u003e\u003e nums = [-1, -2, 5, 8, -5, 20] \u003e\u003e\u003e new_nums = [num * 2 for num in nums if num \u003e 0] \u003e\u003e\u003e new_nums [10, 16, 40] 기본 문법은 아래와 같습니다. [\u003cexpression\u003e for \u003cvariable_name\u003e in \u003csequence\u003e if \u003ccondition\u003e] 위 문법을 풀어쓰면 아래와 같은 의미가 됩니다. result = [] for variable_name in sequence: if condition: result.append(expression) ","date":"2020-11-26","objectID":"/2020-11-26_list-comprehension/:0:0","series":null,"tags":["python"],"title":"리스트 컴프리헨션 (List Comprehension)","uri":"/2020-11-26_list-comprehension/#"},{"categories":["python"],"content":" Reference Practical Python Programming The Python Tutorial ","date":"2020-11-26","objectID":"/2020-11-26_list-comprehension/:1:0","series":null,"tags":["python"],"title":"리스트 컴프리헨션 (List Comprehension)","uri":"/2020-11-26_list-comprehension/#reference"}]